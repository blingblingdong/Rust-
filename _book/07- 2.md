# Day07 - crate與模組



## crate

Rust程式是由crate組成的，每一個crate都是一個單元，除了程式庫與可執行檔到原始碼，還有其他如範例、測試等東西，你很難避免使用第三方程式庫來組成一個運用良好的程式。

我們再過去的專案中，提過用`use`宣告式來宣告我們需要的crate


```rust
use num::Complex;
use std ::str::FromStr;
```

並且要在Cargo.toml中指定各版本的crate：


```rust
[dependencies]
num = "0.4"
image = "0.13"
crossbeam = "0.8"
```

`dependencies`代表這個專案需要的crate，當你執行`cargo build`時，Cargo會自動幫你下載這些crate，並且讀取crate的cargo.toml，下載這些crate，以此往復。

在Cargo取得原始碼後，它會編譯所有的crate，這裡不是執行main()，而是產生一個.rlib檔，在編譯器讀取後，會將程式碼靜態地連結至最終的可執行檔內。

### edtion

Rust有極強的相容性保證，但程式的進化可能導致舊版與新版出現彼此爭議。例如，Rust決定將識別符號async與await改成關鍵字，這樣的改變可能破壞async或await當成變數的程式碼。

因此在Cargo.toml中，你可以指定`edition`，這樣Cargo就會使用指定的edition來編譯程式碼。


```rust
edition = "2018"
```

如果沒有指定，Cargo會使用預設的edition，目前是2015。

### buid profile

你可以加入一些動態設定來改變cargo的動態命令，通常你只要維持預設值，除了你想要profiler時，它可以測量你的程式在哪裡花費CPU時間。要同時啟動優化與debug，你要加入：


```rust
[profile.release]
debug = true
```

## 模組

crate是在不同專案之間共用程式碼，而模組module與專案內的程式碼組織相關，以下是模組的範例：


```rust
mod spores {
  use cells::{Cell, Gene};
  
  
  pub struct Spore{
    ...
  }
  
  pub fn produce_spore(factory: &mut SpoerFactory) -> Spore{
    ...
  }
  
  pub(crate) fn genes(spore: &Spore) -> Vec<Gene>{
    ...
  }
  
  fn recombine(parent: &mut Cell) {
    ...
  }
  
}
```


`pub`是共用的，意思是你可以在模組外呼叫它們。而pub(crate)是僅限模組內共用，它不能在其他模組呼叫。沒有pub的是私有的，只能在定義它的模組內使用。

### 嵌套模組

嵌套模組的概念就是像俄羅斯娃娃般，在模組內放入模組：


```rust
mod transport {
  pub mod road {
    ...
  }
  
  pub mod rail {
    ...
  }
}
```

以上是錯誤的示範，因為你要確保包覆公開模組的模組也必須是公開的：


```rust
pub mod transport {
  pub mod road {
    pub mod car{
      pub(in crate::transport::road) fn drive(){
        ...
      }
    }
    use car::drive;// 正確，在模組內
  }
  

  pub mod rail {
    use road::car::drive;//錯誤，不在模組內
  }
}
```

這種模式雖然能讓你在單一檔案寫完所有程式，但這樣做容易讓程式碼難以維護。

## 不同檔案

第一，若只有一層模組，假設分為`main.rs`與`spores.rs`，你可以先在`main.rs`中宣告模組：


```rust
mod spores;
```

接著，直接在`spores.rs`中寫入模組的函式、變數


```rust
pub struct Spore{
  ...
}

pub fn produce_spore(factory: &mut SpoerFactory) -> Spore{
  ...
}

pub(crate) fn genes(spore: &Spore) -> Vec<Gene>{
  ...
}

fn recombine(parent: &mut Cell) {
  ...
}
```

當你組建carte時，Rust看到`mod spores`時，會尋找`spores.rs`或`spores/mod.rs`，這樣就可以找到模組。

若是模組中的模組，你可以為模組創建自己的資料夾，首先在main.rs宣告：


```rust
pub mod transport;
```

我們一樣假設transport底下有三層：`road`、`rail`、`sea`，你要先在transport/mod.rs中宣告：


```rust
pub mod road;
pub mod rail;
pub mod sea;
```

若road底下還有car與bus，你可以在road/mod.rs中宣告：


```rust
pub mod car;
pub mod bus;
```

整個結構會像這樣：

```
.
├── Cargo.toml
└── src
    ├── children.rs
    ├── main.rs
    └── road
        ├── bus.rs
        ├── car.rs
        └── mod.rs
```

### 路徑與匯入


`::`運算子讓你引用程式庫的功能，你可以直接寫出完整的引用，或已先將功能匯入模組再使用


```rust
let mut map1 = std::collections::HashMap::new();

use std::collections::HashMap;
let mut map2 = HashMap::new();
```

後者概念很簡單，就是把`std::collections::HashMap`用HashMap取代，這樣你就可以直接使用HashMap。

你可以ㄧ次匯入多個、所有模組：


```rust
use std::collections::{HashMap, HashSet};// 一次匯入多個
use std::collections::*;// 匯入所有
use std::collections::HashMap as Map;// 別名
use std::fs::{self, File};// 匯入fs與File
```

模組不會自動繼承父模組的功能，例如在protiens/mod.rs：


```rust
// proteins/mod.rs
pub enum AminoAcid {
  ...
}

pub mod enzymes {
  pub struct Enzyme {
    ...
  }
}
```

那麼，在proteins/synthesis.rs，你可能想在synthesis.rs中使用AminoAcid與Enzyme，你必須在synthesis.rs中匯入：


```rust
// proteins/synthesis.rs
pub fn synthesize(seq: &[AminoAcid]) // 錯誤

use super::AminoAcid // 必須從父輩匯入
```

如果你想在父輩模組用子模組的功能，依然要明確指出路徑


```rust
// proteins/mod.rs

use synthesis::synthesize;
```

相較於`super`關鍵字，`crate`是指包住當前模組的crate，這樣寫可以讓模組更具彈性，不會因為模組的位置而受限。


```rust
// proteins/synthesis.rs
use crate::protiens::AminoAcid;

pub fn synthesize(seq: &[AminoAcid]) {
  ...
}
```

有時候你的模組名稱與第三方crate名稱相同，當然你要盡量避免這件事，有兩種方法可以解決這件事，`self`與`::`:


```rust
use image::Pixels; //會與crate名稱衝突

use ::image::Pixels;
use self::image::Pixels;
```

### pub的struct

struct關鍵字在Rust相當常用，你可以在struct自訂的結構型態。ㄧ般的struct是私有的，你可以用pub讓它變成公開的：


```rust
pub struct Spore {
  pub genes: Vec<Gene>,
  pub age: u32
}
```


當struct是公開的，它的子輩與整個模組都可以使用它，這種透過**模組控制存取**其實是一種很好的設計模式，相較於Java或C++**類別控制存取**，減少了「getter」與「setter」的使用，以下附上範例

::: panelset
::: panel

## Rust {-}

### library.rs


```rust
mod library {
    pub struct Book {
        pub title: String,
        author: String, // 默認是私有的
    }

    pub fn new_book(title: &str, author: &str) -> Book {
        Book {
            title: title.to_string(),
            author: author.to_string(),
        }
    }
}
```


### main.rs


```rust
fn main() {
    let book = library::new_book("The Rust Book", "Steve");
    println!("Title: {}", book.title); // 可以訪問公開的字段
    // println!("Author: {}", book.author); // 無法訪問私有字段
}
```
:::

::: panel
## Java{-}

### Library.java


```java
public class Library {
    // 定義內部的 Book 類別
    public static class Book {
        private String title;
        private String author;

        // 公開的構造函數
        public Book(String title, String author) {
            this.title = title;
            this.author = author;
        }

        // 公開的 getter 方法
        public String getTitle() {
            return title;
        }

        // 私有的 getter 方法
        private String getAuthor() {
            return author;
        }
    }

    // 創建新 Book 的靜態方法
    public static Book newBook(String title, String author) {
        return new Book(title, author);
    }
}
```

### Main.java


```java
public class Main {
    public static void main(String[] args) {
        Library.Book book = Library.newBook("The Rust Book", "Steve");
        System.out.println("Title: " + book.getTitle());
        // System.out.println("Author: " + book.getAuthor()); // 無法訪問私有方法
    }
}
```

:::
:::

## 將程式轉換成程式庫

你一開始構想寫一個模擬蕨類生長的程式，你後來發現許多函式需要重複使用，你決定將程式轉換成一整個程式庫，先來看一下你的程式：


```rust
struct feather{
  size: f64,
  growth_rate: f64
}

impl Fern {
  /// 模擬生長過程
  fn grow(&mut self){
    self.size *= 1.0 + self.growth_rate;
  }
}

fn run_simulation(fern: &mut Fern, days: usize){
  for _ in 0..days{
    fern.grow();
  }
}

fn main() {
  let mut fern = Fern {
    size:1.0,
    growth_rate: 0.001
  };
  run_simulation(&mut fern, 1000);
  println!("final fern size: {}", fern.size);
}
```


- 先將main函式移出，我們等等再處理

- 把原檔名(main.rs)改成lib.rs

- 接著，把函式改成`pub`，以便其他程式使用


```rust
pub struct Fern {
    pub size: f64,
    pub growth_rate: f64
  }

impl Fern {
    /// 模擬生長過程
    pub fn grow(&mut self){
      self.size *= 1.0 + self.growth_rate;
    }
  }

pub fn run_simulation(fern: &mut Fern, days: usize){
    for _ in 0..days{
      fern.grow();
    }
  }
```

這個程式庫算建立好了，如果你想在這個程式庫裡執行程式，你可以在src下再創一個bin目錄，並再下創一個rs檔，這裡以efern.rs為例：


```rust
// src/bin/efern.rs
use fern_sim::{Fern, run_simulation};

fn main() {
    let mut fern = Fern {
        size: 1.0,
        growth_rate: 0.001,
    };
    run_simulation(&mut fern, 1000);
    println!("final fern size: {}", fern.size);
}
```


接著就可以用`build`建立程式庫，並聲明你要跑的程式：

```
cargo build --verbose

cargo run --bin efern
    Finished dev [unoptimized + debuginfo] target(s) in 0.00s
     Running `target/debug/efern`
final fern size: 2.7169239322355985
```

回顧一下整個結構：

```
├── Cargo.lock
├── Cargo.toml
└── src
    ├── bin
    │   └── efern.rs
    └── lib.rs
```

假如你想要在其他專案中使用程式庫，例如我們要在teer程式模擬，先在teer.toml中加入：


```rust
[dependencies]
fern_sim = { path = "../fern_sim"}
```

記得要將fern_sim專案放入teer專案，其他都幾乎一樣，來看一下結構

```
.
├── Cargo.lock
├── Cargo.toml
├── fern_sim
│   ├── Cargo.lock
│   ├── Cargo.toml
│   └── src
│       ├── bin
│       │   └── efern.rs
│       └── lib.rs
└── src
    └── main.rs
```

## 屬性

例如，你希望用非camelCase的變數名稱，你可以在變數前加上`#[allow(non_camel_case_types)]`，這樣Rust就不會報錯：


```rust
#[allow(non_camel_case_types)]
pub struct HTTPResponse {
  ...
}
```


還有常見的條件式編譯，也就是#[cfg]

<table>
  <tr>
    <th>條件</th>
    <th>說明</th>
  </tr>
  <tr>
    <td>test</td>
    <td>啟用測試</td>
  </tr>
  <tr>
    <td>debug_assertions</td>
    <td>啟用偵測斷言</td>
  </tr>
  <tr>
    <td>unix</td>
    <td>為Unix編譯</td>
  </tr>
  <tr>    
    <td>target_pointer_width = "64"</td>
    <td>針對64-bit平台，另外還有32bit</td>
  </tr>
  <tr>
    <td>target_arch = "x86_64</td>
    <td>其他還有：x86、arm、aarch64</td>
  </tr>
  <tr>
    <td>target_os = "macos"</td>
    <td>其他還有：windows、"ios"、android、linux</td>
  </tr>
  <tr>
    <td>unix</td>
    <td>Unix-like系統</td>
  </tr>
  <tr>
    <td>windows</td>
    <td>Windows系統</td>
  </tr>
  <tr>
    <td>feature = "robot"</td>
    <td>啟動名為feature的自訂功能，功能在cargo區域內的feature區域宣告</td>
  </tr>
  <tr>
    <td>all</td>
    <td>滿足A與B的狀況</td>
  </tr>
  <tr>
    <td>any</td>
    <td>A或B滿足</td>
  </tr>
  <tr>
    <td>not(A)</td>
    <td>不滿足A的狀況</td>
  </tr>
</table>

假如你想視情況讓程式顯示英文或中文，你可以先在主程式：


```rust
fn main() {
    hello();
}

#[cfg(not(feature = "english"))]
fn hello() {
    println!("你好，世界！");
}

#[cfg(feature = "english")]
fn hello() {
    println!("Hello, world!");
}
```

接著在Cargo.toml中加入：


```rust
[features]
default = []
english = []
```


這樣你就可以用`cargo run`來執行中文版本，或是`cargo run --features english`來執行英文版本。

另外的例子是你想在不同平台發布：


```rust
fn main() {
    platform_specific_function();
}

#[cfg(target_os = "windows")]
fn platform_specific_function() {
    println!("This is Windows!");
}

#[cfg(not(target_os = "windows"))]
fn platform_specific_function() {
    println!("This is not Windows!");
}
```


這裡就無需在Cargo.toml中加入任何東西，Rust會依據你的平台自動判斷。

最後，如果你想讓整個屬性覆蓋到你整個crate，你可以在文件最上方加入`#![...]`



```rust
#![allow(dead_code)]

fn main() {
    let x = 5;
    println!("x = {}", x);
}
```

## 測試

我們在過去就曾用`#[test]`來測試程式，只要有這個標籤，在`cargo test`時，Rust就會執行這個函式。

假設你輸入`cargo test math`，Rust就會執行名稱有math的測試。

在簡單的程式中，我們可以用`assert!`或`assert_eq!`來測試，但前兩者會被放入release build中，你可以改用`debug_assert!`或`debug_assert_eq!`，這樣只有在debug build中才會執行。

### 整合測試

當你的程式庫建立好後，你可能會想將測試放到程式庫外。這時候你可以在src同一層的test目錄下創建一個rs檔，舉個例子：


```rust
// test/unfurl.rs

use fern_sim::Terrarium;
use std::time::Duration;

#[test]
fn test_fiddlehead_unfurling() {
    let mut t = Terrarium::new();
    t.add_plant("fiddlehead", 0.1, 0.01);
    t.advance(Duration::from_secs(1));
    assert_eq!(t.get_plant("fiddlehead").unwrap().size, 0.11);
}
```

整合測試的價值是它可以像其他用戶看待你的程式庫，他們測試的是crate公開的API。

cargo test會執行所有測試，包括整合測試，但你也可以用`cargo test --test unfurl`來執行單一測試。

## 文件

cargo doc的命令可以為你建立HTML文件，建立的文件會放在target/doc下：

```
cargo doc --open --no-deps
```

`--open`會自動開啟瀏覽器，`--no-deps`會只建立你的程式庫文件，不會建立依賴的文件。

你可以在程式上，以`///`或`[#doc=...]`來寫註解，若想為整個模組寫註解，可以在模組前加上`//!`，這樣你的註解就會被放入文件中。

![](doc.png)
Rust有個特殊功能，就是Markdown的連結可以使用Rust項目指出它引用什麼，而不是相對URL，例如leaves::Leaf，例如這段程式會產生VascularPath、Leaf的文件網頁；


```rust
/// 建立並回傳一個[`VascularPath`]，代表
/// 從[`Root`][r]到[`leaf`](leaves::Leaf)的路徑。
///
/// [r]: roots::Root
pub fn trace_path(leaf: &Leaf) -> VascularPath {
    ...
}
```

你可以加入`#[doc(alias = "...")]，來為搜尋引擎提供別名

如果你像要在文件中加入外部文件，你可以用`#![doc(include = "filename")]`，這樣你的文件就會被加入。   

### doc test

你可以在文件中加入程式碼區塊：


```rust
/// # Examples
/// ```
/// if samples::everything().works() {
///     println!("all good!");
/// }
/// ```
```

它會被當成測試執行，而這種測試就很適合使用`assert!`或`assert_eq!`，這樣你就可以確保文件中的程式碼是正確的。

如果你想要測試，但又想隱藏部分程式碼，你可以用`#`來隱藏：


```rust
/// # Examples
/// ```
/// # use samples::everything;
/// if everything().works() {
///    println!("all good!");
/// }
/// ```
```

又或者你不想讓它變成測試的ㄧ部分，你可以用`ignore`或`no_run`，但`no_run`仍然會測試可不可以編譯：


```rust
/// # Examples
/// ```no_run
/// use samples::everything;
/// if everything().works() {
///    println!("all good!");
/// }
/// ```
```


## 指定依賴項目

首先，如果你想要依賴項目不是在crates.io上面發布的。對此，你可以從Git版本庫URL與revision來指定：


```rust
image = {git = "...", rev = "..."}
```

另一種是指出存放crate原始碼的目錄：


```rust
image = {path = "../image"}
```



