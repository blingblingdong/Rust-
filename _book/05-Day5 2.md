# Day5-運算式

Rust是運算式語言，幾乎所有工作都是由運算式完成。

### 區塊與分號

區塊`{}`是最簡單的運算式，會產生一個值，如下例中，大區塊的結果是`author.name()`或`ip.to_string()`，None的區塊產生的值是沒有分號的`ip.to_string()`。



```rust
let display_name = match post.author() {
    Some(author) => author.name(),
    None => {
      let network_info = post.get_network_metadata()?;
      let ip = network_info.ip();
      ip.to_string()
    }
}

```

Rust的每一個分號都是有意義的，如在區塊中，通常以()作為回傳的值，但若出現沒有分號的運算式，就會回傳該運算式的值，請再看下面的例子：


```rust
let message{
  // let宣告式必須有分號
  let controler = puffball.open();
  
  // 運算式加上分號，，是呼叫方法，並卸除回傳值
  controler.run();
  
  // 運算式沒有分號，是呼叫方法，並回傳值
  // 此例中即回傳給message
  controler.message()
}
```

## 宣告式

宣告式最常見的是let，用來宣告區域變數。你可以在宣告同時初始化，也可以選擇不這麼做：


```rust
let Alex = "Alex";
let age;

if user.is_adult() {
  age = 18;
} else {
  age = 12;
}
```

在宣告後初始化是很常見的手段，還有有些時候會重複宣告：


```rust
for line in file.lines() {
  let line = line?;
}

// 同等的形式是：
for line_result in file.lines() {
  let line = line_result?;
}
```

我們稱這種形式為「shadowing」，第一個line的型態與第二個不同。但有時會造成ㄧ些混淆，所以也可以用另外一個變數取代，如範例中的line_result。


第二種是**項目宣告式(item declaration)**，項目指可以在全域中出現，例如fn、struct或use。

以fn為例，任何區塊都可以容忍fn：


```rust
use std::io;
use std::cmp::Ordering;

fn show_files() -> io::Result<()> {
  let mut v = vec![];
  ...
  
  fn cmp_by_timestamp_then_name(a: &File, b: &File) -> Ordering {
    ...
  }
  
  v.sort_by(cmp_by_timestamp_then_name);
  ...
  
}
```

## if與match

if的形式應該非常熟悉，只要記得你不用幫條件式加上括號


```rust
if condition1 {
  ...
} else if condition2 {
  ...
} else {
  ...
}
```

match與swtch非常相似，以下這個範例是4個分支，最後一個_是萬用分支，類似default，要記得它永遠放在最後。


```rust
match guess.cmp(&secret_number){
    Ordering:Less => rprintln!("太小了！"),
    Ordering:Greater => rprintln!("太大了！"),
    Ordering:Equal => {
        rprintln!("猜對了！");
        break;
    }
    _ => rprintln!("錯誤！"),
}
```

match的限制是，你的選項必須涵蓋所有可能的值，否則會發生錯誤：


```rust
let score = 5;

match score {
  1 => println!("糟糕！"),
  2 => println!("還好！"),
  3 => println!("不錯！"),
}
```

```
✖ error[E0004]: non-exhaustive patterns: `i32::MIN..=0_i32` and `4_i32..=i32::MAX` not covered
 --> src/lib.rs:7:7
  |
7 | match score {
  |       ^^^^^ patterns `i32::MIN..=0_i32` and `4_i32..=i32::MAX` not covered
  |
  = note: the matched value is of type `i32`
help: ensure that all possible cases are being handled by adding a match arm with a wildcard pattern, a match arm with multiple or-patterns as shown, or multiple match arms
```

另外一個規則是，若有回傳值，則每個分支欲回傳的值必須為**相同型態**，不管是if或match都是如此。

## 迴圈

Rust的迴圈是運算式，但while與loop的回傳值是()，沒有什麼用。而loop可以在有指定情況下，產生回傳值


```rust
while condition {
  ...
}

loop {
  ...
}

for pattern in iterable {
  ...
}
```

for 迴圈我相信大家也都很熟了，有幾個小細節可以提醒你：


```extendr
for i in 0..5 {
  rprintln!("{}", i);
}
```
`..`是產生一個範圍，依種簡單的struct，如上例是`{start: 0, end: 5}`，

### 迴圈的流程控制

`break`只用在圍封迴圈中，不會用在`match`中，與其他程式稍有不同，它可以讓你跳出回圈，並且指定一個運算式給他，而這個運算式的值就是回傳值。


```extendr
let x = [1, 2, 3, 4, 5];
let mut a:usize = 0;

loop {
  if a == 5 {
    break rprint!("x被耗用了\n");
  }else{
    a = x[a];
    rprint!("{}\n", a);
  }
}
```

`continue`則是會跳過這次迭代，繼續下一次迭代。


```extendr
for number in 1..=10 {
  if number % 2 == 0 {
    continue;
  }
  rprintln!("{}", number);
}
```

你可以標記一個外部迴圈，讓break或continue可以直接穿越到標記的迴圈，標記的方法是在標記名稱前加上`'`，如`'h`、`'search`等。




```extendr
let x = [1, 2, 3, 4, 5];

let a = 'h : loop {
  for i in 0..5 {
    if x[i] == 3 {
      break 'h i;
    }else{
      rprint!("{}\n", x[i]);
    }
  }
};

```


### 函式呼叫與方法呼叫

在Rust裡，總共有3種呼叫形式，函式呼叫、方法呼叫、型態關聯函式呼叫。


```rust
let x = gcd(1302, 462); //函式呼叫

let room = player.location().ip(); //方法呼叫
// 方法呼叫可以串連

let mut numbers = Vec::new(); //型態關聯函式呼叫

```


有一件奇怪的事情，那就是Rust在呼叫時，`Vec<T>`是無效的，你應該用::Vec<T>，或是尤機器判斷回傳型態。


```rust
return Vec<i32>::with_capacity(10);// 錯誤
return Vec::<i32>::with_capacity(10);// 正確
return Vec::with_capacity(10);// 正確
```

## 欄位與元素

`.`可以取出struct與tuple的元素，前者是以名字，後者是以數字

`[]`可以操作陣列、向量、字串，取出元素。


```rust
game.player // struct
coords.0 // tuple
pices[0] // array
```


用..可以幫助你省略運算元，而`..=`則是包含運算元。



```extendr
let x = [1, 2, 3, 4, 5];

// {start:a-1, end:b+1}從a到b
let s1 = &x[1..=2];
rprintln!("{:?}",s1);

// {end:b+1}但包含b
let s2 = &x[..=2];
rprintln!("{:?}",s2);

// 全部
let s3 = &x[..];
rprintln!("{:?}",s3);

// {start:a}從a的後一個到最後
let s4 = &x[1..];
rprintln!("{:?}",s4);
 
// {start:a, end:b}從a的後一個到b的前一個
let s5 = &x[1..4];
rprintln!("s5 = {:?}",s5);

// {end:b}表示到b的前一個
let s6 = &x[..4];
rprintln!("s6 = {:?}",s6);

```





