<!DOCTYPE html>
<html lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<title>Chapter 4 所有權與移動 | Rust之書</title>
<meta name="author" content="董宸賓">
<meta name="description" content="4.1 所有權與移動 為了讓整個程式能更好的運用記憶體，我們指望程式能做到兩件事： 1.指標絕對不能指向已釋出的物件，避免未定義行為造成安全漏洞 2.用有自行決定記憶體何時釋放與速度的權利，減少無意義的損耗 但想同時擁有這兩項優勢並不容易，尤其是高度的記憶體自由，由你掌控何時釋出，容易造成值的指標懸空。目前的程式可依者兩種優點而分為兩種陣營。...">
<meta name="generator" content="bookdown 0.36.2 with bs4_book()">
<meta property="og:title" content="Chapter 4 所有權與移動 | Rust之書">
<meta property="og:type" content="book">
<meta property="og:description" content="4.1 所有權與移動 為了讓整個程式能更好的運用記憶體，我們指望程式能做到兩件事： 1.指標絕對不能指向已釋出的物件，避免未定義行為造成安全漏洞 2.用有自行決定記憶體何時釋放與速度的權利，減少無意義的損耗 但想同時擁有這兩項優勢並不容易，尤其是高度的記憶體自由，由你掌控何時釋出，容易造成值的指標懸空。目前的程式可依者兩種優點而分為兩種陣營。...">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Chapter 4 所有權與移動 | Rust之書">
<meta name="twitter:description" content="4.1 所有權與移動 為了讓整個程式能更好的運用記憶體，我們指望程式能做到兩件事： 1.指標絕對不能指向已釋出的物件，避免未定義行為造成安全漏洞 2.用有自行決定記憶體何時釋放與速度的權利，減少無意義的損耗 但想同時擁有這兩項優勢並不容易，尤其是高度的記憶體自由，由你掌控何時釋出，容易造成值的指標懸空。目前的程式可依者兩種優點而分為兩種陣營。...">
<!-- JS --><script src="https://cdnjs.cloudflare.com/ajax/libs/clipboard.js/2.0.6/clipboard.min.js" integrity="sha256-inc5kl9MA1hkeYUt+EC3BhlIgyp/2jDIyBLS6k3UxPI=" crossorigin="anonymous"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/fuse.js/6.4.6/fuse.js" integrity="sha512-zv6Ywkjyktsohkbp9bb45V6tEMoWhzFzXis+LrMehmJZZSys19Yxf1dopHx7WzIKxr5tK2dVcYmaCk2uqdjF4A==" crossorigin="anonymous"></script><script src="https://kit.fontawesome.com/6ecbd6c532.js" crossorigin="anonymous"></script><script src="libs/jquery-3.6.0/jquery-3.6.0.min.js"></script><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<link href="libs/bootstrap-4.6.0/bootstrap.min.css" rel="stylesheet">
<script src="libs/bootstrap-4.6.0/bootstrap.bundle.min.js"></script><script src="libs/bs3compat-0.5.1/transition.js"></script><script src="libs/bs3compat-0.5.1/tabs.js"></script><script src="libs/bs3compat-0.5.1/bs3compat.js"></script><link href="libs/bs4_book-1.0.0/bs4_book.css" rel="stylesheet">
<script src="libs/bs4_book-1.0.0/bs4_book.js"></script><link href="libs/panelset-0.2.6/panelset.css" rel="stylesheet">
<script src="libs/panelset-0.2.6/panelset.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/autocomplete.js/0.38.0/autocomplete.jquery.min.js" integrity="sha512-GU9ayf+66Xx2TmpxqJpliWbT5PiGYxpaG8rfnBEk1LL8l1KGkRShhngwdXK1UgqhAzWpZHSiYPc09/NwDQIGyg==" crossorigin="anonymous"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/mark.js/8.11.1/mark.min.js" integrity="sha512-5CYOlHXGh6QpOFA/TeTylKLWfB3ftPsde7AnmhuitiTX4K5SqCLBeKro6sPS8ilsz1Q4NRx3v8Ko2IBiszzdww==" crossorigin="anonymous"></script><!-- CSS --><style type="text/css">
    
    div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
  </style>
<link rel="stylesheet" href="style.css">
</head>
<body data-spy="scroll" data-target="#toc">

<div class="container-fluid">
<div class="row">
  <header class="col-sm-12 col-lg-3 sidebar sidebar-book"><a class="sr-only sr-only-focusable" href="#content">Skip to main content</a>

    <div class="d-flex align-items-start justify-content-between">
      <h1>
        <a href="index.html" title="">Rust之書</a>
      </h1>
      <button class="btn btn-outline-primary d-lg-none ml-2 mt-1" type="button" data-toggle="collapse" data-target="#main-nav" aria-expanded="true" aria-controls="main-nav"><i class="fas fa-bars"></i><span class="sr-only">Show table of contents</span></button>
    </div>

    <div id="main-nav" class="collapse-lg">
      <form role="search">
        <input id="search" class="form-control" type="search" placeholder="Search" aria-label="Search">
</form>

      <nav aria-label="Table of contents"><h2>Table of contents</h2>
        <ul class="book-toc list-unstyled">
<li><a class="" href="index.html"><span class="header-section-number">1</span> About</a></li>
<li><a class="" href="day1---%E5%88%B0%E8%99%95%E7%9C%8B%E7%9C%8B.html"><span class="header-section-number">2</span> Day1 - 到處看看</a></li>
<li><a class="" href="day2---%E5%9E%8B%E6%85%8B.html"><span class="header-section-number">3</span> Day2 - 型態</a></li>
<li><a class="active" href="%E6%89%80%E6%9C%89%E6%AC%8A%E8%88%87%E7%A7%BB%E5%8B%95.html"><span class="header-section-number">4</span> 所有權與移動</a></li>
<li><a class="" href="%E5%8F%83%E8%80%83.html"><span class="header-section-number">5</span> 參考</a></li>
<li><a class="" href="r_unique.html"><span class="header-section-number">6</span> R_unique</a></li>
</ul>

        <div class="book-extra">
          <p><a id="book-repo" href="https://github.com/rstudio/bookdown-demo">View book source <i class="fab fa-github"></i></a></p>
        </div>
      </nav>
</div>
  </header><main class="col-sm-12 col-md-9 col-lg-7" id="content"><div id="所有權與移動" class="section level1" number="4">
<h1>
<span class="header-section-number">4</span> 所有權與移動<a class="anchor" aria-label="anchor" href="#%E6%89%80%E6%9C%89%E6%AC%8A%E8%88%87%E7%A7%BB%E5%8B%95"><i class="fas fa-link"></i></a>
</h1>
<div id="所有權與移動-1" class="section level2" number="4.1">
<h2>
<span class="header-section-number">4.1</span> 所有權與移動<a class="anchor" aria-label="anchor" href="#%E6%89%80%E6%9C%89%E6%AC%8A%E8%88%87%E7%A7%BB%E5%8B%95-1"><i class="fas fa-link"></i></a>
</h2>
<p>為了讓整個程式能更好的運用記憶體，我們指望程式能做到兩件事：</p>
<p>1.指標絕對不能指向已釋出的物件，避免<strong>未定義</strong>行為造成安全漏洞</p>
<p>2.用有自行決定記憶體何時釋放與速度的權利，減少無意義的損耗</p>
<p>但想同時擁有這兩項優勢並不容易，尤其是高度的記憶體自由，由你掌控何時釋出，容易造成值的指標<strong>懸空</strong>。目前的程式可依者兩種優點而分為兩種陣營。</p>
<p>安全派：使用<strong>垃圾回收</strong>的技術來管理記憶體，當所有指向該物件的指標消失時，它會自動釋放該物件，如此你不必為懸空指標憂慮，但同時你也失去了「自行決定何時將物件回收」的權利。目前幾乎所有程式都屬於這個派別，如C#、python、R、Java</p>
<p>自由派：你能選擇何時釋出記憶體，但避免懸空指標的出現全都是你的責任。此派主流語言只有：C和C++</p>
<p>而Rust生來就是要同時獲取兩種優勢，不然也沒必要學。因此，Rust用<strong>限制指標</strong>的使用來解決問題。這勢必會造成困擾，許多我們過去隨意使用的型態與寫法都將放棄。但也就是這些「困擾」，讓Rust能用編譯檢查機制來確保沒有安全混亂，如懸空指標、重複釋出、使用未初始化記憶體。</p>
<p>這一套秩序也是並行設計的根基，如<strong>執行緒基元(threading primitibve)</strong>確保沒有資料爭用問題。</p>
<p>在這些限制下寫出安全且靈活的程式，是你在學習Rust之路最大的挑戰，同時也是優勢。本章將帶你了解<strong>所有權</strong>的概念，比較不同語言的運作方式，進而學習如何處理與追蹤所有權的改變。</p>
</div>
<div id="所有權" class="section level2" number="4.2">
<h2>
<span class="header-section-number">4.2</span> 所有權<a class="anchor" aria-label="anchor" href="#%E6%89%80%E6%9C%89%E6%AC%8A"><i class="fas fa-link"></i></a>
</h2>
<p>C++與C是由所有權人決定何時釋出物件，當所有權人銷毀時，物件也被毀滅。</p>
<div class="sourceCode" id="cb50"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb50-1"><a href="%E6%89%80%E6%9C%89%E6%AC%8A%E8%88%87%E7%A7%BB%E5%8B%95.html#cb50-1" tabindex="-1"></a>std <span class="op">::</span> string s <span class="op">=</span> <span class="st">"hello"</span><span class="op">;</span></span></code></pre></div>
<p>在堆疊中，std::string的長是<strong>3 word</strong>，分別裝的是<strong>緩衝區</strong>、<strong>容量</strong>、<strong>長度</strong>，他們都會指向heap，而hello就被放在heap中。</p>
<p>當字串被銷毀時，字串的解構式(destructor)會被呼叫，這時std::string會釋放heap中的記憶體。你可以建立臨時指標來指向他人擁有的記憶體(如s擁有的h字元)，但當s字串被註銷時，指標就會無效，不得再使用。</p>
<p>這種<strong>賦予所有權人絕對性的權利決定擁有物件的生命週期</strong>的方式，也是Rust的核心概念。每個值都需有決定期生命週期的所有權人，當所有權人被釋出(dropped)時，值也會被釋出。讓編譯器可以ㄧ眼看穿每一個值的生命週期，並以此檢測漏洞。</p>
<p>在Rust中，當控制離開宣告該變數的區塊時，變數銷毀，同時卸除值。</p>
<p>以Rust的Box為例，Box<t><strong>指向heap裡T型態值的指標</strong>。當你呼叫Box::new(v)的時候，系統會配置空間將v塞入，並且回傳一個指向該空間的Box。當box銷毀時，空間釋出。</t></p>
<div class="sourceCode" id="cb51"><pre class="sourceCode rust"><code class="sourceCode rust"><span id="cb51-1"><a href="%E6%89%80%E6%9C%89%E6%AC%8A%E8%88%87%E7%A7%BB%E5%8B%95.html#cb51-1" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb51-2"><a href="%E6%89%80%E6%9C%89%E6%AC%8A%E8%88%87%E7%A7%BB%E5%8B%95.html#cb51-2" tabindex="-1"></a>   <span class="kw">let</span> point <span class="op">=</span> <span class="dt">Box</span><span class="pp">::</span>new((<span class="dv">11</span><span class="op">,</span> <span class="dv">13</span>))<span class="op">;</span>  <span class="co">//ponit在此配置</span></span>
<span id="cb51-3"><a href="%E6%89%80%E6%9C%89%E6%AC%8A%E8%88%87%E7%A7%BB%E5%8B%95.html#cb51-3" tabindex="-1"></a>   <span class="kw">let</span> label <span class="op">=</span> <span class="pp">format!</span>(<span class="st">"{:?}"</span><span class="op">,</span> point)<span class="op">;</span> <span class="co">//label在此配置</span></span>
<span id="cb51-4"><a href="%E6%89%80%E6%9C%89%E6%AC%8A%E8%88%87%E7%A7%BB%E5%8B%95.html#cb51-4" tabindex="-1"></a>   <span class="pp">println!</span>(<span class="st">"label：{}"</span><span class="op">,</span> label)<span class="op">;</span></span>
<span id="cb51-5"><a href="%E6%89%80%E6%9C%89%E6%AC%8A%E8%88%87%E7%A7%BB%E5%8B%95.html#cb51-5" tabindex="-1"></a>   <span class="pp">println!</span>(<span class="st">"point：{:?}"</span><span class="op">,</span> point)<span class="op">;</span></span>
<span id="cb51-6"><a href="%E6%89%80%E6%9C%89%E6%AC%8A%E8%88%87%E7%A7%BB%E5%8B%95.html#cb51-6" tabindex="-1"></a><span class="op">}</span>  <span class="co">//point與label在此銷毀</span></span>
<span id="cb51-7"><a href="%E6%89%80%E6%9C%89%E6%AC%8A%E8%88%87%E7%A7%BB%E5%8B%95.html#cb51-7" tabindex="-1"></a>#<span class="op">&gt;</span> NULL</span></code></pre></div>
<p>堆疊框本身保有變數(point、label)，兩個Box指向個別的heap空間。</p>
<p>而在變數被卸除時，他們擁有的空間也會被釋放。</p>
<p>舉另外一個複雜的例子，同時有tuple、struct、String、向量</p>
<div class="sourceCode" id="cb52"><pre class="sourceCode rust"><code class="sourceCode rust"><span id="cb52-1"><a href="%E6%89%80%E6%9C%89%E6%AC%8A%E8%88%87%E7%A7%BB%E5%8B%95.html#cb52-1" tabindex="-1"></a>strut Person <span class="op">{</span></span>
<span id="cb52-2"><a href="%E6%89%80%E6%9C%89%E6%AC%8A%E8%88%87%E7%A7%BB%E5%8B%95.html#cb52-2" tabindex="-1"></a>    name<span class="op">:</span> <span class="dt">String</span><span class="op">,</span></span>
<span id="cb52-3"><a href="%E6%89%80%E6%9C%89%E6%AC%8A%E8%88%87%E7%A7%BB%E5%8B%95.html#cb52-3" tabindex="-1"></a>    birth<span class="op">:</span> <span class="dt">i32</span><span class="op">,</span></span>
<span id="cb52-4"><a href="%E6%89%80%E6%9C%89%E6%AC%8A%E8%88%87%E7%A7%BB%E5%8B%95.html#cb52-4" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb52-5"><a href="%E6%89%80%E6%9C%89%E6%AC%8A%E8%88%87%E7%A7%BB%E5%8B%95.html#cb52-5" tabindex="-1"></a></span>
<span id="cb52-6"><a href="%E6%89%80%E6%9C%89%E6%AC%8A%E8%88%87%E7%A7%BB%E5%8B%95.html#cb52-6" tabindex="-1"></a><span class="kw">let</span> <span class="kw">mut</span> composers <span class="op">=</span> <span class="dt">Vec</span><span class="pp">::</span>new()<span class="op">;</span></span>
<span id="cb52-7"><a href="%E6%89%80%E6%9C%89%E6%AC%8A%E8%88%87%E7%A7%BB%E5%8B%95.html#cb52-7" tabindex="-1"></a>composers<span class="op">.</span>push(Person <span class="op">{</span>name<span class="op">:</span> <span class="st">"Palestrina"</span><span class="op">.</span>to_string()<span class="op">,</span> birth<span class="op">:</span> <span class="dv">1525</span><span class="op">}</span>)<span class="op">;</span></span>
<span id="cb52-8"><a href="%E6%89%80%E6%9C%89%E6%AC%8A%E8%88%87%E7%A7%BB%E5%8B%95.html#cb52-8" tabindex="-1"></a>composers<span class="op">.</span>push(Person <span class="op">{</span>name<span class="op">:</span> <span class="st">"Dowland"</span><span class="op">.</span>to_string()<span class="op">,</span> birth<span class="op">:</span> <span class="dv">1563</span><span class="op">}</span>)<span class="op">;</span></span>
<span id="cb52-9"><a href="%E6%89%80%E6%9C%89%E6%AC%8A%E8%88%87%E7%A7%BB%E5%8B%95.html#cb52-9" tabindex="-1"></a>composers<span class="op">.</span>push(Person <span class="op">{</span>name<span class="op">:</span> <span class="st">"Lully"</span><span class="op">.</span>to_string()<span class="op">,</span> birth<span class="op">:</span> <span class="dv">1632</span><span class="op">}</span>)<span class="op">;</span></span>
<span id="cb52-10"><a href="%E6%89%80%E6%9C%89%E6%AC%8A%E8%88%87%E7%A7%BB%E5%8B%95.html#cb52-10" tabindex="-1"></a></span>
<span id="cb52-11"><a href="%E6%89%80%E6%9C%89%E6%AC%8A%E8%88%87%E7%A7%BB%E5%8B%95.html#cb52-11" tabindex="-1"></a><span class="cf">for</span> composer <span class="kw">in</span> <span class="op">&amp;</span>composers <span class="op">{</span></span>
<span id="cb52-12"><a href="%E6%89%80%E6%9C%89%E6%AC%8A%E8%88%87%E7%A7%BB%E5%8B%95.html#cb52-12" tabindex="-1"></a>    <span class="pp">println!</span>(<span class="st">"{}, born {}"</span><span class="op">,</span> composer<span class="op">.</span>name<span class="op">,</span> composer<span class="op">.</span>birth)<span class="op">;</span></span>
<span id="cb52-13"><a href="%E6%89%80%E6%9C%89%E6%AC%8A%E8%88%87%E7%A7%BB%E5%8B%95.html#cb52-13" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>在這個結構中，最上層的堆疊匡是composers，擁有一個向量，而緩衝區則指向放有各個以Person為型態的heap空間。接著，如birth：i32的定寬數字直接配置在heap中，而string則有其容量、長度、緩衝區指向heap中的字串。當控制離開宣告composers的作用域後，composers會被卸除，連帶地卸除整個配置。</p>
<p>如前所述，Rust會強迫每個值都有<strong>一個</strong>所有權人，但每一個所有人可以擁有多個值，如composers擁有3個Person元素。並且在複雜的架構中，會形成樹狀的架構，成為<strong>父子關係</strong>。當父親被銷毀時，他的子女也會被銷毀。如composers是3個元素的父輩，而3個元素又有個別的String子輩。因此在Rust中，你不會看到雜亂的架構，每一個值都是某棵樹的一分子。</p>
<p>上述講述的例子可能讓你覺得Rust是一個僵化語言，但實作上可以作出靈活的延伸</p>
<ul>
<li><p>透過所有權的移動，重新排列樹狀結構，</p></li>
<li><p>使用整數、浮點數、字元等簡單的型態，他們不受所有權的限制，稱為Copy型態</p></li>
<li><p>透過借用一個值的<strong>參考</strong>，使用這種<strong>無所有權、具有限生命週期的指標</strong></p></li>
<li><p>利用標準程式庫提供的參考計數(reference-counted)指標型態Rc與Arc，在特殊情況下讓值有多個所有權人</p></li>
</ul>
</div>
<div id="移動" class="section level2" number="4.3">
<h2>
<span class="header-section-number">4.3</span> 移動<a class="anchor" aria-label="anchor" href="#%E7%A7%BB%E5%8B%95"><i class="fas fa-link"></i></a>
</h2>
<p>在Rust中，大多數型態下，諸如將值指派給變數、將值回傳函式、從函式回傳值、將值傳遞給函式等操作，都不是<strong>複製</strong>，而是<strong>移動</strong>。當值被移動時，原本的變數為<strong>未初始化</strong>，該值的所有權被轉移。</p>
<p>因此在以下例子，s1的所有權被轉移給s2，s1變成未初始化，無法再使用，當你再嘗試把s1傳給s3時，編譯器會報錯。</p>
<div class="sourceCode" id="cb53"><pre class="sourceCode rust"><code class="sourceCode rust"><span id="cb53-1"><a href="%E6%89%80%E6%9C%89%E6%AC%8A%E8%88%87%E7%A7%BB%E5%8B%95.html#cb53-1" tabindex="-1"></a><span class="kw">let</span> s1 <span class="op">=</span> <span class="pp">vec!</span>[<span class="st">"aaa"</span><span class="op">.</span>to_string()<span class="op">,</span> <span class="st">"bbb"</span><span class="op">.</span>to_string()]<span class="op">;</span></span>
<span id="cb53-2"><a href="%E6%89%80%E6%9C%89%E6%AC%8A%E8%88%87%E7%A7%BB%E5%8B%95.html#cb53-2" tabindex="-1"></a><span class="kw">let</span> s2 <span class="op">=</span> s1<span class="op">;</span></span>
<span id="cb53-3"><a href="%E6%89%80%E6%9C%89%E6%AC%8A%E8%88%87%E7%A7%BB%E5%8B%95.html#cb53-3" tabindex="-1"></a><span class="kw">let</span> s3 <span class="op">=</span> s1<span class="op">;</span></span></code></pre></div>
<p>✖ error[E0382]: use of moved value: <code>s1</code>
–&gt; src/lib.rs:7:10
|
5 | let s1 = vec[“aaa”.to_string(), “bbb”.to_string()];
| – move occurs because <code>s1</code> has type <code>Vec&lt;String&gt;</code>, which does not implement the <code>Copy</code> trait
6 | let s2 = s1;
| – value moved here
7 | let s3 = s1;
| ^^ value used here after move</p>
<p>為什麽要有這種特性呢？我們可以先看兩個主流陣營的做法，比較優缺。</p>
<div id="python" class="section level3" number="4.3.1">
<h3>
<span class="header-section-number">4.3.1</span> python<a class="anchor" aria-label="anchor" href="#python"><i class="fas fa-link"></i></a>
</h3>
<div class="sourceCode" id="cb54"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb54-1"><a href="%E6%89%80%E6%9C%89%E6%AC%8A%E8%88%87%E7%A7%BB%E5%8B%95.html#cb54-1" tabindex="-1"></a>s1 <span class="op">=</span> [<span class="st">'aaa'</span>, <span class="st">'bbb'</span>]</span>
<span id="cb54-2"><a href="%E6%89%80%E6%9C%89%E6%AC%8A%E8%88%87%E7%A7%BB%E5%8B%95.html#cb54-2" tabindex="-1"></a>s2 <span class="op">=</span> s1</span>
<span id="cb54-3"><a href="%E6%89%80%E6%9C%89%E6%AC%8A%E8%88%87%E7%A7%BB%E5%8B%95.html#cb54-3" tabindex="-1"></a>s3 <span class="op">=</span> s1</span></code></pre></div>
<p>python的每個物件都有一個參考數量，以此來記錄有多少值引用他。ㄧ開始初始化s1時，PyListObject的參考數量為1，當s2=s1時，參考數量變為2，s3=s1時，參考數量變為3。這讓python的賦值成本很低，但因為每次都會建立新參考，也代表著必須紀錄參考數才能知道何時釋出。</p>
</div>
<div id="c" class="section level3" number="4.3.2">
<h3>
<span class="header-section-number">4.3.2</span> C++<a class="anchor" aria-label="anchor" href="#c"><i class="fas fa-link"></i></a>
</h3>
<div class="sourceCode" id="cb55"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb55-1"><a href="%E6%89%80%E6%9C%89%E6%AC%8A%E8%88%87%E7%A7%BB%E5%8B%95.html#cb55-1" tabindex="-1"></a>using namespace std<span class="op">;</span></span>
<span id="cb55-2"><a href="%E6%89%80%E6%9C%89%E6%AC%8A%E8%88%87%E7%A7%BB%E5%8B%95.html#cb55-2" tabindex="-1"></a>vector<span class="op">&lt;</span>string<span class="op">&gt;</span> s1 <span class="op">=</span> <span class="op">{</span><span class="st">"aaa"</span><span class="op">,</span> <span class="st">"bbb"</span><span class="op">};</span></span>
<span id="cb55-3"><a href="%E6%89%80%E6%9C%89%E6%AC%8A%E8%88%87%E7%A7%BB%E5%8B%95.html#cb55-3" tabindex="-1"></a>vector<span class="op">&lt;</span>string<span class="op">&gt;</span> s2 <span class="op">=</span> s1<span class="op">;</span></span>
<span id="cb55-4"><a href="%E6%89%80%E6%9C%89%E6%AC%8A%E8%88%87%E7%A7%BB%E5%8B%95.html#cb55-4" tabindex="-1"></a>vector<span class="op">&lt;</span>string<span class="op">&gt;</span> s3 <span class="op">=</span> s1<span class="op">;</span></span></code></pre></div>
<p>在C++中，當你將s1指派給s2時，會將整個副本都複製給s2。因此s1與s2都是獨立的，短短的幾行已經有3個向量、6個字串，如此的深度複製會造成損耗，但程式也容易決定何時釋出所有記憶體。</p>
</div>
<div id="rust" class="section level3" number="4.3.3">
<h3>
<span class="header-section-number">4.3.3</span> Rust<a class="anchor" aria-label="anchor" href="#rust"><i class="fas fa-link"></i></a>
</h3>
<p>如果你想要像C++一樣進行深複製，而不是移動，你應該呼叫向量的clone方法。</p>
<div class="sourceCode" id="cb56"><pre class="sourceCode rust"><code class="sourceCode rust"><span id="cb56-1"><a href="%E6%89%80%E6%9C%89%E6%AC%8A%E8%88%87%E7%A7%BB%E5%8B%95.html#cb56-1" tabindex="-1"></a><span class="kw">let</span> s1 <span class="op">=</span> <span class="pp">vec!</span>[<span class="st">"aaa"</span><span class="op">.</span>to_string()<span class="op">,</span> <span class="st">"bbb"</span><span class="op">.</span>to_string()]<span class="op">;</span></span>
<span id="cb56-2"><a href="%E6%89%80%E6%9C%89%E6%AC%8A%E8%88%87%E7%A7%BB%E5%8B%95.html#cb56-2" tabindex="-1"></a><span class="kw">let</span> s2 <span class="op">=</span> s1<span class="op">.</span>clone()<span class="op">;</span></span>
<span id="cb56-3"><a href="%E6%89%80%E6%9C%89%E6%AC%8A%E8%88%87%E7%A7%BB%E5%8B%95.html#cb56-3" tabindex="-1"></a><span class="kw">let</span> s3 <span class="op">=</span> s1<span class="op">.</span>clone()<span class="op">;</span></span></code></pre></div>
<p>你也可以使用我們前面提到的參考計數指標來模仿python的行為，也就是共享所有權。</p>
</div>
<div id="移動與控制" class="section level3" number="4.3.4">
<h3>
<span class="header-section-number">4.3.4</span> 移動與控制<a class="anchor" aria-label="anchor" href="#%E7%A7%BB%E5%8B%95%E8%88%87%E6%8E%A7%E5%88%B6"><i class="fas fa-link"></i></a>
</h3>
<p>因為Rust會移動值，因此在預到控制流程時，你必須把握「<strong>如果值可能被移動，則必須考慮初始化的風險</strong>」</p>
<div class="sourceCode" id="cb57"><pre class="sourceCode rust"><code class="sourceCode rust"><span id="cb57-1"><a href="%E6%89%80%E6%9C%89%E6%AC%8A%E8%88%87%E7%A7%BB%E5%8B%95.html#cb57-1" tabindex="-1"></a><span class="kw">let</span> s1 <span class="op">=</span> <span class="pp">vec!</span>[<span class="st">"aaa"</span><span class="op">.</span>to_string()<span class="op">,</span> <span class="st">"bbb"</span><span class="op">.</span>to_string()]<span class="op">;</span></span>
<span id="cb57-2"><a href="%E6%89%80%E6%9C%89%E6%AC%8A%E8%88%87%E7%A7%BB%E5%8B%95.html#cb57-2" tabindex="-1"></a><span class="cf">if</span> c <span class="op">{</span></span>
<span id="cb57-3"><a href="%E6%89%80%E6%9C%89%E6%AC%8A%E8%88%87%E7%A7%BB%E5%8B%95.html#cb57-3" tabindex="-1"></a>    <span class="kw">let</span> s2 <span class="op">=</span> s1<span class="op">;</span></span>
<span id="cb57-4"><a href="%E6%89%80%E6%9C%89%E6%AC%8A%E8%88%87%E7%A7%BB%E5%8B%95.html#cb57-4" tabindex="-1"></a><span class="op">}</span> <span class="cf">else</span> <span class="op">{</span></span>
<span id="cb57-5"><a href="%E6%89%80%E6%9C%89%E6%AC%8A%E8%88%87%E7%A7%BB%E5%8B%95.html#cb57-5" tabindex="-1"></a>    <span class="kw">let</span> s3 <span class="op">=</span> s1<span class="op">;</span></span>
<span id="cb57-6"><a href="%E6%89%80%E6%9C%89%E6%AC%8A%E8%88%87%E7%A7%BB%E5%8B%95.html#cb57-6" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb57-7"><a href="%E6%89%80%E6%9C%89%E6%AC%8A%E8%88%87%E7%A7%BB%E5%8B%95.html#cb57-7" tabindex="-1"></a>s4 <span class="op">=</span> s1<span class="op">;</span><span class="co">// 錯誤，s1可能已經被移動</span></span></code></pre></div>
<p>迴圈也會有類似的問題，有可能在回圈中s1就會被移動，導致s2會被賦予未初始化的值(空的s)。</p>
<div class="sourceCode" id="cb58"><pre class="sourceCode rust"><code class="sourceCode rust"><span id="cb58-1"><a href="%E6%89%80%E6%9C%89%E6%AC%8A%E8%88%87%E7%A7%BB%E5%8B%95.html#cb58-1" tabindex="-1"></a><span class="kw">let</span> s1 <span class="op">=</span> <span class="pp">vec!</span>[<span class="st">"aaa"</span><span class="op">.</span>to_string()<span class="op">,</span> <span class="st">"bbb"</span><span class="op">.</span>to_string()]<span class="op">;</span></span>
<span id="cb58-2"><a href="%E6%89%80%E6%9C%89%E6%AC%8A%E8%88%87%E7%A7%BB%E5%8B%95.html#cb58-2" tabindex="-1"></a><span class="cf">while</span> c <span class="op">{</span></span>
<span id="cb58-3"><a href="%E6%89%80%E6%9C%89%E6%AC%8A%E8%88%87%E7%A7%BB%E5%8B%95.html#cb58-3" tabindex="-1"></a>    <span class="kw">let</span> s2 <span class="op">=</span> s1<span class="op">;</span></span>
<span id="cb58-4"><a href="%E6%89%80%E6%9C%89%E6%AC%8A%E8%88%87%E7%A7%BB%E5%8B%95.html#cb58-4" tabindex="-1"></a>    <span class="cf">break</span><span class="op">;</span></span>
<span id="cb58-5"><a href="%E6%89%80%E6%9C%89%E6%AC%8A%E8%88%87%E7%A7%BB%E5%8B%95.html#cb58-5" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
</div>
<div id="移動與檢索" class="section level3" number="4.3.5">
<h3>
<span class="header-section-number">4.3.5</span> 移動與檢索<a class="anchor" aria-label="anchor" href="#%E7%A7%BB%E5%8B%95%E8%88%87%E6%AA%A2%E7%B4%A2"><i class="fas fa-link"></i></a>
</h3>
<p>一般來說，移動會將值的來源端變成未初始化，但許多情況下，所有權人會阻止隨意地移動。</p>
<div class="sourceCode" id="cb59"><pre class="sourceCode rust"><code class="sourceCode rust"><span id="cb59-1"><a href="%E6%89%80%E6%9C%89%E6%AC%8A%E8%88%87%E7%A7%BB%E5%8B%95.html#cb59-1" tabindex="-1"></a><span class="kw">let</span> <span class="kw">mut</span> v <span class="op">=</span> <span class="dt">Vec</span><span class="pp">::</span>new()<span class="op">;</span></span>
<span id="cb59-2"><a href="%E6%89%80%E6%9C%89%E6%AC%8A%E8%88%87%E7%A7%BB%E5%8B%95.html#cb59-2" tabindex="-1"></a><span class="cf">for</span> i <span class="kw">in</span> <span class="dv">101</span><span class="op">..</span><span class="dv">106</span> <span class="op">{</span></span>
<span id="cb59-3"><a href="%E6%89%80%E6%9C%89%E6%AC%8A%E8%88%87%E7%A7%BB%E5%8B%95.html#cb59-3" tabindex="-1"></a>    v<span class="op">.</span>push(i<span class="op">.</span>to_string())<span class="op">;</span></span>
<span id="cb59-4"><a href="%E6%89%80%E6%9C%89%E6%AC%8A%E8%88%87%E7%A7%BB%E5%8B%95.html#cb59-4" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb59-5"><a href="%E6%89%80%E6%9C%89%E6%AC%8A%E8%88%87%E7%A7%BB%E5%8B%95.html#cb59-5" tabindex="-1"></a></span>
<span id="cb59-6"><a href="%E6%89%80%E6%9C%89%E6%AC%8A%E8%88%87%E7%A7%BB%E5%8B%95.html#cb59-6" tabindex="-1"></a><span class="kw">let</span> third <span class="op">=</span> v[<span class="dv">2</span>]<span class="op">;</span></span>
<span id="cb59-7"><a href="%E6%89%80%E6%9C%89%E6%AC%8A%E8%88%87%E7%A7%BB%E5%8B%95.html#cb59-7" tabindex="-1"></a><span class="kw">let</span> fifth <span class="op">=</span> v[<span class="dv">4</span>]<span class="op">;</span></span></code></pre></div>
<p>以上這段程式會出錯，並建議你改用參考，如果你還是想要將向量的值移出，你可以參考以下的寫法。</p>
<div class="sourceCode" id="cb60"><pre class="sourceCode rust"><code class="sourceCode rust"><span id="cb60-1"><a href="%E6%89%80%E6%9C%89%E6%AC%8A%E8%88%87%E7%A7%BB%E5%8B%95.html#cb60-1" tabindex="-1"></a><span class="kw">let</span> <span class="kw">mut</span> v <span class="op">=</span> <span class="dt">Vec</span><span class="pp">::</span>new()<span class="op">;</span></span>
<span id="cb60-2"><a href="%E6%89%80%E6%9C%89%E6%AC%8A%E8%88%87%E7%A7%BB%E5%8B%95.html#cb60-2" tabindex="-1"></a><span class="cf">for</span> i <span class="kw">in</span> <span class="dv">101</span><span class="op">..</span><span class="dv">106</span> <span class="op">{</span></span>
<span id="cb60-3"><a href="%E6%89%80%E6%9C%89%E6%AC%8A%E8%88%87%E7%A7%BB%E5%8B%95.html#cb60-3" tabindex="-1"></a>    v<span class="op">.</span>push(i<span class="op">.</span>to_string())<span class="op">;</span></span>
<span id="cb60-4"><a href="%E6%89%80%E6%9C%89%E6%AC%8A%E8%88%87%E7%A7%BB%E5%8B%95.html#cb60-4" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb60-5"><a href="%E6%89%80%E6%9C%89%E6%AC%8A%E8%88%87%E7%A7%BB%E5%8B%95.html#cb60-5" tabindex="-1"></a></span>
<span id="cb60-6"><a href="%E6%89%80%E6%9C%89%E6%AC%8A%E8%88%87%E7%A7%BB%E5%8B%95.html#cb60-6" tabindex="-1"></a><span class="co">//1.pop method</span></span>
<span id="cb60-7"><a href="%E6%89%80%E6%9C%89%E6%AC%8A%E8%88%87%E7%A7%BB%E5%8B%95.html#cb60-7" tabindex="-1"></a><span class="co">//移出向量的最後一個值</span></span>
<span id="cb60-8"><a href="%E6%89%80%E6%9C%89%E6%AC%8A%E8%88%87%E7%A7%BB%E5%8B%95.html#cb60-8" tabindex="-1"></a><span class="kw">let</span> fifth <span class="op">=</span> v<span class="op">.</span>pop()<span class="op">.</span>expect(<span class="st">"no fifth element"</span>)<span class="op">;</span></span>
<span id="cb60-9"><a href="%E6%89%80%E6%9C%89%E6%AC%8A%E8%88%87%E7%A7%BB%E5%8B%95.html#cb60-9" tabindex="-1"></a><span class="pp">rprintln!</span>(<span class="st">"fifth: {}"</span><span class="op">,</span> fifth)<span class="op">;</span></span>
<span id="cb60-10"><a href="%E6%89%80%E6%9C%89%E6%AC%8A%E8%88%87%E7%A7%BB%E5%8B%95.html#cb60-10" tabindex="-1"></a></span>
<span id="cb60-11"><a href="%E6%89%80%E6%9C%89%E6%AC%8A%E8%88%87%E7%A7%BB%E5%8B%95.html#cb60-11" tabindex="-1"></a><span class="co">//2. swap_remove method</span></span>
<span id="cb60-12"><a href="%E6%89%80%E6%9C%89%E6%AC%8A%E8%88%87%E7%A7%BB%E5%8B%95.html#cb60-12" tabindex="-1"></a><span class="co">//移出向量的指定位置值</span></span>
<span id="cb60-13"><a href="%E6%89%80%E6%9C%89%E6%AC%8A%E8%88%87%E7%A7%BB%E5%8B%95.html#cb60-13" tabindex="-1"></a><span class="kw">let</span> second <span class="op">=</span> v<span class="op">.</span>swap_remove(<span class="dv">1</span>)<span class="op">;</span></span>
<span id="cb60-14"><a href="%E6%89%80%E6%9C%89%E6%AC%8A%E8%88%87%E7%A7%BB%E5%8B%95.html#cb60-14" tabindex="-1"></a><span class="pp">rprintln!</span>(<span class="st">"second: {}"</span><span class="op">,</span> second)<span class="op">;</span></span>
<span id="cb60-15"><a href="%E6%89%80%E6%9C%89%E6%AC%8A%E8%88%87%E7%A7%BB%E5%8B%95.html#cb60-15" tabindex="-1"></a></span>
<span id="cb60-16"><a href="%E6%89%80%E6%9C%89%E6%AC%8A%E8%88%87%E7%A7%BB%E5%8B%95.html#cb60-16" tabindex="-1"></a><span class="co">// 3.replace method</span></span>
<span id="cb60-17"><a href="%E6%89%80%E6%9C%89%E6%AC%8A%E8%88%87%E7%A7%BB%E5%8B%95.html#cb60-17" tabindex="-1"></a><span class="co">// 用一個值來做交換</span></span>
<span id="cb60-18"><a href="%E6%89%80%E6%9C%89%E6%AC%8A%E8%88%87%E7%A7%BB%E5%8B%95.html#cb60-18" tabindex="-1"></a></span>
<span id="cb60-19"><a href="%E6%89%80%E6%9C%89%E6%AC%8A%E8%88%87%E7%A7%BB%E5%8B%95.html#cb60-19" tabindex="-1"></a><span class="kw">let</span> third <span class="op">=</span> <span class="pp">std::mem::</span>replace(<span class="op">&amp;</span><span class="kw">mut</span> v[<span class="dv">2</span>]<span class="op">,</span> <span class="st">"substitute"</span><span class="op">.</span>to_string())<span class="op">;</span></span>
<span id="cb60-20"><a href="%E6%89%80%E6%9C%89%E6%AC%8A%E8%88%87%E7%A7%BB%E5%8B%95.html#cb60-20" tabindex="-1"></a><span class="pp">rprintln!</span>(<span class="st">"third: {}"</span><span class="op">,</span> third)<span class="op">;</span></span>
<span id="cb60-21"><a href="%E6%89%80%E6%9C%89%E6%AC%8A%E8%88%87%E7%A7%BB%E5%8B%95.html#cb60-21" tabindex="-1"></a></span>
<span id="cb60-22"><a href="%E6%89%80%E6%9C%89%E6%AC%8A%E8%88%87%E7%A7%BB%E5%8B%95.html#cb60-22" tabindex="-1"></a><span class="pp">rprintln!</span>(<span class="st">"v: {:?}"</span><span class="op">,</span> v)<span class="op">;</span></span>
<span id="cb60-23"><a href="%E6%89%80%E6%9C%89%E6%AC%8A%E8%88%87%E7%A7%BB%E5%8B%95.html#cb60-23" tabindex="-1"></a>#<span class="op">&gt;</span> fifth<span class="op">:</span> <span class="dv">105</span></span>
<span id="cb60-24"><a href="%E6%89%80%E6%9C%89%E6%AC%8A%E8%88%87%E7%A7%BB%E5%8B%95.html#cb60-24" tabindex="-1"></a>#<span class="op">&gt;</span> second<span class="op">:</span> <span class="dv">102</span></span>
<span id="cb60-25"><a href="%E6%89%80%E6%9C%89%E6%AC%8A%E8%88%87%E7%A7%BB%E5%8B%95.html#cb60-25" tabindex="-1"></a>#<span class="op">&gt;</span> third<span class="op">:</span> <span class="dv">103</span></span>
<span id="cb60-26"><a href="%E6%89%80%E6%9C%89%E6%AC%8A%E8%88%87%E7%A7%BB%E5%8B%95.html#cb60-26" tabindex="-1"></a>#<span class="op">&gt;</span> v<span class="op">:</span> [<span class="st">"101"</span><span class="op">,</span> <span class="st">"104"</span><span class="op">,</span> <span class="st">"substitute"</span>]</span></code></pre></div>
<p>再以上面Person的例子中，編譯器無法追蹤以struct包裝的string的所有權的移動狀況，但可以考慮用Option來動態追蹤。</p>
<div class="sourceCode" id="cb61"><pre class="sourceCode rust"><code class="sourceCode rust"><span id="cb61-1"><a href="%E6%89%80%E6%9C%89%E6%AC%8A%E8%88%87%E7%A7%BB%E5%8B%95.html#cb61-1" tabindex="-1"></a> <span class="at">#[</span>derive<span class="at">(</span><span class="bu">Debug</span><span class="at">)]</span></span>
<span id="cb61-2"><a href="%E6%89%80%E6%9C%89%E6%AC%8A%E8%88%87%E7%A7%BB%E5%8B%95.html#cb61-2" tabindex="-1"></a><span class="kw">struct</span> Person <span class="op">{</span></span>
<span id="cb61-3"><a href="%E6%89%80%E6%9C%89%E6%AC%8A%E8%88%87%E7%A7%BB%E5%8B%95.html#cb61-3" tabindex="-1"></a>    name<span class="op">:</span> <span class="dt">Option</span><span class="op">&lt;</span><span class="dt">String</span><span class="op">&gt;,</span></span>
<span id="cb61-4"><a href="%E6%89%80%E6%9C%89%E6%AC%8A%E8%88%87%E7%A7%BB%E5%8B%95.html#cb61-4" tabindex="-1"></a>    birth<span class="op">:</span> <span class="dt">i32</span><span class="op">,</span></span>
<span id="cb61-5"><a href="%E6%89%80%E6%9C%89%E6%AC%8A%E8%88%87%E7%A7%BB%E5%8B%95.html#cb61-5" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb61-6"><a href="%E6%89%80%E6%9C%89%E6%AC%8A%E8%88%87%E7%A7%BB%E5%8B%95.html#cb61-6" tabindex="-1"></a></span>
<span id="cb61-7"><a href="%E6%89%80%E6%9C%89%E6%AC%8A%E8%88%87%E7%A7%BB%E5%8B%95.html#cb61-7" tabindex="-1"></a><span class="kw">let</span> <span class="kw">mut</span> composers <span class="op">=</span> <span class="dt">Vec</span><span class="pp">::</span>new()<span class="op">;</span></span>
<span id="cb61-8"><a href="%E6%89%80%E6%9C%89%E6%AC%8A%E8%88%87%E7%A7%BB%E5%8B%95.html#cb61-8" tabindex="-1"></a>composers<span class="op">.</span>push(Person <span class="op">{</span>name<span class="op">:</span> <span class="cn">Some</span>(<span class="st">"Palestrina"</span><span class="op">.</span>to_string())<span class="op">,</span> birth<span class="op">:</span> <span class="dv">1525</span><span class="op">}</span>)<span class="op">;</span></span>
<span id="cb61-9"><a href="%E6%89%80%E6%9C%89%E6%AC%8A%E8%88%87%E7%A7%BB%E5%8B%95.html#cb61-9" tabindex="-1"></a>composers<span class="op">.</span>push(Person <span class="op">{</span>name<span class="op">:</span> <span class="cn">Some</span>(<span class="st">"Dowland"</span><span class="op">.</span>to_string())<span class="op">,</span> birth<span class="op">:</span> <span class="dv">1563</span><span class="op">}</span>)<span class="op">;</span></span>
<span id="cb61-10"><a href="%E6%89%80%E6%9C%89%E6%AC%8A%E8%88%87%E7%A7%BB%E5%8B%95.html#cb61-10" tabindex="-1"></a></span>
<span id="cb61-11"><a href="%E6%89%80%E6%9C%89%E6%AC%8A%E8%88%87%E7%A7%BB%E5%8B%95.html#cb61-11" tabindex="-1"></a><span class="kw">let</span> first_name <span class="op">=</span> <span class="pp">std::mem::</span>replace(<span class="op">&amp;</span><span class="kw">mut</span> composers[<span class="dv">0</span>]<span class="op">.</span>name<span class="op">,</span> <span class="cn">None</span>)<span class="op">;</span></span>
<span id="cb61-12"><a href="%E6%89%80%E6%9C%89%E6%AC%8A%E8%88%87%E7%A7%BB%E5%8B%95.html#cb61-12" tabindex="-1"></a><span class="pp">rprintln!</span>(<span class="st">"first_name: {:?}"</span><span class="op">,</span> first_name)<span class="op">;</span></span>
<span id="cb61-13"><a href="%E6%89%80%E6%9C%89%E6%AC%8A%E8%88%87%E7%A7%BB%E5%8B%95.html#cb61-13" tabindex="-1"></a><span class="pp">rprintln!</span>(<span class="st">"composers: {:?}"</span><span class="op">,</span> composers)<span class="op">;</span></span>
<span id="cb61-14"><a href="%E6%89%80%E6%9C%89%E6%AC%8A%E8%88%87%E7%A7%BB%E5%8B%95.html#cb61-14" tabindex="-1"></a></span>
<span id="cb61-15"><a href="%E6%89%80%E6%9C%89%E6%AC%8A%E8%88%87%E7%A7%BB%E5%8B%95.html#cb61-15" tabindex="-1"></a><span class="co">// option提供給你take方法，，讓整體更簡潔</span></span>
<span id="cb61-16"><a href="%E6%89%80%E6%9C%89%E6%AC%8A%E8%88%87%E7%A7%BB%E5%8B%95.html#cb61-16" tabindex="-1"></a><span class="kw">let</span> second_name <span class="op">=</span> composers[<span class="dv">1</span>]<span class="op">.</span>name<span class="op">.</span>take()<span class="op">;</span></span>
<span id="cb61-17"><a href="%E6%89%80%E6%9C%89%E6%AC%8A%E8%88%87%E7%A7%BB%E5%8B%95.html#cb61-17" tabindex="-1"></a><span class="pp">rprintln!</span>(<span class="st">"second_name: {:?}"</span><span class="op">,</span> second_name)<span class="op">;</span></span>
<span id="cb61-18"><a href="%E6%89%80%E6%9C%89%E6%AC%8A%E8%88%87%E7%A7%BB%E5%8B%95.html#cb61-18" tabindex="-1"></a><span class="pp">rprintln!</span>(<span class="st">"composers: {:?}"</span><span class="op">,</span> composers)<span class="op">;</span></span>
<span id="cb61-19"><a href="%E6%89%80%E6%9C%89%E6%AC%8A%E8%88%87%E7%A7%BB%E5%8B%95.html#cb61-19" tabindex="-1"></a>#<span class="op">&gt;</span> first_name<span class="op">:</span> <span class="cn">Some</span>(<span class="st">"Palestrina"</span>)</span>
<span id="cb61-20"><a href="%E6%89%80%E6%9C%89%E6%AC%8A%E8%88%87%E7%A7%BB%E5%8B%95.html#cb61-20" tabindex="-1"></a>#<span class="op">&gt;</span> composers<span class="op">:</span> [Person <span class="op">{</span> name<span class="op">:</span> <span class="cn">None</span><span class="op">,</span> birth<span class="op">:</span> <span class="dv">1525</span> <span class="op">},</span> Person <span class="op">{</span> name<span class="op">:</span> <span class="cn">Some</span>(<span class="st">"Dowland"</span>)<span class="op">,</span> birth<span class="op">:</span> <span class="dv">1563</span> <span class="op">}</span>]</span>
<span id="cb61-21"><a href="%E6%89%80%E6%9C%89%E6%AC%8A%E8%88%87%E7%A7%BB%E5%8B%95.html#cb61-21" tabindex="-1"></a>#<span class="op">&gt;</span> second_name<span class="op">:</span> <span class="cn">Some</span>(<span class="st">"Dowland"</span>)</span>
<span id="cb61-22"><a href="%E6%89%80%E6%9C%89%E6%AC%8A%E8%88%87%E7%A7%BB%E5%8B%95.html#cb61-22" tabindex="-1"></a>#<span class="op">&gt;</span> composers<span class="op">:</span> [Person <span class="op">{</span> name<span class="op">:</span> <span class="cn">None</span><span class="op">,</span> birth<span class="op">:</span> <span class="dv">1525</span> <span class="op">},</span> Person <span class="op">{</span> name<span class="op">:</span> <span class="cn">None</span><span class="op">,</span> birth<span class="op">:</span> <span class="dv">1563</span> <span class="op">}</span>]</span></code></pre></div>
</div>
<div id="複製型態" class="section level3" number="4.3.6">
<h3>
<span class="header-section-number">4.3.6</span> 複製型態<a class="anchor" aria-label="anchor" href="#%E8%A4%87%E8%A3%BD%E5%9E%8B%E6%85%8B"><i class="fas fa-link"></i></a>
</h3>
<p>剛剛我們提過<strong>Copy型態</strong>，他們不受所有權的限制，可以隨意複製，例如整數、浮點數、字元，這些型態不會像字串、向量等佔用大量的記憶體，以下例子比較：</p>
<div class="sourceCode" id="cb62"><pre class="sourceCode rust"><code class="sourceCode rust"><span id="cb62-1"><a href="%E6%89%80%E6%9C%89%E6%AC%8A%E8%88%87%E7%A7%BB%E5%8B%95.html#cb62-1" tabindex="-1"></a><span class="kw">let</span> s1 <span class="op">=</span> <span class="st">"hello"</span><span class="op">.</span>to_string()<span class="op">;</span></span>
<span id="cb62-2"><a href="%E6%89%80%E6%9C%89%E6%AC%8A%E8%88%87%E7%A7%BB%E5%8B%95.html#cb62-2" tabindex="-1"></a><span class="kw">let</span> s1 <span class="op">=</span> s2<span class="op">;</span></span>
<span id="cb62-3"><a href="%E6%89%80%E6%9C%89%E6%AC%8A%E8%88%87%E7%A7%BB%E5%8B%95.html#cb62-3" tabindex="-1"></a></span>
<span id="cb62-4"><a href="%E6%89%80%E6%9C%89%E6%AC%8A%E8%88%87%E7%A7%BB%E5%8B%95.html#cb62-4" tabindex="-1"></a><span class="kw">let</span> x <span class="op">=</span> <span class="dv">5</span><span class="op">;</span></span>
<span id="cb62-5"><a href="%E6%89%80%E6%9C%89%E6%AC%8A%E8%88%87%E7%A7%BB%E5%8B%95.html#cb62-5" tabindex="-1"></a><span class="kw">let</span> y <span class="op">=</span> x<span class="op">;</span></span></code></pre></div>
<p>在上面的例子中，s1被賦值時，會在heap中配置一個字串。相反x不會在heap中配置，而是直接在堆疊匡裡配置。</p>
<p>另外，當s1給s2時，hello字串的所有權被移轉。而x給y時，不會發生所有權的轉移，而是產生一個完全獨立的副本。</p>
<p>這樣的區分除了在為記憶體空間的考量外，非Copy型態的值在被卸除時<strong>都要做某些特別的事</strong>。例如前面所述的Vec，卸除時須要讓元素釋放、File型態要關閉檔案控制碼、MutexGuard需要解鎖等等。</p>
<p>那如果是自己定義的型態呢？</p>
<div class="sourceCode" id="cb63"><pre class="sourceCode rust"><code class="sourceCode rust"><span id="cb63-1"><a href="%E6%89%80%E6%9C%89%E6%AC%8A%E8%88%87%E7%A7%BB%E5%8B%95.html#cb63-1" tabindex="-1"></a><span class="kw">struct</span> Point <span class="op">{</span></span>
<span id="cb63-2"><a href="%E6%89%80%E6%9C%89%E6%AC%8A%E8%88%87%E7%A7%BB%E5%8B%95.html#cb63-2" tabindex="-1"></a>    x<span class="op">:</span> <span class="dt">i32</span><span class="op">,</span></span>
<span id="cb63-3"><a href="%E6%89%80%E6%9C%89%E6%AC%8A%E8%88%87%E7%A7%BB%E5%8B%95.html#cb63-3" tabindex="-1"></a>    y<span class="op">:</span> <span class="dt">i32</span><span class="op">,</span></span>
<span id="cb63-4"><a href="%E6%89%80%E6%9C%89%E6%AC%8A%E8%88%87%E7%A7%BB%E5%8B%95.html#cb63-4" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb63-5"><a href="%E6%89%80%E6%9C%89%E6%AC%8A%E8%88%87%E7%A7%BB%E5%8B%95.html#cb63-5" tabindex="-1"></a></span>
<span id="cb63-6"><a href="%E6%89%80%E6%9C%89%E6%AC%8A%E8%88%87%E7%A7%BB%E5%8B%95.html#cb63-6" tabindex="-1"></a><span class="kw">fn</span> print(p<span class="op">:</span> Point) <span class="op">{</span></span>
<span id="cb63-7"><a href="%E6%89%80%E6%9C%89%E6%AC%8A%E8%88%87%E7%A7%BB%E5%8B%95.html#cb63-7" tabindex="-1"></a>    <span class="pp">rprintln!</span>(<span class="st">"({}, {})"</span><span class="op">,</span> p<span class="op">.</span>x<span class="op">,</span> p<span class="op">.</span>y)<span class="op">;</span></span>
<span id="cb63-8"><a href="%E6%89%80%E6%9C%89%E6%AC%8A%E8%88%87%E7%A7%BB%E5%8B%95.html#cb63-8" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb63-9"><a href="%E6%89%80%E6%9C%89%E6%AC%8A%E8%88%87%E7%A7%BB%E5%8B%95.html#cb63-9" tabindex="-1"></a></span>
<span id="cb63-10"><a href="%E6%89%80%E6%9C%89%E6%AC%8A%E8%88%87%E7%A7%BB%E5%8B%95.html#cb63-10" tabindex="-1"></a><span class="kw">let</span> p <span class="op">=</span> Point <span class="op">{</span>x<span class="op">:</span> <span class="dv">1</span><span class="op">,</span> y<span class="op">:</span> <span class="dv">2</span><span class="op">};</span></span>
<span id="cb63-11"><a href="%E6%89%80%E6%9C%89%E6%AC%8A%E8%88%87%E7%A7%BB%E5%8B%95.html#cb63-11" tabindex="-1"></a>print(p)<span class="op">;</span><span class="co">//</span></span>
<span id="cb63-12"><a href="%E6%89%80%E6%9C%89%E6%AC%8A%E8%88%87%E7%A7%BB%E5%8B%95.html#cb63-12" tabindex="-1"></a><span class="pp">rprintln!</span>(<span class="st">"({}, {})"</span><span class="op">,</span> p<span class="op">.</span>x<span class="op">,</span> p<span class="op">.</span>y)<span class="op">;</span></span></code></pre></div>
<p>✖ error[E0382]: borrow of moved value: <code>p</code>
–&gt; src/lib.rs:16:28
|
14 | let p = Point {x: 1, y: 2};
| - move occurs because <code>p</code> has type <code>Point</code>, which does not implement the <code>Copy</code> trait
15 | print(p);
| - value moved here
16 | rprintln!(“({}, {})”, p.x, p.y);
| ^^^ value borrowed here after move
|</p>
<p>這裡的抱錯告訴你，在print(p)後，p的所有權被移動，所以你不能再使用p。所以在預設情況下，自定義的型態都是非Copy型態。</p>
<p>但明明point型態裡放的都是整數，沒有必要動來動去！因此，你可以加入#[derive(Copy, Clone)]來讓point型態成為Copy型態。</p>
<p>不過注意，如果你的型態裡有非Copy型態的成員，那麽你可不能用#[derive(Copy, Clone)]，而是要自己實作Copy與Clone trait。</p>
</div>
</div>
<div id="rc與arc共享所有權" class="section level2" number="4.4">
<h2>
<span class="header-section-number">4.4</span> Rc與Arc：共享所有權<a class="anchor" aria-label="anchor" href="#rc%E8%88%87arc%E5%85%B1%E4%BA%AB%E6%89%80%E6%9C%89%E6%AC%8A"><i class="fas fa-link"></i></a>
</h2>
<p>所有權帶來安全，但設計程式免不了遇到需要保留值到最後，卻找不到適合的單一所有權人，又或著需要在多個執行緒間共享值。這時你可以使用Rc與Arc，他們是<strong>參考計數指標</strong>，可以讓值有多個所有權人。</p>
<p>Rc與Arc的差別在於Arc可以在不同的執行緒間共享，Rc則是以高速在單執行緒間更改參數量，除此之外，兩者是等效，因此我們以Rc示範。</p>
<p>Rc就是重現python的參考數管理生命週期的方式</p>
<div class="sourceCode" id="cb64"><pre class="sourceCode rust"><code class="sourceCode rust"><span id="cb64-1"><a href="%E6%89%80%E6%9C%89%E6%AC%8A%E8%88%87%E7%A7%BB%E5%8B%95.html#cb64-1" tabindex="-1"></a><span class="kw">use</span> <span class="pp">std::rc::</span>Rc<span class="op">;</span></span>
<span id="cb64-2"><a href="%E6%89%80%E6%9C%89%E6%AC%8A%E8%88%87%E7%A7%BB%E5%8B%95.html#cb64-2" tabindex="-1"></a></span>
<span id="cb64-3"><a href="%E6%89%80%E6%9C%89%E6%AC%8A%E8%88%87%E7%A7%BB%E5%8B%95.html#cb64-3" tabindex="-1"></a><span class="kw">let</span> s <span class="op">=</span> <span class="pp">Rc::</span>new(<span class="st">"shirataki"</span><span class="op">.</span>to_string())<span class="op">;</span></span>
<span id="cb64-4"><a href="%E6%89%80%E6%9C%89%E6%AC%8A%E8%88%87%E7%A7%BB%E5%8B%95.html#cb64-4" tabindex="-1"></a><span class="kw">let</span> s2 <span class="op">=</span> s<span class="op">.</span>clone()<span class="op">;</span></span>
<span id="cb64-5"><a href="%E6%89%80%E6%9C%89%E6%AC%8A%E8%88%87%E7%A7%BB%E5%8B%95.html#cb64-5" tabindex="-1"></a><span class="kw">let</span> s3 <span class="op">=</span> s<span class="op">.</span>clone()<span class="op">;</span></span></code></pre></div>
<p>Rc<t>是一個指向heap裡的指標，並且附帶一個參考數量。當你呼叫clone時，並非移動或複製，而是另外一個指向同個heap的指標，並且增加參考數。</t></p>
<p>Rc的值並不可變，於此來確立執行緒安全的保障。所以，「任何值不可以是既共享又可變」。</p>
<p>參考管理記憶體最大的問題是：當兩個參考計數的值互指，導致計數永遠不會歸零，卡在記憶體不被釋出。這種情況通常出現在舊值可變的情況，因為這樣才會出現此種循環，剛好Rust的機制讓這種情況很難發生。</p>
</div>
<div id="總結" class="section level2" number="4.5">
<h2>
<span class="header-section-number">4.5</span> 總結<a class="anchor" aria-label="anchor" href="#%E7%B8%BD%E7%B5%90"><i class="fas fa-link"></i></a>
</h2>
<p>在此章節中，我們先學會了Rust的所有權概念，並且比較了不同語言的運作方式。接著，了解移動、複製與共享3種讓所有權更彈性。下一章節我們將討論最後一招：借用值的參考。</p>

</div>
</div>
  <div class="chapter-nav">
<div class="prev"><a href="day2---%E5%9E%8B%E6%85%8B.html"><span class="header-section-number">3</span> Day2 - 型態</a></div>
<div class="next"><a href="%E5%8F%83%E8%80%83.html"><span class="header-section-number">5</span> 參考</a></div>
</div></main><div class="col-md-3 col-lg-2 d-none d-md-block sidebar sidebar-chapter">
    <nav id="toc" data-toggle="toc" aria-label="On this page"><h2>On this page</h2>
      <ul class="nav navbar-nav">
<li><a class="nav-link" href="#%E6%89%80%E6%9C%89%E6%AC%8A%E8%88%87%E7%A7%BB%E5%8B%95"><span class="header-section-number">4</span> 所有權與移動</a></li>
<li><a class="nav-link" href="#%E6%89%80%E6%9C%89%E6%AC%8A%E8%88%87%E7%A7%BB%E5%8B%95-1"><span class="header-section-number">4.1</span> 所有權與移動</a></li>
<li><a class="nav-link" href="#%E6%89%80%E6%9C%89%E6%AC%8A"><span class="header-section-number">4.2</span> 所有權</a></li>
<li>
<a class="nav-link" href="#%E7%A7%BB%E5%8B%95"><span class="header-section-number">4.3</span> 移動</a><ul class="nav navbar-nav">
<li><a class="nav-link" href="#python"><span class="header-section-number">4.3.1</span> python</a></li>
<li><a class="nav-link" href="#c"><span class="header-section-number">4.3.2</span> C++</a></li>
<li><a class="nav-link" href="#rust"><span class="header-section-number">4.3.3</span> Rust</a></li>
<li><a class="nav-link" href="#%E7%A7%BB%E5%8B%95%E8%88%87%E6%8E%A7%E5%88%B6"><span class="header-section-number">4.3.4</span> 移動與控制</a></li>
<li><a class="nav-link" href="#%E7%A7%BB%E5%8B%95%E8%88%87%E6%AA%A2%E7%B4%A2"><span class="header-section-number">4.3.5</span> 移動與檢索</a></li>
<li><a class="nav-link" href="#%E8%A4%87%E8%A3%BD%E5%9E%8B%E6%85%8B"><span class="header-section-number">4.3.6</span> 複製型態</a></li>
</ul>
</li>
<li><a class="nav-link" href="#rc%E8%88%87arc%E5%85%B1%E4%BA%AB%E6%89%80%E6%9C%89%E6%AC%8A"><span class="header-section-number">4.4</span> Rc與Arc：共享所有權</a></li>
<li><a class="nav-link" href="#%E7%B8%BD%E7%B5%90"><span class="header-section-number">4.5</span> 總結</a></li>
</ul>

      <div class="book-extra">
        <ul class="list-unstyled">
<li><a id="book-source" href="https://github.com/rstudio/bookdown-demo/blob/master/03-Day3.Rmd">View source <i class="fab fa-github"></i></a></li>
          <li><a id="book-edit" href="https://github.com/rstudio/bookdown-demo/edit/master/03-Day3.Rmd">Edit this page <i class="fab fa-github"></i></a></li>
        </ul>
</div>
    </nav>
</div>

</div>
</div> <!-- .container -->

<footer class="bg-primary text-light mt-5"><div class="container"><div class="row">

  <div class="col-12 col-md-6 mt-3">
    <p>"<strong>Rust之書</strong>" was written by 董宸賓. It was last built on 2024-07-10.</p>
  </div>

  <div class="col-12 col-md-6 mt-3">
    <p>This book was built by the <a class="text-light" href="https://bookdown.org">bookdown</a> R package.</p>
  </div>

</div></div>
</footer><!-- dynamically load mathjax for compatibility with self-contained --><script>
  (function () {
    var script = document.createElement("script");
    script.type = "text/javascript";
    var src = "true";
    if (src === "" || src === "true") src = "https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.9/latest.js?config=TeX-MML-AM_CHTML";
    if (location.protocol !== "file:")
      if (/^https?:/.test(src))
        src = src.replace(/^https?:/, '');
    script.src = src;
    document.getElementsByTagName("head")[0].appendChild(script);
  })();
</script><script type="text/x-mathjax-config">const popovers = document.querySelectorAll('a.footnote-ref[data-toggle="popover"]');
for (let popover of popovers) {
  const div = document.createElement('div');
  div.setAttribute('style', 'position: absolute; top: 0, left:0; width:0, height:0, overflow: hidden; visibility: hidden;');
  div.innerHTML = popover.getAttribute('data-content');

  var has_math = div.querySelector("span.math");
  if (has_math) {
    document.body.appendChild(div);
    MathJax.Hub.Queue(["Typeset", MathJax.Hub, div]);
    MathJax.Hub.Queue(function() {
      popover.setAttribute('data-content', div.innerHTML);
      document.body.removeChild(div);
    })
  }
}
</script>
</body>
</html>
