
# 參考



在上一章看到的所有指標，從Box<T>heap指標，以及String與Vec的內部指標，都擁有所有權：也就是說，當所有權人被卸除時，他的參考對象也隨之卸除。Rust也有**無所有權指標**，稱為參考，不會影響參考對象的生命週期。

參考的概念就是取得位址，但在Rust中，**參考的生命週期絕對不能超過參考的生命週期**，來保證運作的安全性，換言之，正確理解Rust參考的方式是「借用值」，總有一天要歸還給所有權人。

## 值的參考

我們要製作單曲與其歌手的表格，可以用雜湊表(HashMap)來儲存，並寫一個`show`函式來顯示表格


```rust
use std::collections::HashMap;
type Table = HashMap<String, Vec<String>>;

fn show(table: Table){
  for(artist, album) in table {
    rprintln!("{}的單曲：", artist);
    for song in album {
      rprintln!(" {}", song);
    }
  }
}
```

在主要函式中，只要插入元素，並使用上面的函式即可



```rust

fn main() {
  let mut table = Table::new();
  
  table.insert("周杰倫".to_string(), vec!["青花瓷".to_string(), "稻香".to_string()]);
  table.insert("蔡依林".to_string(), vec!["倒帶".to_string(), "愛情三十六計".to_string()]);
  table.insert("張學友".to_string(), vec!["吻別".to_string(), "當愛已成往事".to_string()]);
  
  show(table);
  
}

```

輕鬆執行


```
#> [1m[32m    Finished[0m `dev` profile [unoptimized + debuginfo] target(s) in 0.00s
#> [1m[32m     Running[0m `artist/target/debug/artist`
#> 蔡依林的單曲：
#>  倒帶
#>  愛情三十六計
#> 周杰倫的單曲：
#>  青花瓷
#>  稻香
#> 張學友的單曲：
#>  吻別
#>  當愛已成往事
```

在看完前一章後，你會問HashMap的值如何傳遞的？那恭喜你，HashMap是以動態配置一個表，當你呼叫show(table)時，整個table會被移入函式，由for取得所有權，並ㄧ層ㄧ層的耗用，直到全部被銷毀。

```Rust
show(table);
assert_eq!(table["周杰倫"], ["青花瓷", "稻香"]);
```

會產生錯誤告訴你，table已經被用掉了，應該用reference來取代

```
error[E0382]: borrow of moved value: `table`
  --> src/main.rs:23:14
   |
16 |   let mut table = Table::new();
   |       --------- move occurs because `table` has type `HashMap<String, Vec<String>>`, which does not implement the `Copy` trait
...
22 |   show(table);
   |        ----- value moved here
23 |   assert_eq!(table["周杰倫"], ["青花瓷", "稻香"]);
   |              ^^^^^ value borrowed here after move
   |
note: consider changing this parameter type in function `show` to borrow instead if owning the value isn't necessary
  --> src/main.rs:5:16
   |
5  | fn show(table: Table){
   |    ----        ^^^^^ this parameter takes ownership of the value
   |    |
   |    in this function
help: consider cloning the value if the performance cost is acceptable
   |
22 |   show(table.clone());
   |             ++++++++
```

那又要使用哪種參考呢？

- 共享參考(shared reference)：可以讓任意數量的共享參考指向同一個值，但不能修改參考值。&e會產生e的共享參考，e的型態是T，&e的型態是&T。

- 可變參考(mut reference)：只能有一個可變參考指向同一個值，但可以修改參考值。&mut e會產生e的可變參考，e的型態是T，&mut e的型別是&mut T。**他不是Copy**

你可以用「多個讀取方」與「單一寫入方」來區分，當你使用共享參考時，「任何人」都無法修改值，即使是原本的所有權人。相反，在可變參考出現時，只有在其消滅時，方能再次使用。

回到上面範例，show函式僅需要讀取table，因此我們已共享參考的方式改寫，只需要將show函式的參數型態改為&Table即可，同時記得在主要函式中，要放入&table。


```rust
fn show(table: &Table){
  for(artist, album) in table {
    println!("{}的單曲：", artist);
    for song in album {
      println!(" {}", song);
    }
  }
}

fn main() {
  
  ...
  
  show(&table);
  assert_eq!(table["周杰倫"], ["青花瓷", "稻香"]);
}
```


只需改變最上層的型態，如當Table變為&Table時，Vec<String>會變為&Vec<String>，String會變為&String，這樣就可以達到「借用值」的目的。


而如果你想修改或是用方法，記得用可變參考，如用sort方法來排序歌曲


```rust
fn sort_album(table: &mut Table){
  for(_, album) in table {
    album.sort();
  }
})
```

## 隱性參考


```rust
let x = 5;
let y = &x;  //必須要嚴明參考
assert!(*y == 5); //解參考時要明確
#> NULL
```

在可變參考時也相同：


```rust
let mut x = 5;
let n = &mut x;
*n += 32;
assert!(*n == 37);
```

請再次觀察第一個例子，我們為何不用在使用元素時解參考呢？

答案是，因為參考在Rust裡太常出現，運算子.可以用來隱性解參考


```rust
struct Person {
  name: String,
  age: i32,
}
let p = Person {name: "John".to_string(), age: 32};
let p_ref = &p;

assert_eq!(p_ref.name, "John");
//相當於
assert_eq!((*p_ref).name, "John");
```


## 參考的參考

Rust允許多重參考，可以一層一層直到借到一個值：


```rust
let p:i32 = 1;
let r1: &i32 = &p;
let r2: &&i32 = &r1;
let r3: &&&i32 = &r2;
rprintln!("{} {} {}", r1, r2, r3);
#> 1 1 1
```

上面例子，r1借用p的值，r2會穿過r1到p借用值，也就是說，兩者值相同，但位址不同

下面例子告訴你，==會自動指向最後的值，但std::ptr::eq會比較位址


```rust
let p:i32 = 1;
let c:i32 = 1;

let r1: &i32 = &p;
let r2: &i32 = &c;

rprintln!("{} {}", r1, r2);
rprintln!("{}", r1 == r2);
rprintln!("{}",std::ptr::eq(r1, r2));
#> 1 1
#> true
#> false
```

### 借用任意運算式的參考

在Rust裡，你可以直接借用運算式的值(的參考)


```rust
fn factorial(n: usize) -> usize {
  (1..n+1).product()
}

let r = &factorial(6);
rprintln!("{}", r+&(1+2));
#> 723
```

在借用的對象是運算式時，Rust會產生ㄧ個**匿名變數來保存值**，而這個變數的生命週期取決於使用參考的方式，若如同上面的&factorial(6)，直接指派給r，那麽他的生命週期就隨r。反之，如&(1+2)在封閉陳述式內，他的生命週期就是這個陳述式。


## 借用區域變數

下面的案例，告訴你注意借用值的生面週期


```rust
let r;
  {
  let x = 5;
  r = &x;
  }

rprintln!("{}", *r);
```


會告訴你，因為x掛點了，但借用他值的r還活著，導致出現了懸空指標

```
✖ error[E0597]: `x` does not live long enough
  --> src/lib.rs:8:7
   |
7  |   let x = 5;
   |       - binding `x` declared here
8  |   r = &x;
   |       ^^ borrowed value does not live long enough
9  |   }
   |   - `x` dropped here while still borrowed
10 |
11 | rprintln!("{}", *r);
   |                 -- borrow later used here
```

在處理一般的資料結構時，會順理成章的避免發生者種狀況，因為都是先有資料，參考都是在資料之後產生，因此解決這種「限制」的最好方式，就是安排好資料的生命週期與宣告順序。


```rust
let x = 1;
{
  let r = &x;
  rprintln!("{}", r);
}
#> 1
#> NULL
```

## 用函式引數來接收參考

以函式引數接收參考時，同樣注意生命週期、可變性、型態等問題


```rust
// 以下無法成功編譯
static mut STASH:&i32;
fn f(p : &i32) {
  STASH = p;
}
```

你可以將static理解為全域變數，會ㄧ直存在於整個執行期。而可變的static是不安全的，你只能在`unsafe`區塊中使用。其二，每一個static都必須初始化。


```rust
// 修改後依然有小錯誤
static mut STASH:&i32 = &10;
fn f(p : &i32) {
unsafe{
  STASH = p;
  }
}
```

如果型態的問題已解決，讓我們來看看生命週期：

完整的f是長`fn f<'a>(p : &'a i32)`

'a的概念是任何生命週期，只要涵蓋f的區域即可。但static必須是整個生命週期，你必須很明確的指出，我們要的生命週期是static


```rust
// 終於解決問題
static mut STASH:&i32 = &10;
fn f(p: &'static i32) {
unsafe{
  STASH = p;
  }
}
```

退一步來說，雖然略為麻煩，但你可以從簽章看出一個函式的意圖，如從`fn f<'a>(p : &'a i32)`到`fn f(p: &'static i32)`，你可以從中看出生命週期，而不用重新閱讀一長串程式。

## 回傳參考值

在處理資料時，我們常傳入一部分資料，並回傳一個結果，例如以下要取得整個slice裡的最小值


```rust
fn smallest(v:&[i32]) -> &i32{
  let mut s = &v[0];
  for r in &v[1..] {
    if *r < *s {
      s = r;
    }
  }
  s
}
#> NULL
```


同樣的，以上函式省略了週期，明確地寫出會是`fn smallest<'a>(v:&'a i32) -> &'a i32`，你可以看到，**回傳值的生命週期與引數的生命週期相同**，這是Rust預設的概念。

因此，當回傳值的生命週期大於引數的生命週期，就會提醒你發生錯誤


```rust
let s;
  {
    let v = [1, 2, 3, 4, 5];
    s = smallest(&v);
  }

rprintln!("{}", s);
```

```
✖ error[E0597]: `v` does not live long enough
  --> src/lib.rs:20:18
   |
19 |     let v = [1, 2, 3, 4, 5];
   |         - binding `v` declared here
20 |     s = smallest(&v);
   |                  ^^ borrowed value does not live long enough
21 |   }
   |   - `v` dropped here while still borrowed
22 |
23 | rprintln!("{}", s);
   |                 - borrow later used here
```

解決以上問題，只要注意生命週期即可



```rust
let s;
  {
    let v = [1, 2, 3, 4, 5];
    s = smallest(&v);
    rprintln!("{}", s);
  }
#> 1
#> NULL
```

## 包含參考的結構

以下是過去錯誤的例子


```rust
struct S {
 r: &i32
}

let s;
{
  let x = 10;
  s = S{r: &x};
}
rprintln!(*s.r, 10);// 錯誤：x已被卸除
```

Rust就是如此嚴謹，即使放入結構中，也要注意週期的概念

我們再次把完整的內容寫出來`struct S<'a> { r: &'a i32 }`，於此，s的週期'a不會超過x

如果我們要將**有週期的參數型態**，就要明確的指出，有兩個方法


```rust
struct S {
 r: &i32
}

//Rust會要求你寫出生命週期
struct D {
 s: S
}

//可以指定s為static
struct D {
 s: S<'static>
}

//編譯器會提供你這個做法
struct D<'a> {
 s: S<'a>
}
```

### 不同生命週期的結構

上面我們講到結構也要注意週期問題，以下例子有些弔詭，r與x的生命週期最長，次為y，最後是a。我們賦予r結構a的x值，並且在x未死亡前，在最後印出r的值。照理來說，牽涉r值的，僅有r本身與x，所以應該不會有問題。



```rust
struct s<'a>{
  x: &'a i32,
  y: &'a i32,
}

let x = 20;
let r;
{
  let y = 10;
  {
    let a = s{x: &x, y: &y};
    r = a.x;
  }
}
rprintln!("{}", r);
```

但是，Rust會告訴你，r的生命週期不夠長，因為y已經死亡...

```
✖ error[E0597]: `y` does not live long enough
  --> src/lib.rs:15:25
   |
13 |   let y = 10;
   |       - binding `y` declared here
14 |   {
15 |     let a = s{x: &x, y: &y};
   |                         ^^ borrowed value does not live long enough
...
18 | }
   | - `y` dropped here while still borrowed
19 | rprintln!("{}", r);
   |                 - borrow later used here
```

其實，秘密就在預設結構的生命週期。結構中，x與y被預設為'a，而Rust會以較小的生命週期為主，如同上例中，即使x尚未死亡，但y的生命週期結束，結構中的x也被視為死亡。

所以，你可以在結構中就預設不同的生命週期，可以避免這種窘境，並且讓所有人都知道這個結構的生命週期


```rust
struct s<'a, 'b>{
  x: &'a i32,
  y: &'b i32,
}

let x = 20;
let r;
{
  let y = 10;
  {
    let a = s{x: &x, y: &y};
    r = a.x;
  }
}
rprintln!("{}", r);
#> 20
```


## 共用與可變性的衝突


```rust
fn extend(v:&mut Vec<f64>, slice:&[f64]){
  for s in slice {
    v.push(*s);
  }
}
#> NULL
```



```rust
let mut s1 = Vec::new();
let s2 = [1.0, 2.0, 3.0];
let s3 = [4.0, 5.0, 6.0];

extend(&mut s1, &s2);
extend(&mut s1, &s3);
rprintln!("{:?}", s1);
#> [1.0, 2.0, 3.0, 4.0, 5.0, 6.0]
```



```rust
extend(&mut s1, &s1);
```

```
✖ error[E0502]: cannot borrow `s1` as immutable because it is also borrowed as mutable
  --> src/lib.rs:18:17
   |
18 | extend(&mut s1, &s1);
   | ------ -------  ^^^ immutable borrow occurs here
   | |      |
   | |      mutable borrow occurs here
   | mutable borrow later used by call
```

再次強調兩點：

- 共用參考是唯獨的：你可以讓任意數兩的變數指向，但他不會是可變的，因為可變參考必定會修改或更動原本的值。

- 可變參考是唯一的：只有一個可變參考指向同一個值，所以也不會出現與共用參考重疊生命週期。

所以，上面的例子中，錯誤訊息告訴你，你不能再指向s1(共用參考)，因為在函式內已經建立「唯一」路徑(可變參考)。

以機器面來說，當extend獲取第一個參數`&mut s1`時，因為要加入更多元素，因此要重新配置記憶體。舊的記憶體會先被釋出，此時extend要讀取第二個參數`&s1`，但這個參數指向的記憶體早已被釋出。



```rust
let mut v = (1,3);
let mut r = &v.0;
let r1 = &mut r;
*r1 = &2;
rprintln!("{}", v.0);
#> 1
```


## 結論

總言之，此章節對Rust的參考做了全面性的介紹，尤其注意到生命週期與可變性的概念，揭示了這是一門需要詳細規劃的預言。

從自動記憶體管理出現的年代，物件之海成為習以為常的架構模式，它的確可以幫助我們快速開發。但同時，因為物件相互彼此依賴共生，要測試、修改、測試變得困難。

而Rust的限制，讓你的架構從一開使就井然有序，因為Rust喜歡讓指標、所有權、資料等朝向同一個地方，這並不容易，所以請繼續往下努力，總有一天你可以建立起架構之海。





