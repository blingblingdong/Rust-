[{"path":"index.html","id":"about","chapter":"1 About","heading":"1 About","text":"本冊是我本人學習Rust的筆記，出稿是我在2024夏天，打工無聊時，開啟幾天的Rust學習之旅。","code":""},{"path":"index.html","id":"參考資料","chapter":"1 About","heading":"1.1 參考資料","text":"","code":""},{"path":"day1---到處看看.html","id":"day1---到處看看","chapter":"2 Day1 - 到處看看","heading":"2 Day1 - 到處看看","text":"1~10猜數字！\n請輸入數字\n1\n你猜的數字是: 1\n太小了!\n請輸入數字\n7\n你猜的數字是: 7\n太大了!\n請輸入數字\n5\n你猜的數字是: 5\n太小了!\n請輸入數字\n6\n你猜的數字是: 6\n恭喜獲勝!","code":"use rand::Rng;\nuse std::cmp::Ordering;\nuse std::io;\n\nfn main() {\n    println!(\"1~10猜數字！\");\n\n    let secret_number = rand::thread_rng().gen_range(1..=10);\n\n    loop {\n        println!(\"請輸入數字\");\n\n        let mut guess = String::new();\n\n        io::stdin()\n            .read_line(&mut guess)\n            .expect(\"解析失敗\");\n\n        let guess: u32 = match guess.trim().parse() {\n            Ok(num) => num,\n            Err(_) => continue,\n        };\n\n        println!(\"你猜的數字是: {guess}\");\n\n        match guess.cmp(&secret_number) {\n            Ordering::Less => println!(\"太小了!\"),\n            Ordering::Greater => println!(\"太大了!\"),\n            Ordering::Equal => {\n                println!(\"恭喜獲勝!\");\n                break;\n            }\n        }\n    }\n}"},{"path":"day1---到處看看.html","id":"安裝rust","chapter":"2 Day1 - 到處看看","heading":"2.1 安裝rust","text":"這會安裝最新版本的Rust，並且會自動更新。如果成功，會得到以下訊息：檢查版本","code":"curl --proto '=https' --tlsv1.2 https://sh.rustup.rs -sSf | shRust is installed now. Great!rustc --version"},{"path":"day1---到處看看.html","id":"相關工具","chapter":"2 Day1 - 到處看看","heading":"2.1.1 相關工具","text":"安裝完Rust，我們來檢查其他三個相關的指令工具如預期的，他應該要跟我們分別回報版本，而這三個工具分別用來:cargo是Rust專門的編譯管理器與萬能的工具包，例如建立新專案，組建專案與執行專案，之後我們會頻繁使用。cargo是Rust專門的編譯管理器與萬能的工具包，例如建立新專案，組建專案與執行專案，之後我們會頻繁使用。rustc也是rust的編譯器，但我們通常都是透過cargo來為我們統一編譯及管理。rustc也是rust的編譯器，但我們通常都是透過cargo來為我們統一編譯及管理。rustdoc是文件工具，你以特定代碼在rs檔裡撰寫文件，rustdoc可以用它們來建立正確的HTML，但這件事我們同樣交由cargo處理。rustdoc是文件工具，你以特定代碼在rs檔裡撰寫文件，rustdoc可以用它們來建立正確的HTML，但這件事我們同樣交由cargo處理。","code":"cargo --version\nrustc --version\nrustdoc --version\n#> cargo 1.80.1 (376290515 2024-07-16)\n#> rustc 1.80.1 (3f5fd8dd4 2024-08-06)\n#> rustdoc 1.80.1 (3f5fd8dd4 2024-08-06)"},{"path":"day1---到處看看.html","id":"hello.rs","chapter":"2 Day1 - 到處看看","heading":"2.2 hello.rs","text":"首先，執行以下指令，建立一個暫時新的專案：接著。寫入一個如下列的程式碼，並且儲存成 hello.rs：fn代表定義的函式，這裡的函式就是main()println!是顯示文字的巨集接著，讓我們來編譯這個代碼：","code":"mkdir tmp\ncd tmpfn main() {\n    println!(\"Hello, world!\");\n}rustc hello.rs\n./hellorprintln!(\"Hello, world!\");"},{"path":"day1---到處看看.html","id":"第一個專案-猜猜數字","chapter":"2 Day1 - 到處看看","heading":"2.3 第一個專案-猜猜數字","text":"跳往新目錄並且檢視新建成的專案目錄結構如下：Cargo.toml 是專案的設定檔，src/main.rs 是程式碼的檔案。使用指令創建的main.rs內容如下：所有的執行黨都是從main函數開始執行的而所有函式都會回傳一個值，在rust中，我們以箭頭與型別名稱表示例如：-> u32 表示回傳一個無符號(unsigned integer)32位元整數而main函數的回傳值是()，表示沒有回傳值，因此回傳的是Rust unit type接著，我們來執行這個專案：","code":"cargo new guess # create a new projectcd guess\ntree.\n├── Cargo.toml\n└── src\n    └── main.rsfn main() {\n    println!(\"Hello, world!\");\n}cargo run#> Hello, world!"},{"path":"day1---到處看看.html","id":"宣告變數","chapter":"2 Day1 - 到處看看","heading":"2.3.1 宣告變數","text":"Rust的變數型態是精華，我們會在明天討論它，但現在我們先來看看如何宣告變數。接著，我們宣告一個隨機數，我們會用到rand crate所以，請打開Cargo.toml，並且加入rand依賴，讓編譯器知道我們要使用這個套件：現在有一個隨機數了！接下來，我們要處理如何讓使用者輸入數字。這裡我們會用到std::io這個標準程式庫，因此只需引用它，而不需要再cargo.toml中加入依賴。use std::io;在terminal接收任何輸入，會被預期是字串，思路是：先接收字串，並且用字串提供的方法轉換成數字。guess在第ㄧ次被宣告是一個字串，並且接受使用者的輸入接著，第二次將其宣告為u32整數，是透過將字串轉換成數字。parrse()會回傳一個Result型別，成功的OK(num)或是失敗的Err(_)，我們用match來處理這兩種情況。接著我們要比較使用者輸入的數字與隨機數，並且給予提示。你可以用if-else來處理這個問題。或是用match與odering來處理(記得聲明引用程式庫use std::cmp::Ordering;)完整的程式碼與執行結果應該如下：","code":"let x = 5;\nprintln!(\"The value of x is: {}\", x);[package]\nname = \"guess\"\nversion = \"0.1.0\"\nedition = \"2021\"\n\n# See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html\n[dependencies]\nrand = \"0.8.4\"use rand::Rng;\n\nlet secret_number = rand::thread_rng().gen_range(1..=10);\nprintln!(\"The secret number is: {}\", secret_number);let mut guess = String::new();\n\nio::stdin().read_line(&mut guess)\n    .expect(\"閱讀失敗！請輸入數字\");\n  \nlet guess: u32 = match guess.trim().parse() {\n    Ok(num) => num,\n    Err(_) => continue,\n};if guess < secret_number {\n    rprintln!(\"太小了！\");\n} else if guess > secret_number {\n    rprintln!(\"太大了！\");\n} else {\n    rprintln!(\"猜對了！\");\n    break;\n}match guess.cmp(&secret_number){\n    Ordering:Less => rprintln!(\"太小了！\"),\n    Ordering:Greater => rprintln!(\"太大了！\"),\n    Ordering:Equal => {\n        rprintln!(\"猜對了！\");\n        break;\n    }\n}"},{"path":"day1---到處看看.html","id":"程式碼","chapter":"2 Day1 - 到處看看","heading":"2.4 程式碼","text":"","code":"use rand::Rng;\nuse std::cmp::Ordering;\nuse std::io;\n\nfn main() {\n    println!(\"1~10猜數字！\");\n\n    let secret_number = rand::thread_rng().gen_range(1..=10);\n\n    loop {\n        println!(\"請輸入數字\");\n\n        let mut guess = String::new();\n\n        io::stdin()\n            .read_line(&mut guess)\n            .expect(\"解析失敗\");\n\n        let guess: u32 = match guess.trim().parse() {\n            Ok(num) => num,\n            Err(_) => continue,\n        };\n\n        println!(\"你猜的數字是: {guess}\");\n\n        match guess.cmp(&secret_number) {\n            Ordering::Less => println!(\"太小了!\"),\n            Ordering::Greater => println!(\"太大了!\"),\n            Ordering::Equal => {\n                println!(\"恭喜獲勝!\");\n                break;\n            }\n        }\n    }\n}"},{"path":"day1---到處看看.html","id":"結果","chapter":"2 Day1 - 到處看看","heading":"2.5 結果","text":"1~10猜數字！\n請輸入數字\n1\n你猜的數字是: 1\n太小了!\n請輸入數字\n7\n你猜的數字是: 7\n太大了!\n請輸入數字\n5\n你猜的數字是: 5\n太小了!\n請輸入數字\n6\n你猜的數字是: 6\n恭喜獲勝!","code":""},{"path":"day2---型態.html","id":"day2---型態","chapter":"3 Day2 - 型態","heading":"3 Day2 - 型態","text":"本章介紹rust基本型態，他們的型態都有具體的機器等級對映物，因此他們的成本皆是可預測的。種類相當繁多，沒必要都「背」下來，隨著寫多了就記得下來了！Rust語言某種程度上是圍繞型態打造的，在簡單性和成本之間取得平衡，能保持記憶體與執行緒安全，同時透過泛型型態和trait保持彈性。本章介紹Rust基本型態，他們的型態都有具體的機器等級對映物，因此他們的成本皆是可預測的。目前，你大概知道Rust是一種靜態語言，且對型態有強烈的意識。你必須在編譯前就對型態有所規劃，這與動態語言例如R或JavaScript有很大的不同。不過與另外一門以安全興著稱的Java相比，rust的型態系統更為靈活，且更為強大。Rust內建有型態推斷機制，在實務上，有許多變數或運算實際上只適合一種型態，於此，Rust允許你省略型態宣告，而由編譯器推斷型態。你當然可以把每個型態都寫下來，但這樣做會讓程式碼變得冗長，且不易閱讀。從函式的回傳型態看來，v必定是Vec，也就是16-bit帶正負號整數向量，而推入之元素也必定是i16因此，Rust允許你省略型態宣告，而由編譯器推斷型態。","code":"fn build_vector() -> Vec<i16>{\n  let mut v: Vec<i16> = Vec::<i16>::new();\n  v.push(10i16);\n  v.push(20i16);\n}fn build_vector() -> Vec<i16>{\n  let mut v = Vec::new();\n  v.push(10);\n  v.push(20);\n}"},{"path":"day2---型態.html","id":"定寬數字型態","chapter":"3 Day2 - 型態","heading":"3.1 定寬數字型態","text":"字寬數字型態是Rust的基礎，是配合絕大多數的現代處理器的硬體所實作的型態。雖然定寬的數字型態有可能溢出或失去準度，但在多數情況下已經夠用，但這比任意精度準數和精確的有理數型態款幾千倍。如果你還是想這樣表示，你可以試試num crate。arch型態是指機器字寬，通常是32或64位元，usize和isize是指機器字寬的無正負號整數型態，通常用來表示記憶體位置。","code":""},{"path":"day2---型態.html","id":"整數型態","chapter":"3 Day2 - 型態","heading":"3.1.1 整數型態","text":"Rust的整數型態分為有無帶正負號的整數，而他們都是使用2的補數表示法。\n例如：i8的範圍是\\(-2^7\\)到\\(2^7-1\\)，u8的範圍是\\(0\\)到\\(2^8-1\\)Rust的整數常數可以加上後綴詞來表示型態，例如：10u8表示8-bit無正負號整數10，10i16表示16-bit帶正負號整數10。如果沒有後綴詞明確指出該型態，Rust會嘗試推斷型態，但如果無法推斷，則會報錯。另外，前綴0x表示16進位，0o表示8進位，0b表示2進位。有一個提升閱讀性的小技巧，你可以使用下底線來分隔數字或型態後綴詞，例如：1_000_000_u32表示32-bit無正負號整數1000000。如果你想要轉換整數型態，你可以使用as關鍵詞，之後會詳細介紹。標準程式庫提供了一些整數運算的method例如：abs()返回絕對值，wrapping_add()返回溢出時的結果，saturating_add()返回飽和時的結果，checked_add()返回溢出時的None，否則返回Some。","code":"assert_eq!(  10_i8 as u16, 10_u16);\n\nassert_eq!(  -1_i16 as i32, -1_i32);//符號擴展\nassert_eq!(65535_u16 as i32, 65535_i32);//零擴展"},{"path":"day2---型態.html","id":"checked-wrapping-saturing與overflowing算術","chapter":"3 Day2 - 型態","heading":"3.1.2 checked, wrapping, saturing與overflowing算術","text":"當整數運算溢出時，在debug buid裡，Rust會panic，而在release build裡，Rust會進行溢出檢查，並返回一個未定義的結果，我們將這種模式稱作wrap around，該結果相當於「在數學上正確的結果」modulo「值得範圍」。例如，以下程式在debug build裡會panic，而在release build裡會環繞為負數，而且迴圈會無期限地執行下去。如果你不想要這種預設行為，整數型態提供你一些方法，這些方法共分4類checked_XXX()：返回Option，若數學上正確的結果無法用該型態到值來表示，則返回None，否則返回Some(值)。wrapping_XXX()：返回值，當溢位時，返回「在數學上正確的結果」modulo「值得範圍」。這個法的優勢在於：他們在所有的buid裡面都會是相同的saturating_XXX()：返回值，當溢位時，返回最大或最小值，也就是計算結果被限制在該型態可以表示的最大與最小值範圍內除法、餘數逐位元移位沒有saturating版本overflowing_XXX()：返回一個tuple，第一個元素是計算結果，第二個元素是一個bool，當溢位時，bool為true，否則為false。overflowing在處理位元移動時稍有不同，他們的overflowed只會在移動距離與型態本身的位元寬或更大時才會回傳true，而實際的移動距離是你請求移動距離mod型態的位元寬度。","code":"let mut i = 1;\nloop{\n  i *= 10;//panic：試著執行溢位乘法\n          //(但只有在debug build裡)\n}// 10+20=30，結果在u8的範圍內\nassert_eq!(10_u8.checked_add(20), Some(30));\n\n\n// 255+1=256，結果超出u8的範圍\nassert_eq!(255_u8.checked_add(1), None);\n\n// 進行加法，當它溢位時panic\n\nlet sum = x.checked_add(y).unwrap();//第一個在範圍值內沒有問題\n// 第二個超出範圍，因此我們獲得250000 modulo$2^16$。\nassert_eq!(10000_u16.wrapping_mul(200), 250000);\nassert_eq!(10000_u16.wrapping_mul(500), 250000);\n\n// 針對正負運算有可能wrap成負數\nassert_eq!(500_i16.wrapping_sub(1000), -500);assert_eq!(100_u8.saturating_add(200), 255);\nassert_eq!(100_u8.saturating_sub(200), 0);assert_eq!(100_u8.overflowing_add(200), (44, true));\nassert_eq!(100_u8.overflowing_sub(200), (156, true));// 移動17 bit對u16而言太大，而17 mod 16 = 1\nassert_eq!(100_u16.overflowing_shl(17), (200, true));"},{"path":"day2---型態.html","id":"浮點數型態","chapter":"3 Day2 - 型態","heading":"3.2 浮點數型態","text":"一個非常標準的Rust浮點數長這樣：314.926e-4f64整數：314\n小數：926\n指數：e-4\n後綴：f64Rust的浮點數分為f32和f64，相當於Java的float和double，他們分別是32-bit和64-bit的IEEE754浮點數。要讓編譯器知道值為浮點數，你不一定明文型態，但必須要有指數、小數點或後綴型態，如：5.就是合法的浮點數，但5不是。如果沒有指定型態，但從脈絡可推斷為浮點數，則編譯器會推斷為f64。f32與f64型態有一些關聯常數是IEEE規定的特殊值，例如INFINITY、NEG_INFINITY、NAN、MIN、MAX等。另外，浮點數也提供一些method，例如sqrt()是開根號，exp()是指數函數請注意，方法呼叫的順位比運算子高，因此在對帶負號的浮點數值做運算時，務必加括號。Rust不會做隱性轉換，如果你丟給預期做浮點數運算的函式一個整數，Rust會大聲地抱怨給你聽，因此，請善用as關鍵字。雖然不做隱性運算會讓程式碼更加攏長，但這也減少許多bug的發生。最後，std::f32::consts和std::f64::consts提供了一些常數，例如：PI、E、LOG2_E、LOG10_E、LN_2、LN_10等。","code":"assert_eq!(f32::INFINITY, 1.0/0.0);\nassert!((-1. / f32::INFINITY).is_sign_negative());let x = 2.0_f64.exp();\nassert_eq!(x, std::f64::consts::E.powf(2.0));\nassert_eq!((-1.22f64).sqrt(), std::f64::NAN);"},{"path":"day2---型態.html","id":"布林型態","chapter":"3 Day2 - 型態","heading":"3.3 布林型態","text":"Rust的布林值，分為true和false，透過一些比較運算子產生許多語言都為布林判斷偷偷開了後門，如C將字元、整數、指標等隱性轉換為布林值，讓你在if或while裡直接將他們當作條件。但Rust不准你這樣做，即使在短路邏輯用算子&&和||裡也不行。你必須寫出if x!=0{…}，而不是if x{…}。但你可以可以用as運算子將bool轉換為整數型態，但數字不能反向轉換為布林值。","code":"assert_eq!(true as i32, 1);\nassert_eq!(false as i32, 0);"},{"path":"day2---型態.html","id":"tuple型態","chapter":"3 Day2 - 型態","heading":"3.4 tuple型態","text":"tuple可以是一對、三個、四個各種不同型態的值組合成的值例：(“Taipei”, 25, 100.0)這個tuple的型態是(&str, i32, f64)，你可以用tuple.0、tuple.1、tuple.2來取得裡面的值。但可惜你只能用常數來獲取值，而非變數，如tuple.0是合法的，但tuple.i是不合法的。這樣的tuple型態在rust中通常來幫函式回傳多個值，假如你有一個string slice要處理，你可以使用split_at()，這個函式會回傳一個tuple，裡面包含了兩個string slice，分別是原始string slice的前半部和後半部。該宣告式應該長這樣fn split_at(&self, mid: usize) -> (&str, &str)，你可以用let (first, second) = s.split_at(3);來取得這兩個string slice。我們常常不自覺的使用tuple，例如我們想要將一個file的檔名(&str,pixel(u8),和長寬(usize, usize)，最正規的是寫一個struct，但若作為過渡的資料結構，tuple為你做簡單明確的橋樑。另外一種是當作零tuple，也稱單元型態，只有一個值，寫成()。他出現在Rust需要某種型態，但又缺乏有意義的值可以使用。例如，不回傳值的函式回傳型態有些回傳這個型態，在std::men::swap函式中，沒有「有意義」的回傳值，而是單純的交換兩個變數的值，他的宣告式如下：另外我們常寫的Result<(), std::io::Error>，出錯時回傳std::io::Error的值，而成功則不回傳有意義的值。","code":"let tuple = (\"Taipei\", 25, 100.0);\ntuple.0\n#> [1] \"Taipei\"let s = \"Taipei\";\nlet (first, second) = s.split_at(3);\nrprintln!(\"{} {}\", first, second);\n#> Tai peifn write_image(filename: &str, pixels: &[u8], width: usize, height: usize)//<T>代表swap的「泛型」，可以處理任何型態的T參考值。\nfn swap<T>(x: &mut T, y: &mut T)\n//其實有回傳()，但寫的時候省略"},{"path":"day2---型態.html","id":"指標型態","chapter":"3 Day2 - 型態","heading":"3.5 指標型態","text":"Rust有幾種代表記憶體地址的型態，這是Rust和具備垃圾桶(garbage collection:記憶體回收)機制的語言之巨大差異，也是Rust看似繁瑣的型態系統的一部分。在Java中，如果class Rectangle中Vector2D upperleft; upperleft是分別建立的另一個Vector2D物件的參考，Java物件內部絕對不會有實際的其他物件。而Rust為管理並減少記憶體配置，在預設情況，值是崁套的，假設一個((0,0), (144, 122))值存成4個相鄰的整數。如果你將它存入一個區域變數，你會得到一個寬為四個整數的「區域變數」。Rust不會在heap上配置記憶體，除非你明確要求。這樣的做法是記憶體友好的，但如果要讓一個值指向另一個值，你必須明確的使用指標。強大的是，在safe Rust裡的標型態都受到約束，以消除為定義行為。","code":""},{"path":"day2---型態.html","id":"reference","chapter":"3 Day2 - 型態","heading":"3.5.1 Reference","text":"在入門段，我們常常使用簡單的ref來做參考，在執行期，一個指向i32的參考是一個機器word，保存的是i32的「地址」，該位子可能在stack也可能在heap。運算式&x產生一個指向x的參考，而*ptr則是取得ptr指向的值。多提一嘴，Rust參考絕對不會是null，並會記錄所有權與生命期，諸如懸空指標、重複釋出與無效指標的會在編譯期被排除。兩種參考型態：&T：不可變參考，你不能透過它來修改值。一個值可以有多個共享參考&T：不可變參考，你不能透過它來修改值。一個值可以有多個共享參考&mut T：可變參考，你可以透過它來修改值。一個值只能有一個可變參考，且在該參考存在期間，不可有其他參考存在。&mut T：可變參考，你可以透過它來修改值。一個值只能有一個可變參考，且在該參考存在期間，不可有其他參考存在。這兩種區別在編譯器檢查與執行時，可以確保程式的安全。","code":""},{"path":"day2---型態.html","id":"box","chapter":"3 Day2 - 型態","heading":"3.5.2 Box","text":"若你想在heap上配置值，最簡單的就是呼叫Box::new()b的型態是Box，當b離開作用域時，記憶體會被立刻釋出，除非移動，例如被回傳。移動是Rust非常重要的概念會提到，我們會在後面章節詳細介紹。","code":"let x = 10;\nlet b = Box::new(x);// 在heap上配置一個i32\n\nlet c = *b;// 取得b指向的值\nlet z = &b;// 取得b的參考\n\nrprintln!(\"{} {} {}\", c, b, z);\n\n#> 10 10 10"},{"path":"day2---型態.html","id":"原始指標","chapter":"3 Day2 - 型態","heading":"3.5.3 原始指標","text":"原始指標像C++同款，這在Rust是unsafe的，因爲程式不會追蹤它，因此他容易出錯，例如指向null或未初始化的記憶體。","code":""},{"path":"day2---型態.html","id":"陣列","chapter":"3 Day2 - 型態","heading":"3.5.4 陣列","text":"陣列的型態是[T; N]，T就像前面所述代表型態，N是長度，大小是執行期決定的常數，不能擴增或縮減。陣列有多種寫法，最簡單也常見的就是放在中括號裡如果要寫一個長陣列，裏面放差不多的值，可以寫成[V; N]，V是值，N是長度，例如：有些時候會用這種方法代表緩衝區，如上例就是1KB的緩衝區。如上述，因爲判斷長度在編譯期就是固定的，所以你不能用變數n來產生有n個值的陣列。陣列的方法其實都是Rust偷偷將陣列的參考轉換成silce，因此你才能在陣列上使用slice的方法。","code":"let a [u8; 3] = [1, 2, 3];[0_u8; 1024]let mut a = [5, 4, 3, 2, 1];\n\na.sort();\n\nfor x in a {\n  rprintln!(\"{}\", x);\n}\n#> 1\n#> 2\n#> 3\n#> 4\n#> 5\n#> NULL"},{"path":"day2---型態.html","id":"向量","chapter":"3 Day2 - 型態","heading":"3.5.5 向量","text":"最原始的向量是長這樣ＬVec，看到了嗎，只有型態沒長度，這代表你可以隨著時變去改變大小，他會在heap上配置記憶體，並且會在不需要時自動釋放。如果你知道向量的長度，你可以用vec!宏來建立，例如：因為他是向量，你可以繼續加入值：另外一種方式是呼叫Vec::new()來產生新的向量，然後用push()來加入值。也可以用iterator產的生的值來建立向量，例如：向陣列一樣，向量也會找到slice的方法。如果你事先知道向量的長度，你可以使用Vec::with_capacity()來代替Vec::new()，這樣預先留下夠大的緩衝區，可以減少向量擴增時的記憶體配置次數。在設計函式時常常用到這樣的優勢，如colloect()，iterator會事先知道向量有幾個值，以正確的預先配置回傳向量。向量的len()會告訴你向量的長度，capacity()會告訴你在不重新配置的情況下可以容納的元素。你可以用insert(位置, 值)來插入元素，用remove(位置)來移除元素最後介紹pop()，他會從Vec pop值會得到Option，如果最後一個值是v，則回傳Some(v)，否則回傳None。","code":"let vec = vec![1, 2, 3, 4, 5];\nvec.push(6);let mut vec = Vec::new();\nvec.push(1);\nvec.push(2);let a = [5, 4, 3, 2, 1];\nlet mut vec = Vec::new();\n\nfor x in a {\n  vec.push(x);\n}\n\nfor x in vec {\n  rprintln!(\"{}\", x);\n}\n#> 5\n#> 4\n#> 3\n#> 2\n#> 1\n#> NULLlet mut vec = Vec::with_capacity(2);\nrprintln!(\"len:{}, capacity:{}\", vec.len(), vec.capacity());\n\nvec.push(1);\nvec.push(2);\nrprintln!(\"len:{}, capacity:{}\", vec.len(), vec.capacity());\n\nvec.push(3);\nrprintln!(\"len:{}, capacity:{}\", vec.len(), vec.capacity());\n\n#> len:0, capacity:2\n#> len:2, capacity:2\n#> len:3, capacity:4let mut vec = vec![1, 2, 3, 4, 5];\n\n//在1與2之間插入0\nvec.insert(1, 0);\n\n//移除3\nvec.remove(3);\n\nrprintln!(\"{:?}\", vec);\n#> [1, 0, 2, 4, 5]let mut vec = vec![\"哈囉\", \"世界\"];\n\nrprintln!(\"{:?}\", vec.pop());\nrprintln!(\"{:?}\", vec.pop());\nrprintln!(\"{:?}\", vec.pop());\n#> Some(\"世界\")\n#> Some(\"哈囉\")\n#> Noneuse std::process::Command;\n\nlet mut cmd = Command::new(\"ls\");\nlet res = cmd.output();\nrprintln!(\"{:?}\", res);\n#> Ok(Output { status: ExitStatus(unix_wait_status(0)), stdout: \"01-Day1.Rmd\\n01-Day1.md\\n02-Day2.Rmd\\n03-Day3.Rmd\\n04-Day04.Rmd\\n05-Day5.Rmd\\n06-Day06.Rmd\\n07-.Rmd\\n08-結構.Rmd\\n09.Rmd\\n10-Day10.Rmd\\n11-closure.Rmd\\n12-Iterator.Rmd\\n13-集合.Rmd\\nREADME.md\\nRust書.Rproj\\nRust書.rds\\nUntitledRMD.Rmd\\n_book\\n_bookdown.yml\\n_common.R\\n_output.yml\\nactix\\nartist\\nbook.bib\\nchicago-fullnote-bibliography.csl\\ndoc.png\\ndst\\nfern_sim\\nfiredata\\nguess\\nhealth\\nindex.Rmd\\nindex.md\\njason\\nmandelbort\\npackages.bib\\npreamble.tex\\nrender136b12b6d2f5c.rds\\nrender176a9e828c7a.rds\\nsrc\\nstyle.css\\nteer\\nwww\\n\", stderr: \"\" })"},{"path":"所有權與移動.html","id":"所有權與移動","chapter":"4 所有權與移動","heading":"4 所有權與移動","text":"","code":""},{"path":"所有權與移動.html","id":"所有權與移動-1","chapter":"4 所有權與移動","heading":"4.1 所有權與移動","text":"為了讓整個程式能更好的運用記憶體，我們指望程式能做到兩件事：1.指標絕對不能指向已釋出的物件，避免未定義行為造成安全漏洞2.用有自行決定記憶體何時釋放與速度的權利，減少無意義的損耗但想同時擁有這兩項優勢並不容易，尤其是高度的記憶體自由，由你掌控何時釋出，容易造成值的指標懸空。目前的程式可依者兩種優點而分為兩種陣營。安全派：使用垃圾回收的技術來管理記憶體，當所有指向該物件的指標消失時，它會自動釋放該物件，如此你不必為懸空指標憂慮，但同時你也失去了「自行決定何時將物件回收」的權利。目前幾乎所有程式都屬於這個派別，如C#、python、R、Java自由派：你能選擇何時釋出記憶體，但避免懸空指標的出現全都是你的責任。此派主流語言只有：C和C++而Rust生來就是要同時獲取兩種優勢，不然也沒必要學。因此，Rust用限制指標的使用來解決問題。這勢必會造成困擾，許多我們過去隨意使用的型態與寫法都將放棄。但也就是這些「困擾」，讓Rust能用編譯檢查機制來確保沒有安全混亂，如懸空指標、重複釋出、使用未初始化記憶體。這一套秩序也是並行設計的根基，如執行緒基元(threading primitibve)確保沒有資料爭用問題。在這些限制下寫出安全且靈活的程式，是你在學習Rust之路最大的挑戰，同時也是優勢。本章將帶你了解所有權的概念，比較不同語言的運作方式，進而學習如何處理與追蹤所有權的改變。","code":""},{"path":"所有權與移動.html","id":"所有權","chapter":"4 所有權與移動","heading":"4.2 所有權","text":"C++與C是由所有權人決定何時釋出物件，當所有權人銷毀時，物件也被毀滅。在堆疊中，std::string的長是3 word，分別裝的是緩衝區、容量、長度，他們都會指向heap，而hello就被放在heap中。當字串被銷毀時，字串的解構式(destructor)會被呼叫，這時std::string會釋放heap中的記憶體。你可以建立臨時指標來指向他人擁有的記憶體(如s擁有的h字元)，但當s字串被註銷時，指標就會無效，不得再使用。這種賦予所有權人絕對性的權利決定擁有物件的生命週期的方式，也是Rust的核心概念。每個值都需有決定期生命週期的所有權人，當所有權人被釋出(dropped)時，值也會被釋出。讓編譯器可以ㄧ眼看穿每一個值的生命週期，並以此檢測漏洞。在Rust中，當控制離開宣告該變數的區塊時，變數銷毀，同時卸除值。以Rust的Box為例，Box指向heap裡T型態值的指標。當你呼叫Box::new(v)的時候，系統會配置空間將v塞入，並且回傳一個指向該空間的Box。當box銷毀時，空間釋出。堆疊框本身保有變數(point、label)，兩個Box指向個別的heap空間。而在變數被卸除時，他們擁有的空間也會被釋放。舉另外一個複雜的例子，同時有tuple、struct、String、向量在這個結構中，最上層的堆疊匡是composers，擁有一個向量，而緩衝區則指向放有各個以Person為型態的heap空間。接著，如birth：i32的定寬數字直接配置在heap中，而string則有其容量、長度、緩衝區指向heap中的字串。當控制離開宣告composers的作用域後，composers會被卸除，連帶地卸除整個配置。如前所述，Rust會強迫每個值都有一個所有權人，但每一個所有人可以擁有多個值，如composers擁有3個Person元素。並且在複雜的架構中，會形成樹狀的架構，成為父子關係。當父親被銷毀時，他的子女也會被銷毀。如composers是3個元素的父輩，而3個元素又有個別的String子輩。因此在Rust中，你不會看到雜亂的架構，每一個值都是某棵樹的一分子。上述講述的例子可能讓你覺得Rust是一個僵化語言，但實作上可以作出靈活的延伸透過所有權的移動，重新排列樹狀結構，透過所有權的移動，重新排列樹狀結構，使用整數、浮點數、字元等簡單的型態，他們不受所有權的限制，稱為Copy型態使用整數、浮點數、字元等簡單的型態，他們不受所有權的限制，稱為Copy型態透過借用一個值的參考，使用這種無所有權、具有限生命週期的指標透過借用一個值的參考，使用這種無所有權、具有限生命週期的指標利用標準程式庫提供的參考計數(reference-counted)指標型態Rc與Arc，在特殊情況下讓值有多個所有權人利用標準程式庫提供的參考計數(reference-counted)指標型態Rc與Arc，在特殊情況下讓值有多個所有權人","code":"std :: string s = \"hello\";{\n   let point = Box::new((11, 13));  //ponit在此配置\n   let label = format!(\"{:?}\", point); //label在此配置\n   println!(\"label：{}\", label);\n   println!(\"point：{:?}\", point);\n}  //point與label在此銷毀\n#> NULLstrut Person {\n    name: String,\n    birth: i32,\n}\n\nlet mut composers = Vec::new();\ncomposers.push(Person {name: \"Palestrina\".to_string(), birth: 1525});\ncomposers.push(Person {name: \"Dowland\".to_string(), birth: 1563});\ncomposers.push(Person {name: \"Lully\".to_string(), birth: 1632});\n\nfor composer in &composers {\n    println!(\"{}, born {}\", composer.name, composer.birth);\n}"},{"path":"所有權與移動.html","id":"移動","chapter":"4 所有權與移動","heading":"4.3 移動","text":"在Rust中，大多數型態下，諸如將值指派給變數、將值回傳函式、從函式回傳值、將值傳遞給函式等操作，都不是複製，而是移動。當值被移動時，原本的變數為未初始化，該值的所有權被轉移。因此在以下例子，s1的所有權被轉移給s2，s1變成未初始化，無法再使用，當你再嘗試把s1傳給s3時，編譯器會報錯。✖ error[E0382]: use moved value: s1\n–> src/lib.rs:7:10\n|\n5 | let s1 = vec[“aaa”.to_string(), “bbb”.to_string()];\n| – move occurs s1 type Vec<String>, implement Copy trait\n6 | let s2 = s1;\n| – value moved \n7 | let s3 = s1;\n| ^^ value used move為什麽要有這種特性呢？我們可以先看兩個主流陣營的做法，比較優缺。","code":"let s1 = vec![\"aaa\".to_string(), \"bbb\".to_string()];\nlet s2 = s1;\nlet s3 = s1;"},{"path":"所有權與移動.html","id":"python","chapter":"4 所有權與移動","heading":"4.3.1 python","text":"python的每個物件都有一個參考數量，以此來記錄有多少值引用他。ㄧ開始初始化s1時，PyListObject的參考數量為1，當s2=s1時，參考數量變為2，s3=s1時，參考數量變為3。這讓python的賦值成本很低，但因為每次都會建立新參考，也代表著必須紀錄參考數才能知道何時釋出。","code":"s1 = ['aaa', 'bbb']\ns2 = s1\ns3 = s1"},{"path":"所有權與移動.html","id":"c","chapter":"4 所有權與移動","heading":"4.3.2 C++","text":"在C++中，當你將s1指派給s2時，會將整個副本都複製給s2。因此s1與s2都是獨立的，短短的幾行已經有3個向量、6個字串，如此的深度複製會造成損耗，但程式也容易決定何時釋出所有記憶體。","code":"using namespace std;\nvector<string> s1 = {\"aaa\", \"bbb\"};\nvector<string> s2 = s1;\nvector<string> s3 = s1;"},{"path":"所有權與移動.html","id":"rust","chapter":"4 所有權與移動","heading":"4.3.3 Rust","text":"如果你想要像C++一樣進行深複製，而不是移動，你應該呼叫向量的clone方法。你也可以使用我們前面提到的參考計數指標來模仿python的行為，也就是共享所有權。","code":"let s1 = vec![\"aaa\".to_string(), \"bbb\".to_string()];\nlet s2 = s1.clone();\nlet s3 = s1.clone();"},{"path":"所有權與移動.html","id":"移動與控制","chapter":"4 所有權與移動","heading":"4.3.4 移動與控制","text":"因為Rust會移動值，因此在預到控制流程時，你必須把握「如果值可能被移動，則必須考慮初始化的風險」迴圈也會有類似的問題，有可能在回圈中s1就會被移動，導致s2會被賦予未初始化的值(空的s)。","code":"let s1 = vec![\"aaa\".to_string(), \"bbb\".to_string()];\nif c {\n    let s2 = s1;\n} else {\n    let s3 = s1;\n}\ns4 = s1;// 錯誤，s1可能已經被移動let s1 = vec![\"aaa\".to_string(), \"bbb\".to_string()];\nwhile c {\n    let s2 = s1;\n    break;\n}"},{"path":"所有權與移動.html","id":"移動與檢索","chapter":"4 所有權與移動","heading":"4.3.5 移動與檢索","text":"一般來說，移動會將值的來源端變成未初始化，但許多情況下，所有權人會阻止隨意地移動。以上這段程式會出錯，並建議你改用參考，如果你還是想要將向量的值移出，你可以參考以下的寫法。再以上面Person的例子中，編譯器無法追蹤以struct包裝的string的所有權的移動狀況，但可以考慮用Option來動態追蹤。","code":"let mut v = Vec::new();\nfor i in 101..106 {\n    v.push(i.to_string());\n}\n\nlet third = v[2];\nlet fifth = v[4];let mut v = Vec::new();\nfor i in 101..106 {\n    v.push(i.to_string());\n}\n\n//1.pop method\n//移出向量的最後一個值\nlet fifth = v.pop().expect(\"no fifth element\");\nrprintln!(\"fifth: {}\", fifth);\n\n//2. swap_remove method\n//移出向量的指定位置值\nlet second = v.swap_remove(1);\nrprintln!(\"second: {}\", second);\n\n// 3.replace method\n// 用一個值來做交換\n\nlet third = std::mem::replace(&mut v[2], \"substitute\".to_string());\nrprintln!(\"third: {}\", third);\n\nrprintln!(\"v: {:?}\", v);\n#> fifth: 105\n#> second: 102\n#> third: 103\n#> v: [\"101\", \"104\", \"substitute\"] #[derive(Debug)]\nstruct Person {\n    name: Option<String>,\n    birth: i32,\n}\n\nlet mut composers = Vec::new();\ncomposers.push(Person {name: Some(\"Palestrina\".to_string()), birth: 1525});\ncomposers.push(Person {name: Some(\"Dowland\".to_string()), birth: 1563});\n\nlet first_name = std::mem::replace(&mut composers[0].name, None);\nrprintln!(\"first_name: {:?}\", first_name);\nrprintln!(\"composers: {:?}\", composers);\n\n// option提供給你take方法，，讓整體更簡潔\nlet second_name = composers[1].name.take();\nrprintln!(\"second_name: {:?}\", second_name);\nrprintln!(\"composers: {:?}\", composers);\n#> first_name: Some(\"Palestrina\")\n#> composers: [Person { name: None, birth: 1525 }, Person { name: Some(\"Dowland\"), birth: 1563 }]\n#> second_name: Some(\"Dowland\")\n#> composers: [Person { name: None, birth: 1525 }, Person { name: None, birth: 1563 }]"},{"path":"所有權與移動.html","id":"複製型態","chapter":"4 所有權與移動","heading":"4.3.6 複製型態","text":"剛剛我們提過Copy型態，他們不受所有權的限制，可以隨意複製，例如整數、浮點數、字元，這些型態不會像字串、向量等佔用大量的記憶體，以下例子比較：在上面的例子中，s1被賦值時，會在heap中配置一個字串。相反x不會在heap中配置，而是直接在堆疊匡裡配置。另外，當s1給s2時，hello字串的所有權被移轉。而x給y時，不會發生所有權的轉移，而是產生一個完全獨立的副本。這樣的區分除了在為記憶體空間的考量外，非Copy型態的值在被卸除時都要做某些特別的事。例如前面所述的Vec，卸除時須要讓元素釋放、File型態要關閉檔案控制碼、MutexGuard需要解鎖等等。那如果是自己定義的型態呢？✖ error[E0382]: borrow moved value: p\n–> src/lib.rs:16:28\n|\n14 | let p = Point {x: 1, y: 2};\n| - move occurs p type Point, implement Copy trait\n15 | print(p);\n| - value moved \n16 | rprintln!(“({}, {})”, p.x, p.y);\n| ^^^ value borrowed move\n|這裡的抱錯告訴你，在print(p)後，p的所有權被移動，所以你不能再使用p。所以在預設情況下，自定義的型態都是非Copy型態。但明明point型態裡放的都是整數，沒有必要動來動去！因此，你可以加入#[derive(Copy, Clone)]來讓point型態成為Copy型態。不過注意，如果你的型態裡有非Copy型態的成員，那麽你可不能用#[derive(Copy, Clone)]，而是要自己實作Copy與Clone trait。","code":"let s1 = \"hello\".to_string();\nlet s1 = s2;\n\nlet x = 5;\nlet y = x;struct Point {\n    x: i32,\n    y: i32,\n}\n\nfn print(p: Point) {\n    rprintln!(\"({}, {})\", p.x, p.y);\n}\n\nlet p = Point {x: 1, y: 2};\nprint(p);//\nrprintln!(\"({}, {})\", p.x, p.y);"},{"path":"所有權與移動.html","id":"rc與arc共享所有權","chapter":"4 所有權與移動","heading":"4.4 Rc與Arc：共享所有權","text":"所有權帶來安全，但設計程式免不了遇到需要保留值到最後，卻找不到適合的單一所有權人，又或著需要在多個執行緒間共享值。這時你可以使用Rc與Arc，他們是參考計數指標，可以讓值有多個所有權人。Rc與Arc的差別在於Arc可以在不同的執行緒間共享，Rc則是以高速在單執行緒間更改參數量，除此之外，兩者是等效，因此我們以Rc示範。Rc就是重現python的參考數管理生命週期的方式Rc是一個指向heap裡的指標，並且附帶一個參考數量。當你呼叫clone時，並非移動或複製，而是另外一個指向同個heap的指標，並且增加參考數。Rc的值並不可變，於此來確立執行緒安全的保障。所以，「任何值不可以是既共享又可變」。參考管理記憶體最大的問題是：當兩個參考計數的值互指，導致計數永遠不會歸零，卡在記憶體不被釋出。這種情況通常出現在舊值可變的情況，因為這樣才會出現此種循環，剛好Rust的機制讓這種情況很難發生。","code":"use std::rc::Rc;\n\nlet s = Rc::new(\"shirataki\".to_string());\nlet s2 = s.clone();\nlet s3 = s.clone();"},{"path":"所有權與移動.html","id":"總結","chapter":"4 所有權與移動","heading":"4.5 總結","text":"在此章節中，我們先學會了Rust的所有權概念，並且比較了不同語言的運作方式。接著，了解移動、複製與共享3種讓所有權更彈性。下一章節我們將討論最後一招：借用值的參考。","code":""},{"path":"參考.html","id":"參考","chapter":"5 參考","heading":"5 參考","text":"在上一章看到的所有指標，從Boxheap指標，以及String與Vec的內部指標，都擁有所有權：也就是說，當所有權人被卸除時，他的參考對象也隨之卸除。Rust也有無所有權指標，稱為參考，不會影響參考對象的生命週期。參考的概念就是取得位址，但在Rust中，參考的生命週期絕對不能超過參考的生命週期，來保證運作的安全性，換言之，正確理解Rust參考的方式是「借用值」，總有一天要歸還給所有權人。","code":""},{"path":"參考.html","id":"值的參考","chapter":"5 參考","heading":"5.1 值的參考","text":"我們要製作單曲與其歌手的表格，可以用雜湊表(HashMap)來儲存，並寫一個show函式來顯示表格在主要函式中，只要插入元素，並使用上面的函式即可輕鬆執行在看完前一章後，你會問HashMap的值如何傳遞的？那恭喜你，HashMap是以動態配置一個表，當你呼叫show(table)時，整個table會被移入函式，由for取得所有權，並ㄧ層ㄧ層的耗用，直到全部被銷毀。會產生錯誤告訴你，table已經被用掉了，應該用reference來取代那又要使用哪種參考呢？共享參考(shared reference)：可以讓任意數量的共享參考指向同一個值，但不能修改參考值。&e會產生e的共享參考，e的型態是T，&e的型態是&T。共享參考(shared reference)：可以讓任意數量的共享參考指向同一個值，但不能修改參考值。&e會產生e的共享參考，e的型態是T，&e的型態是&T。可變參考(mut reference)：只能有一個可變參考指向同一個值，但可以修改參考值。&mut e會產生e的可變參考，e的型態是T，&mut e的型別是&mut T。他不是Copy可變參考(mut reference)：只能有一個可變參考指向同一個值，但可以修改參考值。&mut e會產生e的可變參考，e的型態是T，&mut e的型別是&mut T。他不是Copy你可以用「多個讀取方」與「單一寫入方」來區分，當你使用共享參考時，「任何人」都無法修改值，即使是原本的所有權人。相反，在可變參考出現時，只有在其消滅時，方能再次使用。回到上面範例，show函式僅需要讀取table，因此我們已共享參考的方式改寫，只需要將show函式的參數型態改為&Table即可，同時記得在主要函式中，要放入&table。只需改變最上層的型態，如當Table變為&Table時，Vec會變為&Vec，String會變為&String，這樣就可以達到「借用值」的目的。而如果你想修改或是用方法，記得用可變參考，如用sort方法來排序歌曲","code":"use std::collections::HashMap;\ntype Table = HashMap<String, Vec<String>>;\n\nfn show(table: Table){\n  for(artist, album) in table {\n    rprintln!(\"{}的單曲：\", artist);\n    for song in album {\n      rprintln!(\" {}\", song);\n    }\n  }\n}\nfn main() {\n  let mut table = Table::new();\n  \n  table.insert(\"周杰倫\".to_string(), vec![\"青花瓷\".to_string(), \"稻香\".to_string()]);\n  table.insert(\"蔡依林\".to_string(), vec![\"倒帶\".to_string(), \"愛情三十六計\".to_string()]);\n  table.insert(\"張學友\".to_string(), vec![\"吻別\".to_string(), \"當愛已成往事\".to_string()]);\n  \n  show(table);\n  \n}#>  [1m [32m    Finished [0m `dev` profile [unoptimized + debuginfo] target(s) in 0.00s\n#>  [1m [32m     Running [0m `artist/target/debug/artist`\n#> 蔡依林的單曲：\n#>  倒帶\n#>  愛情三十六計\n#> 周杰倫的單曲：\n#>  青花瓷\n#>  稻香\n#> 張學友的單曲：\n#>  吻別\n#>  當愛已成往事show(table);\nassert_eq!(table[\"周杰倫\"], [\"青花瓷\", \"稻香\"]);error[E0382]: borrow of moved value: `table`\n  --> src/main.rs:23:14\n   |\n16 |   let mut table = Table::new();\n   |       --------- move occurs because `table` has type `HashMap<String, Vec<String>>`, which does not implement the `Copy` trait\n...\n22 |   show(table);\n   |        ----- value moved here\n23 |   assert_eq!(table[\"周杰倫\"], [\"青花瓷\", \"稻香\"]);\n   |              ^^^^^ value borrowed here after move\n   |\nnote: consider changing this parameter type in function `show` to borrow instead if owning the value isn't necessary\n  --> src/main.rs:5:16\n   |\n5  | fn show(table: Table){\n   |    ----        ^^^^^ this parameter takes ownership of the value\n   |    |\n   |    in this function\nhelp: consider cloning the value if the performance cost is acceptable\n   |\n22 |   show(table.clone());\n   |             ++++++++fn show(table: &Table){\n  for(artist, album) in table {\n    println!(\"{}的單曲：\", artist);\n    for song in album {\n      println!(\" {}\", song);\n    }\n  }\n}\n\nfn main() {\n  \n  ...\n  \n  show(&table);\n  assert_eq!(table[\"周杰倫\"], [\"青花瓷\", \"稻香\"]);\n}fn sort_album(table: &mut Table){\n  for(_, album) in table {\n    album.sort();\n  }\n})"},{"path":"參考.html","id":"隱性參考","chapter":"5 參考","heading":"5.2 隱性參考","text":"在可變參考時也相同：請再次觀察第一個例子，我們為何不用在使用元素時解參考呢？答案是，因為參考在Rust裡太常出現，運算子.可以用來隱性解參考","code":"let x = 5;\nlet y = &x;  //必須要嚴明參考\nassert!(*y == 5); //解參考時要明確\n#> NULLlet mut x = 5;\nlet n = &mut x;\n*n += 32;\nassert!(*n == 37);struct Person {\n  name: String,\n  age: i32,\n}\nlet p = Person {name: \"John\".to_string(), age: 32};\nlet p_ref = &p;\n\nassert_eq!(p_ref.name, \"John\");\n//相當於\nassert_eq!((*p_ref).name, \"John\");"},{"path":"參考.html","id":"參考的參考","chapter":"5 參考","heading":"5.3 參考的參考","text":"Rust允許多重參考，可以一層一層直到借到一個值：上面例子，r1借用p的值，r2會穿過r1到p借用值，也就是說，兩者值相同，但位址不同下面例子告訴你，==會自動指向最後的值，但std::ptr::eq會比較位址","code":"let p:i32 = 1;\nlet r1: &i32 = &p;\nlet r2: &&i32 = &r1;\nlet r3: &&&i32 = &r2;\nrprintln!(\"{} {} {}\", r1, r2, r3);\n#> 1 1 1let p:i32 = 1;\nlet c:i32 = 1;\n\nlet r1: &i32 = &p;\nlet r2: &i32 = &c;\n\nrprintln!(\"{} {}\", r1, r2);\nrprintln!(\"{}\", r1 == r2);\nrprintln!(\"{}\",std::ptr::eq(r1, r2));\n#> 1 1\n#> true\n#> false"},{"path":"參考.html","id":"借用任意運算式的參考","chapter":"5 參考","heading":"5.3.1 借用任意運算式的參考","text":"在Rust裡，你可以直接借用運算式的值(的參考)在借用的對象是運算式時，Rust會產生ㄧ個匿名變數來保存值，而這個變數的生命週期取決於使用參考的方式，若如同上面的&factorial(6)，直接指派給r，那麽他的生命週期就隨r。反之，如&(1+2)在封閉陳述式內，他的生命週期就是這個陳述式。","code":"fn factorial(n: usize) -> usize {\n  (1..n+1).product()\n}\n\nlet r = &factorial(6);\nrprintln!(\"{}\", r+&(1+2));\n#> 723"},{"path":"參考.html","id":"借用區域變數","chapter":"5 參考","heading":"5.4 借用區域變數","text":"下面的案例，告訴你注意借用值的生面週期會告訴你，因為x掛點了，但借用他值的r還活著，導致出現了懸空指標在處理一般的資料結構時，會順理成章的避免發生者種狀況，因為都是先有資料，參考都是在資料之後產生，因此解決這種「限制」的最好方式，就是安排好資料的生命週期與宣告順序。","code":"let r;\n  {\n  let x = 5;\n  r = &x;\n  }\n\nrprintln!(\"{}\", *r);✖ error[E0597]: `x` does not live long enough\n  --> src/lib.rs:8:7\n   |\n7  |   let x = 5;\n   |       - binding `x` declared here\n8  |   r = &x;\n   |       ^^ borrowed value does not live long enough\n9  |   }\n   |   - `x` dropped here while still borrowed\n10 |\n11 | rprintln!(\"{}\", *r);\n   |                 -- borrow later used herelet x = 1;\n{\n  let r = &x;\n  rprintln!(\"{}\", r);\n}\n#> 1\n#> NULL"},{"path":"參考.html","id":"用函式引數來接收參考","chapter":"5 參考","heading":"5.5 用函式引數來接收參考","text":"以函式引數接收參考時，同樣注意生命週期、可變性、型態等問題你可以將static理解為全域變數，會ㄧ直存在於整個執行期。而可變的static是不安全的，你只能在unsafe區塊中使用。其二，每一個static都必須初始化。如果型態的問題已解決，讓我們來看看生命週期：完整的f是長fn f<'>(p : &'i32)’a的概念是任何生命週期，只要涵蓋f的區域即可。但static必須是整個生命週期，你必須很明確的指出，我們要的生命週期是static退一步來說，雖然略為麻煩，但你可以從簽章看出一個函式的意圖，如從fn f<'>(p : &'i32)到fn f(p: &'static i32)，你可以從中看出生命週期，而不用重新閱讀一長串程式。","code":"// 以下無法成功編譯\nstatic mut STASH:&i32;\nfn f(p : &i32) {\n  STASH = p;\n}// 修改後依然有小錯誤\nstatic mut STASH:&i32 = &10;\nfn f(p : &i32) {\nunsafe{\n  STASH = p;\n  }\n}// 終於解決問題\nstatic mut STASH:&i32 = &10;\nfn f(p: &'static i32) {\nunsafe{\n  STASH = p;\n  }\n}"},{"path":"參考.html","id":"回傳參考值","chapter":"5 參考","heading":"5.6 回傳參考值","text":"在處理資料時，我們常傳入一部分資料，並回傳一個結果，例如以下要取得整個slice裡的最小值同樣的，以上函式省略了週期，明確地寫出會是fn smallest<'>(v:&'i32) -> &'i32，你可以看到，回傳值的生命週期與引數的生命週期相同，這是Rust預設的概念。因此，當回傳值的生命週期大於引數的生命週期，就會提醒你發生錯誤解決以上問題，只要注意生命週期即可","code":"fn smallest(v:&[i32]) -> &i32{\n  let mut s = &v[0];\n  for r in &v[1..] {\n    if *r < *s {\n      s = r;\n    }\n  }\n  s\n}\n#> NULLlet s;\n  {\n    let v = [1, 2, 3, 4, 5];\n    s = smallest(&v);\n  }\n\nrprintln!(\"{}\", s);✖ error[E0597]: `v` does not live long enough\n  --> src/lib.rs:20:18\n   |\n19 |     let v = [1, 2, 3, 4, 5];\n   |         - binding `v` declared here\n20 |     s = smallest(&v);\n   |                  ^^ borrowed value does not live long enough\n21 |   }\n   |   - `v` dropped here while still borrowed\n22 |\n23 | rprintln!(\"{}\", s);\n   |                 - borrow later used herelet s;\n  {\n    let v = [1, 2, 3, 4, 5];\n    s = smallest(&v);\n    rprintln!(\"{}\", s);\n  }\n#> 1\n#> NULL"},{"path":"參考.html","id":"包含參考的結構","chapter":"5 參考","heading":"5.7 包含參考的結構","text":"以下是過去錯誤的例子Rust就是如此嚴謹，即使放入結構中，也要注意週期的概念我們再次把完整的內容寫出來struct S<'> { r: &'i32 }，於此，s的週期’a不會超過x如果我們要將有週期的參數型態，就要明確的指出，有兩個方法","code":"struct S {\n r: &i32\n}\n\nlet s;\n{\n  let x = 10;\n  s = S{r: &x};\n}\nrprintln!(*s.r, 10);// 錯誤：x已被卸除struct S {\n r: &i32\n}\n\n//Rust會要求你寫出生命週期\nstruct D {\n s: S\n}\n\n//可以指定s為static\nstruct D {\n s: S<'static>\n}\n\n//編譯器會提供你這個做法\nstruct D<'a> {\n s: S<'a>\n}"},{"path":"參考.html","id":"不同生命週期的結構","chapter":"5 參考","heading":"5.7.1 不同生命週期的結構","text":"上面我們講到結構也要注意週期問題，以下例子有些弔詭，r與x的生命週期最長，次為y，最後是a。我們賦予r結構a的x值，並且在x未死亡前，在最後印出r的值。照理來說，牽涉r值的，僅有r本身與x，所以應該不會有問題。但是，Rust會告訴你，r的生命週期不夠長，因為y已經死亡…其實，秘密就在預設結構的生命週期。結構中，x與y被預設為’，而Rust會以較小的生命週期為主，如同上例中，即使x尚未死亡，但y的生命週期結束，結構中的x也被視為死亡。所以，你可以在結構中就預設不同的生命週期，可以避免這種窘境，並且讓所有人都知道這個結構的生命週期","code":"struct s<'a>{\n  x: &'a i32,\n  y: &'a i32,\n}\n\nlet x = 20;\nlet r;\n{\n  let y = 10;\n  {\n    let a = s{x: &x, y: &y};\n    r = a.x;\n  }\n}\nrprintln!(\"{}\", r);✖ error[E0597]: `y` does not live long enough\n  --> src/lib.rs:15:25\n   |\n13 |   let y = 10;\n   |       - binding `y` declared here\n14 |   {\n15 |     let a = s{x: &x, y: &y};\n   |                         ^^ borrowed value does not live long enough\n...\n18 | }\n   | - `y` dropped here while still borrowed\n19 | rprintln!(\"{}\", r);\n   |                 - borrow later used herestruct s<'a, 'b>{\n  x: &'a i32,\n  y: &'b i32,\n}\n\nlet x = 20;\nlet r;\n{\n  let y = 10;\n  {\n    let a = s{x: &x, y: &y};\n    r = a.x;\n  }\n}\nrprintln!(\"{}\", r);\n#> 20"},{"path":"參考.html","id":"共用與可變性的衝突","chapter":"5 參考","heading":"5.8 共用與可變性的衝突","text":"再次強調兩點：共用參考是唯獨的：你可以讓任意數兩的變數指向，但他不會是可變的，因為可變參考必定會修改或更動原本的值。共用參考是唯獨的：你可以讓任意數兩的變數指向，但他不會是可變的，因為可變參考必定會修改或更動原本的值。可變參考是唯一的：只有一個可變參考指向同一個值，所以也不會出現與共用參考重疊生命週期。可變參考是唯一的：只有一個可變參考指向同一個值，所以也不會出現與共用參考重疊生命週期。所以，上面的例子中，錯誤訊息告訴你，你不能再指向s1(共用參考)，因為在函式內已經建立「唯一」路徑(可變參考)。以機器面來說，當extend獲取第一個參數&mut s1時，因為要加入更多元素，因此要重新配置記憶體。舊的記憶體會先被釋出，此時extend要讀取第二個參數&s1，但這個參數指向的記憶體早已被釋出。","code":"fn extend(v:&mut Vec<f64>, slice:&[f64]){\n  for s in slice {\n    v.push(*s);\n  }\n}\n#> NULLlet mut s1 = Vec::new();\nlet s2 = [1.0, 2.0, 3.0];\nlet s3 = [4.0, 5.0, 6.0];\n\nextend(&mut s1, &s2);\nextend(&mut s1, &s3);\nrprintln!(\"{:?}\", s1);\n#> [1.0, 2.0, 3.0, 4.0, 5.0, 6.0]extend(&mut s1, &s1);✖ error[E0502]: cannot borrow `s1` as immutable because it is also borrowed as mutable\n  --> src/lib.rs:18:17\n   |\n18 | extend(&mut s1, &s1);\n   | ------ -------  ^^^ immutable borrow occurs here\n   | |      |\n   | |      mutable borrow occurs here\n   | mutable borrow later used by calllet mut v = (1,3);\nlet mut r = &v.0;\nlet r1 = &mut r;\n*r1 = &2;\nrprintln!(\"{}\", v.0);\n#> 1"},{"path":"參考.html","id":"結論","chapter":"5 參考","heading":"5.9 結論","text":"總言之，此章節對Rust的參考做了全面性的介紹，尤其注意到生命週期與可變性的概念，揭示了這是一門需要詳細規劃的預言。從自動記憶體管理出現的年代，物件之海成為習以為常的架構模式，它的確可以幫助我們快速開發。但同時，因為物件相互彼此依賴共生，要測試、修改、測試變得困難。而Rust的限制，讓你的架構從一開使就井然有序，因為Rust喜歡讓指標、所有權、資料等朝向同一個地方，這並不容易，所以請繼續往下努力，總有一天你可以建立起架構之海。","code":""},{"path":"day5-運算式.html","id":"day5-運算式","chapter":"6 Day5-運算式","heading":"6 Day5-運算式","text":"Rust是運算式語言，幾乎所有工作都是由運算式完成。","code":""},{"path":"day5-運算式.html","id":"區塊與分號","chapter":"6 Day5-運算式","heading":"6.0.1 區塊與分號","text":"區塊{}是最簡單的運算式，會產生一個值，如下例中，大區塊的結果是author.name()或ip.to_string()，None的區塊產生的值是沒有分號的ip.to_string()。Rust的每一個分號都是有意義的，如在區塊中，通常以()作為回傳的值，但若出現沒有分號的運算式，就會回傳該運算式的值，請再看下面的例子：","code":"let display_name = match post.author() {\n    Some(author) => author.name(),\n    None => {\n      let network_info = post.get_network_metadata()?;\n      let ip = network_info.ip();\n      ip.to_string()\n    }\n}let message{\n  // let宣告式必須有分號\n  let controler = puffball.open();\n  \n  // 運算式加上分號，，是呼叫方法，並卸除回傳值\n  controler.run();\n  \n  // 運算式沒有分號，是呼叫方法，並回傳值\n  // 此例中即回傳給message\n  controler.message()\n}"},{"path":"day5-運算式.html","id":"宣告式","chapter":"6 Day5-運算式","heading":"6.1 宣告式","text":"宣告式最常見的是let，用來宣告區域變數。你可以在宣告同時初始化，也可以選擇不這麼做：在宣告後初始化是很常見的手段，還有有些時候會重複宣告：我們稱這種形式為「shadowing」，第一個line的型態與第二個不同。但有時會造成ㄧ些混淆，所以也可以用另外一個變數取代，如範例中的line_result。第二種是項目宣告式(item declaration)，項目指可以在全域中出現，例如fn、struct或use。以fn為例，任何區塊都可以容忍fn：","code":"let Alex = \"Alex\";\nlet age;\n\nif user.is_adult() {\n  age = 18;\n} else {\n  age = 12;\n}for line in file.lines() {\n  let line = line?;\n}\n\n// 同等的形式是：\nfor line_result in file.lines() {\n  let line = line_result?;\n}use std::io;\nuse std::cmp::Ordering;\n\nfn show_files() -> io::Result<()> {\n  let mut v = vec![];\n  ...\n  \n  fn cmp_by_timestamp_then_name(a: &File, b: &File) -> Ordering {\n    ...\n  }\n  \n  v.sort_by(cmp_by_timestamp_then_name);\n  ...\n  \n}"},{"path":"day5-運算式.html","id":"if與match","chapter":"6 Day5-運算式","heading":"6.2 if與match","text":"if的形式應該非常熟悉，只要記得你不用幫條件式加上括號match與swtch非常相似，以下這個範例是4個分支，最後一個_是萬用分支，類似default，要記得它永遠放在最後。match的限制是，你的選項必須涵蓋所有可能的值，否則會發生錯誤：另外一個規則是，若有回傳值，則每個分支欲回傳的值必須為相同型態，不管是if或match都是如此。","code":"if condition1 {\n  ...\n} else if condition2 {\n  ...\n} else {\n  ...\n}match guess.cmp(&secret_number){\n    Ordering:Less => rprintln!(\"太小了！\"),\n    Ordering:Greater => rprintln!(\"太大了！\"),\n    Ordering:Equal => {\n        rprintln!(\"猜對了！\");\n        break;\n    }\n    _ => rprintln!(\"錯誤！\"),\n}let score = 5;\n\nmatch score {\n  1 => println!(\"糟糕！\"),\n  2 => println!(\"還好！\"),\n  3 => println!(\"不錯！\"),\n}✖ error[E0004]: non-exhaustive patterns: `i32::MIN..=0_i32` and `4_i32..=i32::MAX` not covered\n --> src/lib.rs:7:7\n  |\n7 | match score {\n  |       ^^^^^ patterns `i32::MIN..=0_i32` and `4_i32..=i32::MAX` not covered\n  |\n  = note: the matched value is of type `i32`\nhelp: ensure that all possible cases are being handled by adding a match arm with a wildcard pattern, a match arm with multiple or-patterns as shown, or multiple match arms"},{"path":"day5-運算式.html","id":"迴圈","chapter":"6 Day5-運算式","heading":"6.3 迴圈","text":"Rust的迴圈是運算式，但while與loop的回傳值是()，沒有什麼用。而loop可以在有指定情況下，產生回傳值for 迴圈我相信大家也都很熟了，有幾個小細節可以提醒你：..是產生一個範圍，依種簡單的struct，如上例是{start: 0, end: 5}，","code":"while condition {\n  ...\n}\n\nloop {\n  ...\n}\n\nfor pattern in iterable {\n  ...\n}for i in 0..5 {\n  rprintln!(\"{}\", i);\n}"},{"path":"day5-運算式.html","id":"迴圈的流程控制","chapter":"6 Day5-運算式","heading":"6.3.1 迴圈的流程控制","text":"break只用在圍封迴圈中，不會用在match中，與其他程式稍有不同，它可以讓你跳出回圈，並且指定一個運算式給他，而這個運算式的值就是回傳值。continue則是會跳過這次迭代，繼續下一次迭代。你可以標記一個外部迴圈，讓break或continue可以直接穿越到標記的迴圈，標記的方法是在標記名稱前加上'，如'h、'search等。","code":"let x = [1, 2, 3, 4, 5];\nlet mut a:usize = 0;\n\nloop {\n  if a == 5 {\n    break rprint!(\"x被耗用了\\n\");\n  }else{\n    a = x[a];\n    rprint!(\"{}\\n\", a);\n  }\n}for number in 1..=10 {\n  if number % 2 == 0 {\n    continue;\n  }\n  rprintln!(\"{}\", number);\n}let x = [1, 2, 3, 4, 5];\n\nlet a = 'h : loop {\n  for i in 0..5 {\n    if x[i] == 3 {\n      break 'h i;\n    }else{\n      rprint!(\"{}\\n\", x[i]);\n    }\n  }\n};\n"},{"path":"day5-運算式.html","id":"函式呼叫與方法呼叫","chapter":"6 Day5-運算式","heading":"6.3.2 函式呼叫與方法呼叫","text":"在Rust裡，總共有3種呼叫形式，函式呼叫、方法呼叫、型態關聯函式呼叫。有一件奇怪的事情，那就是Rust在呼叫時，Vec<T>是無效的，你應該用::Vec，或是尤機器判斷回傳型態。","code":"let x = gcd(1302, 462); //函式呼叫\n\nlet room = player.location().ip(); //方法呼叫\n// 方法呼叫可以串連\n\nlet mut numbers = Vec::new(); //型態關聯函式呼叫return Vec<i32>::with_capacity(10);// 錯誤\nreturn Vec::<i32>::with_capacity(10);// 正確\nreturn Vec::with_capacity(10);// 正確"},{"path":"day5-運算式.html","id":"欄位與元素","chapter":"6 Day5-運算式","heading":"6.4 欄位與元素","text":".可以取出struct與tuple的元素，前者是以名字，後者是以數字[]可以操作陣列、向量、字串，取出元素。用..可以幫助你省略運算元，而..=則是包含運算元。","code":"game.player // struct\ncoords.0 // tuple\npices[0] // arraylet x = [1, 2, 3, 4, 5];\n\n// {start:a-1, end:b+1}從a到b\nlet s1 = &x[1..=2];\nrprintln!(\"{:?}\",s1);\n\n// {end:b+1}但包含b\nlet s2 = &x[..=2];\nrprintln!(\"{:?}\",s2);\n\n// 全部\nlet s3 = &x[..];\nrprintln!(\"{:?}\",s3);\n\n// {start:a}從a的後一個到最後\nlet s4 = &x[1..];\nrprintln!(\"{:?}\",s4);\n \n// {start:a, end:b}從a的後一個到b的前一個\nlet s5 = &x[1..4];\nrprintln!(\"s5 = {:?}\",s5);\n\n// {end:b}表示到b的前一個\nlet s6 = &x[..4];\nrprintln!(\"s6 = {:?}\",s6);\n"},{"path":"day06---錯誤.html","id":"day06---錯誤","chapter":"7 Day06 - 錯誤","heading":"7 Day06 - 錯誤","text":"Rust在錯誤處理的方式也很特別，因為錯誤處理本身不難，但有幾個新概念要注意Rust裡的錯誤分為panic與Result，一種是出於程式本身，不該發生的錯誤。另一個是本章的重點，處理無法控制問題的Result。(在這裡向各位致歉，錯誤處理本身很難用簡單的例子描述)","code":""},{"path":"day06---錯誤.html","id":"panic","chapter":"7 Day06 - 錯誤","heading":"7.1 Panic","text":"第一個要介紹的是Panic，由各種bug引起，最好的方法就是不要panic。但不可能不遇到錯誤，你也不必擔心，因為Rust的panic是安全的。下面以兩種panic會出現的狀況做介紹：回溯與中止。","code":""},{"path":"day06---錯誤.html","id":"回溯unwinding","chapter":"7 Day06 - 錯誤","heading":"7.1.1 回溯(unwinding)","text":"假設我們要設計一個程式，讓海盜分贓寶物。其中，船長先拿到所有的一半，剩下的由船員均分(小數部分給鸚鵡)基本上這麼簡單的程式很難錯誤，但當船員因為船難都死光，只剩船長歸來，Rust會告訴你：當這個panic發生時，會發生以下的事情：如果你依照建議回溯對疊，程式會將所有的區域變數、參數全部卸除：任何的Vec與String都會被釋放，打開的File會被關閉等等如果你依照建議回溯對疊，程式會將所有的區域變數、參數全部卸除：任何的Vec與String都會被釋放，打開的File會被關閉等等當清理完當前的函式呼叫，會前往上一層函式呼叫，沿著堆疊向上清除。當清理完當前的函式呼叫，會前往上一層函式呼叫，沿著堆疊向上清除。最後會退出整個執行緒，如果panic的是整個執行緒，那麽整個程式就會終止。最後會退出整個執行緒，如果panic的是整個執行緒，那麽整個程式就會終止。panic不是崩潰，而是一種安全機制，它的目的是在不安全發生前，將危險的堆疊回溯，但不影響其他程式執行。換句話說，除了主執行緒以外，其他執行緒的panic是各自發生，不互相影響。","code":"fn share(total:u64, crew_size:u64) -> u64 {\n  let half = total/2;\n  half/crew_size\n}\nrprintln!(\"The share for each crew member is {}\", share(100,3));\nthread '<unnamed>' panicked at src/lib.rs:7:3:\nattempt to divide by zero"},{"path":"day06---錯誤.html","id":"中止","chapter":"7 Day06 - 錯誤","heading":"7.1.2 中止","text":"堆疊回溯是panic預設的行為，但有兩種情況不會嘗試回溯堆疊：當Rust還在嘗試處理第一個panic，第二個panic由.drop()方法觸發，Rust會停止回溯，直接中止程式。當Rust還在嘗試處理第一個panic，第二個panic由.drop()方法觸發，Rust會停止回溯，直接中止程式。如果你主動用-C panic=abort參數編譯程式，Rust會直接中止程式，好處是可以減少編譯後的程序大小。如果你主動用-C panic=abort參數編譯程式，Rust會直接中止程式，好處是可以減少編譯後的程序大小。","code":""},{"path":"day06---錯誤.html","id":"result","chapter":"7 Day06 - 錯誤","heading":"7.2 Result","text":"Rust沒有例外(exception)，可能失敗函式要使用這種回傳型態：Result型態代表你準備好迎接失敗，當我們呼叫get_weather()函式時，成功的結果是Ok(WeatherReport)，失敗的結果是Err(io::Error)。","code":"fn get_weather(location:Lating) -> Result<WeatherReport, io::Error>"},{"path":"day06---錯誤.html","id":"捕捉錯誤","chapter":"7 Day06 - 錯誤","heading":"7.3 捕捉錯誤","text":"最直接的方法就是直接使用match:每次都要用match似乎有些繁複，所以Result<T, E>提供各種方法，這些方法都是用match實作：result.is_ok(), result.is_err()：\n回傳一個bool來表示result是成功的結果還是錯誤的result.is_ok(), result.is_err()：\n回傳一個bool來表示result是成功的結果還是錯誤的result.ok()：\n以Option回傳成功值，(T)或回傳None捨棄錯誤值result.ok()：\n以Option回傳成功值，(T)或回傳None捨棄錯誤值result.err()：\n以Option回傳錯誤值result.err()：\n以Option回傳錯誤值result.unwrap_or(fallback)：\n回傳成公值，否則回傳fallback，捨棄錯物值。最優秀的部分是，它可以在成功時直接拿到回傳值，而不是Option。result.unwrap_or(fallback)：\n回傳成公值，否則回傳fallback，捨棄錯物值。最優秀的部分是，它可以在成功時直接拿到回傳值，而不是Option。result.unwrap_or_else(fallback_fn)：\n與上面的例子相同，但它適合在計算fallback值很昂貴時，因為fallback_fn只有在錯誤時會計算。result.unwrap_or_else(fallback_fn)：\n與上面的例子相同，但它適合在計算fallback值很昂貴時，因為fallback_fn只有在錯誤時會計算。result.unwrap()：\n直接回傳成功值，如果是錯誤，直接panic。result.unwrap()：\n直接回傳成功值，如果是錯誤，直接panic。result.expect(msg)：\n與unwrap()相同，但可以自訂panic的訊息。result.expect(msg)：\n與unwrap()相同，但可以自訂panic的訊息。最後兩個是針對參考的方法，兩者都十分常用，因為除了.is_ok()與.is_err()，其他方法都會消耗Result<T, E>，所以你必須用參考來處理。result.as_ref()：\n將Result<T, E>轉換成Result<&T, &E>result.as_ref()：\n將Result<T, E>轉換成Result<&T, &E>result.as_mut()：\n將Result<T, E>轉換成Result<&mut T, &mut E>result.as_mut()：\n將Result<T, E>轉換成Result<&mut T, &mut E>","code":"match get_weather(location) {\n  Ok(report) => {\n    println!(\"The weather is {}\", report);\n  },\n  Err(e) => {\n    println!(\"Error: {}\", e);\n  }\n}"},{"path":"day06---錯誤.html","id":"打印錯誤","chapter":"7 Day06 - 錯誤","heading":"7.3.1 打印錯誤","text":"println!：所有的錯誤型態都可以用printn!這個宏來打印。如果你用{}，會打印出較短的錯誤訊息。而如果你用{:?}，會包括額外的技術錯誤訊息。err.to_string()：即以String形式回傳錯誤訊息","code":""},{"path":"day06---錯誤.html","id":"傳播錯誤","chapter":"7 Day06 - 錯誤","heading":"7.3.2 傳播錯誤","text":"?：你可以在產生Result的任何運算式後面加上?，而結果取決於成功或失敗成功：會打開result並取得裡面的成功值錯誤：會立刻從原函式return，沿著呼叫鏈往上回傳。?只能用於回傳Result的函式，如果你的函式回傳的是Option，你可以用ok_or或ok_or_else來轉換。","code":"fn get_weather(location:Lating) -> Result<WeatherReport, io::Error>\n\n//用?來處理，成功可以直接拿到WeatherReport\nlet weather = get_weather(location)?;\n\n// 相等的match\nmatch weather = get_weather(location) {\n  Ok(report) => {\n    println!(\"The weather is {}\", report);\n  },\n  Err(e) => {\n    return Err(e);\n  }\n}use std::fs;\nuse std::io;\nuse std::path::Path;\n\nfn move_all(src: &Path, dst: &Path) -> io::Result<()> {\n  rprintln!(\"Moving all files from {:?} to {:?}\", src, dst);\n  for entry_result in src.read_dir()? {  // 打開目錄可能發生錯誤\n    let entry = entry_result?;  // 讀取檔案可能發生錯誤\n    let dst_file = dst.join(entry.file_name());\n    fs::rename(entry.path(), dst_file)?; // 移動檔案可能發生錯誤\n  }\n  Ok(())\n}"},{"path":"day06---錯誤.html","id":"在main中處理錯誤","chapter":"7 Day06 - 錯誤","heading":"7.4 在main中處理錯誤","text":"?用來處理錯誤大多數情況被視為一個絕佳的方法，但在main函式中，因為回傳值不是Result，你不能用?最簡單的方式是用expect，若回傳錯誤訊息，程式會直接panic，這在小型的程式中非常常見。但expect所印出的訊息通常不夠詳細，這時候你可以修改main讓他回傳Result，這樣你就可以用?來處理錯誤。","code":"fn main() {\n  caculate().expect(\"calculation failed\");\n}fn main() -> Result<(), io::Error> {\n  caculate()?;\n  Ok(())\n}"},{"path":"day06---錯誤.html","id":"自訂錯誤型態","chapter":"7 Day06 - 錯誤","heading":"7.5 自訂錯誤型態","text":"來假設你要寫一個新的Json解析器，而且要用自己的錯誤型態：這個struct叫json::error::JsonError，它有三個欄位：message、line、column。當你想發出這個錯誤型態：但如果你想要讓他更標準，你還要：但這樣做真的太過繁瑣，你應該化繁為簡，crate就是為這種時刻而存在的。常用的有很多，例如thiserror、snafu、anyhow等等。","code":"# [derive(Debug, Clone)]\npub struct JsonError {\n  pub message: String,\n  pub line: usize,\n  pub column: usize,\n}return Err(JsonError {\n  message: \"Expected a colon\".to_string(),\n  line: current_line,\n  column: current_column,\n});use std::fmt;\n\nimpl fmt::Display for JsonError {\n  fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n    write!(f, \"{} ({}:{})\", self.message, self.line, self.column)\n  }\n}\n\nimpl std::error::Error for JsonError {}use thiserror::Error;\n#[derive(Error, Debug)]\n#[error(\"{message} ({line}:{column})\")]\npub struct JsonError {\n  pub message: String,\n  pub line: usize,\n  pub column: usize,\n}"},{"path":"day06---錯誤.html","id":"為何使用result","chapter":"7 Day06 - 錯誤","heading":"7.6 為何使用Result","text":"讀完整章之後，你大概有足夠的知識來了解為什麼Rust選擇用Result而不是例外：Rust嚴格要求你在可能出錯的地方做出某種選擇，讓你不會疏漏某塊重要的東西Rust嚴格要求你在可能出錯的地方做出某種選擇，讓你不會疏漏某塊重要的東西最常見的?，也就是傳播錯誤，在Rust裡是一見好事，因為你可以一目瞭然掌握錯誤發生的地方最常見的?，也就是傳播錯誤，在Rust裡是一見好事，因為你可以一目瞭然掌握錯誤發生的地方Result本身是一種資料型態，你可以在集合中儲存結果，例如你要載入上萬比資料，並且預期有少部分會失敗，用Result向量就可以很好的處理Result本身是一種資料型態，你可以在集合中儲存結果，例如你要載入上萬比資料，並且預期有少部分會失敗，用Result向量就可以很好的處理","code":""},{"path":"day07---crate與模組.html","id":"day07---crate與模組","chapter":"8 Day07 - crate與模組","heading":"8 Day07 - crate與模組","text":"","code":"mod library {\n    pub struct Book {\n        pub title: String,\n        author: String, // 默認是私有的\n    }\n\n    pub fn new_book(title: &str, author: &str) -> Book {\n        Book {\n            title: title.to_string(),\n            author: author.to_string(),\n        }\n    }\n}fn main() {\n    let book = library::new_book(\"The Rust Book\", \"Steve\");\n    println!(\"Title: {}\", book.title); // 可以訪問公開的字段\n    // println!(\"Author: {}\", book.author); // 無法訪問私有字段\n}public class Library {\n    // 定義內部的 Book 類別\n    public static class Book {\n        private String title;\n        private String author;\n\n        // 公開的構造函數\n        public Book(String title, String author) {\n            this.title = title;\n            this.author = author;\n        }\n\n        // 公開的 getter 方法\n        public String getTitle() {\n            return title;\n        }\n\n        // 私有的 getter 方法\n        private String getAuthor() {\n            return author;\n        }\n    }\n\n    // 創建新 Book 的靜態方法\n    public static Book newBook(String title, String author) {\n        return new Book(title, author);\n    }\n}public class Main {\n    public static void main(String[] args) {\n        Library.Book book = Library.newBook(\"The Rust Book\", \"Steve\");\n        System.out.println(\"Title: \" + book.getTitle());\n        // System.out.println(\"Author: \" + book.getAuthor()); // 無法訪問私有方法\n    }\n}"},{"path":"day07---crate與模組.html","id":"crate","chapter":"8 Day07 - crate與模組","heading":"8.1 crate","text":"Rust程式是由crate組成的，每一個crate都是一個單元，除了程式庫與可執行檔到原始碼，還有其他如範例、測試等東西，你很難避免使用第三方程式庫來組成一個運用良好的程式。我們再過去的專案中，提過用use宣告式來宣告我們需要的crate並且要在Cargo.toml中指定各版本的crate：dependencies代表這個專案需要的crate，當你執行cargo build時，Cargo會自動幫你下載這些crate，並且讀取crate的cargo.toml，下載這些crate，以此往復。在Cargo取得原始碼後，它會編譯所有的crate，這裡不是執行main()，而是產生一個.rlib檔，在編譯器讀取後，會將程式碼靜態地連結至最終的可執行檔內。","code":"use num::Complex;\nuse std ::str::FromStr;[dependencies]\nnum = \"0.4\"\nimage = \"0.13\"\ncrossbeam = \"0.8\""},{"path":"day07---crate與模組.html","id":"edtion","chapter":"8 Day07 - crate與模組","heading":"8.1.1 edtion","text":"Rust有極強的相容性保證，但程式的進化可能導致舊版與新版出現彼此爭議。例如，Rust決定將識別符號async與await改成關鍵字，這樣的改變可能破壞async或await當成變數的程式碼。因此在Cargo.toml中，你可以指定edition，這樣Cargo就會使用指定的edition來編譯程式碼。如果沒有指定，Cargo會使用預設的edition，目前是2015。","code":"\nedition = \"2018\""},{"path":"day07---crate與模組.html","id":"buid-profile","chapter":"8 Day07 - crate與模組","heading":"8.1.2 buid profile","text":"你可以加入一些動態設定來改變cargo的動態命令，通常你只要維持預設值，除了你想要profiler時，它可以測量你的程式在哪裡花費CPU時間。要同時啟動優化與debug，你要加入：","code":"[profile.release]\ndebug = true"},{"path":"day07---crate與模組.html","id":"模組","chapter":"8 Day07 - crate與模組","heading":"8.2 模組","text":"crate是在不同專案之間共用程式碼，而模組module與專案內的程式碼組織相關，以下是模組的範例：pub是共用的，意思是你可以在模組外呼叫它們。而pub(crate)是僅限模組內共用，它不能在其他模組呼叫。沒有pub的是私有的，只能在定義它的模組內使用。","code":"mod spores {\n  use cells::{Cell, Gene};\n  \n  \n  pub struct Spore{\n    ...\n  }\n  \n  pub fn produce_spore(factory: &mut SpoerFactory) -> Spore{\n    ...\n  }\n  \n  pub(crate) fn genes(spore: &Spore) -> Vec<Gene>{\n    ...\n  }\n  \n  fn recombine(parent: &mut Cell) {\n    ...\n  }\n  \n}"},{"path":"day07---crate與模組.html","id":"嵌套模組","chapter":"8 Day07 - crate與模組","heading":"8.2.1 嵌套模組","text":"嵌套模組的概念就是像俄羅斯娃娃般，在模組內放入模組：以上是錯誤的示範，因為你要確保包覆公開模組的模組也必須是公開的：這種模式雖然能讓你在單一檔案寫完所有程式，但這樣做容易讓程式碼難以維護。","code":"mod transport {\n  pub mod road {\n    ...\n  }\n  \n  pub mod rail {\n    ...\n  }\n}pub mod transport {\n  pub mod road {\n    pub mod car{\n      pub(in crate::transport::road) fn drive(){\n        ...\n      }\n    }\n    use car::drive;// 正確，在模組內\n  }\n  \n\n  pub mod rail {\n    use road::car::drive;//錯誤，不在模組內\n  }\n}"},{"path":"day07---crate與模組.html","id":"不同檔案","chapter":"8 Day07 - crate與模組","heading":"8.3 不同檔案","text":"第一，若只有一層模組，假設分為main.rs與spores.rs，你可以先在main.rs中宣告模組：接著，直接在spores.rs中寫入模組的函式、變數當你組建carte時，Rust看到mod spores時，會尋找spores.rs或spores/mod.rs，這樣就可以找到模組。若是模組中的模組，你可以為模組創建自己的資料夾，首先在main.rs宣告：我們一樣假設transport底下有三層：road、rail、sea，你要先在transport/mod.rs中宣告：若road底下還有car與bus，你可以在road/mod.rs中宣告：整個結構會像這樣：","code":"mod spores;pub struct Spore{\n  ...\n}\n\npub fn produce_spore(factory: &mut SpoerFactory) -> Spore{\n  ...\n}\n\npub(crate) fn genes(spore: &Spore) -> Vec<Gene>{\n  ...\n}\n\nfn recombine(parent: &mut Cell) {\n  ...\n}pub mod transport;pub mod road;\npub mod rail;\npub mod sea;pub mod car;\npub mod bus;.\n├── Cargo.toml\n└── src\n    ├── children.rs\n    ├── main.rs\n    └── road\n        ├── bus.rs\n        ├── car.rs\n        └── mod.rs"},{"path":"day07---crate與模組.html","id":"路徑與匯入","chapter":"8 Day07 - crate與模組","heading":"8.3.1 路徑與匯入","text":"::運算子讓你引用程式庫的功能，你可以直接寫出完整的引用，或已先將功能匯入模組再使用後者概念很簡單，就是把std::collections::HashMap用HashMap取代，這樣你就可以直接使用HashMap。你可以ㄧ次匯入多個、所有模組：模組不會自動繼承父模組的功能，例如在protiens/mod.rs：那麼，在proteins/synthesis.rs，你可能想在synthesis.rs中使用AminoAcid與Enzyme，你必須在synthesis.rs中匯入：如果你想在父輩模組用子模組的功能，依然要明確指出路徑相較於super關鍵字，crate是指包住當前模組的crate，這樣寫可以讓模組更具彈性，不會因為模組的位置而受限。有時候你的模組名稱與第三方crate名稱相同，當然你要盡量避免這件事，有兩種方法可以解決這件事，self與:::","code":"let mut map1 = std::collections::HashMap::new();\n\nuse std::collections::HashMap;\nlet mut map2 = HashMap::new();use std::collections::{HashMap, HashSet};// 一次匯入多個\nuse std::collections::*;// 匯入所有\nuse std::collections::HashMap as Map;// 別名\nuse std::fs::{self, File};// 匯入fs與File// proteins/mod.rs\npub enum AminoAcid {\n  ...\n}\n\npub mod enzymes {\n  pub struct Enzyme {\n    ...\n  }\n}// proteins/synthesis.rs\npub fn synthesize(seq: &[AminoAcid]) // 錯誤\n\nuse super::AminoAcid // 必須從父輩匯入// proteins/mod.rs\n\nuse synthesis::synthesize;// proteins/synthesis.rs\nuse crate::protiens::AminoAcid;\n\npub fn synthesize(seq: &[AminoAcid]) {\n  ...\n}use image::Pixels; //會與crate名稱衝突\n\nuse ::image::Pixels;\nuse self::image::Pixels;"},{"path":"day07---crate與模組.html","id":"pub的struct","chapter":"8 Day07 - crate與模組","heading":"8.3.2 pub的struct","text":"struct關鍵字在Rust相當常用，你可以在struct自訂的結構型態。ㄧ般的struct是私有的，你可以用pub讓它變成公開的：當struct是公開的，它的子輩與整個模組都可以使用它，這種透過模組控制存取其實是一種很好的設計模式，相較於Java或C++類別控制存取，減少了「getter」與「setter」的使用，以下附上範例","code":"pub struct Spore {\n  pub genes: Vec<Gene>,\n  pub age: u32\n}"},{"path":"day07---crate與模組.html","id":"rust-1","chapter":"8 Day07 - crate與模組","heading":"Rust","text":"","code":""},{"path":"day07---crate與模組.html","id":"library.rs","chapter":"8 Day07 - crate與模組","heading":"8.3.3 library.rs","text":"","code":"mod library {\n    pub struct Book {\n        pub title: String,\n        author: String, // 默認是私有的\n    }\n\n    pub fn new_book(title: &str, author: &str) -> Book {\n        Book {\n            title: title.to_string(),\n            author: author.to_string(),\n        }\n    }\n}"},{"path":"day07---crate與模組.html","id":"main.rs","chapter":"8 Day07 - crate與模組","heading":"8.3.4 main.rs","text":"","code":"fn main() {\n    let book = library::new_book(\"The Rust Book\", \"Steve\");\n    println!(\"Title: {}\", book.title); // 可以訪問公開的字段\n    // println!(\"Author: {}\", book.author); // 無法訪問私有字段\n}"},{"path":"day07---crate與模組.html","id":"java","chapter":"8 Day07 - crate與模組","heading":"Java","text":"","code":""},{"path":"day07---crate與模組.html","id":"library.java","chapter":"8 Day07 - crate與模組","heading":"8.3.5 Library.java","text":"","code":"public class Library {\n    // 定義內部的 Book 類別\n    public static class Book {\n        private String title;\n        private String author;\n\n        // 公開的構造函數\n        public Book(String title, String author) {\n            this.title = title;\n            this.author = author;\n        }\n\n        // 公開的 getter 方法\n        public String getTitle() {\n            return title;\n        }\n\n        // 私有的 getter 方法\n        private String getAuthor() {\n            return author;\n        }\n    }\n\n    // 創建新 Book 的靜態方法\n    public static Book newBook(String title, String author) {\n        return new Book(title, author);\n    }\n}"},{"path":"day07---crate與模組.html","id":"main.java","chapter":"8 Day07 - crate與模組","heading":"8.3.6 Main.java","text":"","code":"public class Main {\n    public static void main(String[] args) {\n        Library.Book book = Library.newBook(\"The Rust Book\", \"Steve\");\n        System.out.println(\"Title: \" + book.getTitle());\n        // System.out.println(\"Author: \" + book.getAuthor()); // 無法訪問私有方法\n    }\n}"},{"path":"day07---crate與模組.html","id":"將程式轉換成程式庫","chapter":"8 Day07 - crate與模組","heading":"8.4 將程式轉換成程式庫","text":"你一開始構想寫一個模擬蕨類生長的程式，你後來發現許多函式需要重複使用，你決定將程式轉換成一整個程式庫，先來看一下你的程式：先將main函式移出，我們等等再處理先將main函式移出，我們等等再處理把原檔名(main.rs)改成lib.rs把原檔名(main.rs)改成lib.rs接著，把函式改成pub，以便其他程式使用接著，把函式改成pub，以便其他程式使用這個程式庫算建立好了，如果你想在這個程式庫裡執行程式，你可以在src下再創一個bin目錄，並再下創一個rs檔，這裡以efern.rs為例：接著就可以用build建立程式庫，並聲明你要跑的程式：回顧一下整個結構：假如你想要在其他專案中使用程式庫，例如我們要在teer程式模擬，先在teer.toml中加入：記得要將fern_sim專案放入teer專案，其他都幾乎一樣，來看一下結構","code":"struct feather{\n  size: f64,\n  growth_rate: f64\n}\n\nimpl Fern {\n  /// 模擬生長過程\n  fn grow(&mut self){\n    self.size *= 1.0 + self.growth_rate;\n  }\n}\n\nfn run_simulation(fern: &mut Fern, days: usize){\n  for _ in 0..days{\n    fern.grow();\n  }\n}\n\nfn main() {\n  let mut fern = Fern {\n    size:1.0,\n    growth_rate: 0.001\n  };\n  run_simulation(&mut fern, 1000);\n  println!(\"final fern size: {}\", fern.size);\n}pub struct Fern {\n    pub size: f64,\n    pub growth_rate: f64\n  }\n\nimpl Fern {\n    /// 模擬生長過程\n    pub fn grow(&mut self){\n      self.size *= 1.0 + self.growth_rate;\n    }\n  }\n\npub fn run_simulation(fern: &mut Fern, days: usize){\n    for _ in 0..days{\n      fern.grow();\n    }\n  }// src/bin/efern.rs\nuse fern_sim::{Fern, run_simulation};\n\nfn main() {\n    let mut fern = Fern {\n        size: 1.0,\n        growth_rate: 0.001,\n    };\n    run_simulation(&mut fern, 1000);\n    println!(\"final fern size: {}\", fern.size);\n}cargo build --verbose\n\ncargo run --bin efern\n    Finished dev [unoptimized + debuginfo] target(s) in 0.00s\n     Running `target/debug/efern`\nfinal fern size: 2.7169239322355985├── Cargo.lock\n├── Cargo.toml\n└── src\n    ├── bin\n    │   └── efern.rs\n    └── lib.rs[dependencies]\nfern_sim = { path = \"../fern_sim\"}.\n├── Cargo.lock\n├── Cargo.toml\n├── fern_sim\n│   ├── Cargo.lock\n│   ├── Cargo.toml\n│   └── src\n│       ├── bin\n│       │   └── efern.rs\n│       └── lib.rs\n└── src\n    └── main.rs"},{"path":"day07---crate與模組.html","id":"屬性","chapter":"8 Day07 - crate與模組","heading":"8.5 屬性","text":"例如，你希望用非camelCase的變數名稱，你可以在變數前加上#[allow(non_camel_case_types)]，這樣Rust就不會報錯：還有常見的條件式編譯，也就是#[cfg]假如你想視情況讓程式顯示英文或中文，你可以先在主程式：接著在Cargo.toml中加入：這樣你就可以用cargo run來執行中文版本，或是cargo run --features english來執行英文版本。另外的例子是你想在不同平台發布：這裡就無需在Cargo.toml中加入任何東西，Rust會依據你的平台自動判斷。最後，如果你想讓整個屬性覆蓋到你整個crate，你可以在文件最上方加入#![...]","code":"#[allow(non_camel_case_types)]\npub struct HTTPResponse {\n  ...\n}fn main() {\n    hello();\n}\n\n#[cfg(not(feature = \"english\"))]\nfn hello() {\n    println!(\"你好，世界！\");\n}\n\n#[cfg(feature = \"english\")]\nfn hello() {\n    println!(\"Hello, world!\");\n}[features]\ndefault = []\nenglish = []fn main() {\n    platform_specific_function();\n}\n\n#[cfg(target_os = \"windows\")]\nfn platform_specific_function() {\n    println!(\"This is Windows!\");\n}\n\n#[cfg(not(target_os = \"windows\"))]\nfn platform_specific_function() {\n    println!(\"This is not Windows!\");\n}#![allow(dead_code)]\n\nfn main() {\n    let x = 5;\n    println!(\"x = {}\", x);\n}"},{"path":"day07---crate與模組.html","id":"測試","chapter":"8 Day07 - crate與模組","heading":"8.6 測試","text":"我們在過去就曾用#[test]來測試程式，只要有這個標籤，在cargo test時，Rust就會執行這個函式。假設你輸入cargo test math，Rust就會執行名稱有math的測試。在簡單的程式中，我們可以用assert!或assert_eq!來測試，但前兩者會被放入release build中，你可以改用debug_assert!或debug_assert_eq!，這樣只有在debug build中才會執行。","code":""},{"path":"day07---crate與模組.html","id":"整合測試","chapter":"8 Day07 - crate與模組","heading":"8.6.1 整合測試","text":"當你的程式庫建立好後，你可能會想將測試放到程式庫外。這時候你可以在src同一層的test目錄下創建一個rs檔，舉個例子：整合測試的價值是它可以像其他用戶看待你的程式庫，他們測試的是crate公開的API。cargo test會執行所有測試，包括整合測試，但你也可以用cargo test --test unfurl來執行單一測試。","code":"// test/unfurl.rs\n\nuse fern_sim::Terrarium;\nuse std::time::Duration;\n\n#[test]\nfn test_fiddlehead_unfurling() {\n    let mut t = Terrarium::new();\n    t.add_plant(\"fiddlehead\", 0.1, 0.01);\n    t.advance(Duration::from_secs(1));\n    assert_eq!(t.get_plant(\"fiddlehead\").unwrap().size, 0.11);\n}"},{"path":"day07---crate與模組.html","id":"文件","chapter":"8 Day07 - crate與模組","heading":"8.7 文件","text":"cargo doc的命令可以為你建立HTML文件，建立的文件會放在target/doc下：--open會自動開啟瀏覽器，---deps會只建立你的程式庫文件，不會建立依賴的文件。你可以在程式上，以///或[#doc=...]來寫註解，若想為整個模組寫註解，可以在模組前加上//!，這樣你的註解就會被放入文件中。你可以加入`#[doc(alias = “…”)]，來為搜尋引擎提供別名如果你像要在文件中加入外部文件，你可以用#![doc(include = \"filename\")]，這樣你的文件就會被加入。","code":"cargo doc --open --no-deps/// 建立並回傳一個[`VascularPath`]，代表\n/// 從[`Root`][r]到[`leaf`](leaves::Leaf)的路徑。\n///\n/// [r]: roots::Root\npub fn trace_path(leaf: &Leaf) -> VascularPath {\n    ...\n}"},{"path":"day07---crate與模組.html","id":"doc-test","chapter":"8 Day07 - crate與模組","heading":"8.7.1 doc test","text":"你可以在文件中加入程式碼區塊：它會被當成測試執行，而這種測試就很適合使用assert!或assert_eq!，這樣你就可以確保文件中的程式碼是正確的。如果你想要測試，但又想隱藏部分程式碼，你可以用#來隱藏：又或者你不想讓它變成測試的ㄧ部分，你可以用ignore或no_run，但no_run仍然會測試可不可以編譯：","code":"/// # Examples\n/// ```\n/// if samples::everything().works() {\n///     println!(\"all good!\");\n/// }\n/// ```/// # Examples\n/// ```\n/// # use samples::everything;\n/// if everything().works() {\n///    println!(\"all good!\");\n/// }\n/// ```/// # Examples\n/// ```no_run\n/// use samples::everything;\n/// if everything().works() {\n///    println!(\"all good!\");\n/// }\n/// ```"},{"path":"day07---crate與模組.html","id":"指定依賴項目","chapter":"8 Day07 - crate與模組","heading":"8.8 指定依賴項目","text":"首先，如果你想要依賴項目不是在crates.io上面發布的。對此，你可以從Git版本庫URL與revision來指定：另一種是指出存放crate原始碼的目錄：","code":"image = {git = \"...\", rev = \"...\"}\nimage = {path = \"../image\"}"},{"path":"day08---結構.html","id":"day08---結構","chapter":"9 Day08 - 結構","heading":"9 Day08 - 結構","text":"","code":""},{"path":"day08---結構.html","id":"具名欄位結構","chapter":"9 Day08 - 結構","heading":"9.1 具名欄位結構","text":"這段程式宣告一個GrayscaleMap結構，其具備兩個具體型態欄位，分別是pixels和size。根據慣例，Rust的型態名稱使用大寫字母，而欄位與方法則使用小寫字母。你可以用結構運算式來建立這個型態：結構運算式是GrayscaleMap{pixels, size}，因此你可以用同名的引數和區域變數來設定欄位：你可以用.來存取結構欄位：欄位也有公開與私有的概念，如果你只有將結構設為公開，則欄位仍是私有的：在這個情況下，其他模組可以使用這個結構與任何關聯函式，但無法用名稱來存取私用欄位，或使用結構與算式建立新的結構。這就是為什麼你不能用結構運算式來建立新的String或Vec，你必須使用String::new()或Vec::new()。..可以用來複製欄位，但要注意所有權的問題，我們用<>的例子說明：根據故事，有一位菜鳥魔法師，施法讓掃帚幫你忙工作，但他忘了怎麼讓它停下。即使將他切成兩半，它仍然不會停下：完成定義後，我們來看看結果如何：","code":"struct GrayscaleMap{\n  pixels: Vec<u8>,\n  size: (usize, usize)\n}let width = 1024;\nlet height = 576;\nlet image = GrayscaleMap{\n  pixels: vec![0; width * height],\n  size: (width, height)\n};struct GrayscaleMap{\n  pixels: Vec<u8>,\n  size: (usize, usize)\n}\n\n\nfn new_map(size: (usize, usize), pixels: Vec<u8>) -> GrayscaleMap{\n  assert_eq!(size.0 * size.1, pixels.len());\n  GrayscaleMap{pixels, size}\n}let image = new_map((1024, 576), vec![0; 1024 * 576]);\nassert_eq!(image.size, (1024, 576));pub struct GrayscaleMap{\n  pixels: Vec<u8>,\n  size: (usize, usize)\n}\nstruct Broom {\n  name: String,\n  height: u32,\n  health: u32,\n  position: (f32, f32, f32),\n  intent: BroomIntent\n}\n\n#[derive(Copy, Clone)]\nenum BroomIntent { FetchWater, DumpWater }\n\n// 參數取得Broom的所有權\nfn chop(b: Broom) -> (Broom, Broom) {\n  // 在這裡Broom除了name外，其他欄位都是複製\n  // 因此broom1取得b的name型態所有權\n  let mut broom1 = Broom { height: b.height / 2, ..b };\n  \n  // 我們想要掃帚2使用掃軸I的所有參數\n  // 但是name是String，所以必須複製一份\n  // 其他都可以直接複製\n  let mut broom2 = Broom { name: broom1.name.clone(), ..b};\n  \n  broom1.name.push_str(\" I\");\n  broom2.name.push_str(\" II\");\n  \n  (broom1, broom2)\n}let hokey = Broom {\n  name: \"Hokey\".to_string(),\n  height: 60,\n  health: 100,\n  position: (100.0, 200.0, 0.0),\n  intent: BroomIntent::FetchWater\n};\n\n\nlet (hokey1, hokey2) = chop(hokey);\nrprintln!(\"{} 的長度：{}\", hokey1.name, hokey1.height);\nrprintln!(\"{} 的長度：{}\", hokey2.name, hokey2.height);\n#> Hokey I 的長度：30\n#> Hokey II 的長度：60"},{"path":"day08---結構.html","id":"類tuple結構","chapter":"9 Day08 - 結構","heading":"9.2 類tuple結構","text":"第二種結構很類似tuple，事實上，它長相就是有名字的tuple，取值的方式與tuple一模ㄧ樣：它與具名結構在底層幾乎ㄧ樣，兩者之間的差別僅取於你想如何表達。例如你想讓程式更加清晰，使用具名欄位無可厚非。相較之下，若你通常使用模式比對來尋找元素，類tuple結構可能更適合。類tuple元素很適合來製作newtype，因為只有一個組件，不會有清晰度的問題，反之，當你需要對型態做嚴格檢查，用類tuple可以幫助你檢查問題與提供更多資訊。相較於Vec，Ascii型態更好表達它的用途。","code":"struct Bounds(usize, usize);\n\nlet image_bounds = Bounds(1024, 768);\n\nrprintln!(\"image bounds: {} x {}\", image_bounds.0, image_bounds.1);\n#> image bounds: 1024 x 768struct Ascii(Vec<u8>);"},{"path":"day08---結構.html","id":"impl定義方法","chapter":"9 Day08 - 結構","heading":"9.3 impl定義方法","text":"過去的範例中，我們曾經使用v.push(e)來將元素推入向量，用v.len()來取得長度…等等。你也可以為你的結構定義方法，但與Java和C++不同，Rust的方法寫在單獨的impl區塊中。在impl定義的函式叫做關聯函式，他們都會與行形態有關。相反，外部的函式叫自由函式。Rust會預設你的第一個參數是你呼叫參數的值，又稱self，self就是impl上面的型態，因此你可以省略型態寫法。有點類似Java與C++的this，但他們的this成員是unqualified identifer，可以直接看見，但Rust的方法必須明確以self稱呼，與Python和JavaScript的方法中使用this類似。再者，例子中因為pusn與pop方法都會修改Quene結構，所以都是以&mut self當作參數結構，但你在使用時無需寫出，Rust會私下處理，如：如果你不需要修改它，可以只接收共享參考你也可以直接要走所有權，就是直接寫self，有時候這樣還不夠，所以Rust允許你用聰明指標型態來傳遞self。","code":"pub struct Quene {\n  older: Vec<char>,\n  younger: Vec<char>\n}\n\n\nimpl Quene {\n  pub fn push(&mut self, c:char){\n    self.younger.push(c);\n  }\n  \n  pub fn pop(&mut self) -> Option<char> {\n    if self.older.is_empty(){\n      if self.younger.is_empty(){\n        return None;\n      }\n  \n      use std::mem::swap;\n      swap(&mut self.older, &mut self.younger);\n      self.older.reverse();\n    }\n    \n    self.older.pop()\n    \n  }\n  \n  \n}let mut q = Quene { older : Vec::new(), younger:: Vec::new() };\n\nq.push('0');\nq.push('1');\nassert_eq!(q.pop(), Some('0'));\n\nq.push('3');\nassert_eq!(q.pop(), some('1'));\nassert_eq!(q.pop(), some('3'));impl Quene {\n  pub fn is_empty(&self) -> bool {\n    self.older.is_empty() && self.younger.is_empty()\n  }\n}\n\nassert!(q.is_empty());"},{"path":"day08---結構.html","id":"用boxrc或arc傳遞self","chapter":"9 Day08 - 結構","heading":"9.4 用Box、Rc或Arc傳遞self","text":"如果需要的話，方法的self也可以使用Box<self>、Rc<self>或Arc<self>，一旦使用了，你只能對特定指標型態呼叫這種方法，呼叫方法會將指標的所有權傳給他。通常你不會用到這種作法，大多數時間你將聰明型態指標的self傳給參數為self、&self或& mut self都不太會有問題。但若真的需要這種指標當參數，你必須明確寫出self的型態，如同它是普通參數：","code":"\nimpl Node {\n  fn append_to(self: Rc<self>, parent: &mut Node) {\n    parent.children.push(self);\n  }\n}"},{"path":"day08---結構.html","id":"型態關聯函式","chapter":"9 Day08 - 結構","heading":"9.5 型態關聯函式","text":"型態關聯函式與上述不同的是，它不接受self引數函式，他們仍是函式，但不是方法：它們通常用來建構函式，如：","code":"impl Quene {\n  pub fn new() -> Queue {\n  Quene { older: Vec::new(), younger: Vec::new() }\n  }\n}\n\nfn main() {\n  let mut q = Queue::new()\n}"},{"path":"day08---結構.html","id":"關聯常數","chapter":"9 Day08 - 結構","heading":"9.6 關聯常數","text":"關聯常數是「與形態有關的值」，類似的概念來自C#與Java，顧名思義，他是ㄧ個常數，讀取他們的方法與關聯函式很像：關聯常數的型太也不必與相關型態相同，你可以利用這個特性，替型態加入ID或名稱，例如你有類似Vector2的型態需要寫入檔案並在稍後載入記憶體，你可以用關聯常數加入名稱與數字ID，寫在資料旁邊來指出它的型態：","code":"pub struct Vector2 {\n  x: f32,\n  y: f32,\n}\n\nimpl Vector2 {\n  const ZERO: Vector2 = Vector2 {x: 0.0, y: 0.0};\n  const UNIT: Vector2 = Vector2 {x: 1.0, y:0.0};\n}\n\nfn main{\n  let scaled = Vector2::UNIT.scaled_by(2.0);\n}impl Vector2 {\n  const NAME: &'static str = \"Vector2\";\n  const ID: u32 = 18;\n}"},{"path":"day08---結構.html","id":"泛型結構","chapter":"9 Day08 - 結構","heading":"9.7 泛型結構","text":"前面的Queue結構中，我們將它設定為專門處理字元的結構，但如果你想將這個結構普通到幾乎所有類型，你應該使用泛型結構：如此以來，你就不用每個型態都寫一遍結構，接著將impl改寫：注意到了嗎，我們將原本的pub fn new() -> Queue<T>改寫成pub fn new() -> Self，兩者沒有實際的區別，只是可以幫助你更好閱讀。在運作程式的部分，當結構是泛型，Rust會為你自動推動型態，你無需明確的指出，但若無法推斷，Rust就會強制你指定一種型態。","code":"pub struct Queue<T> {\n  older: Vec<T>,\n  younger: Vec<T>\n}\npub struct Queue<T> {\n  older: Vec<T>,\n  younger: Vec<T>\n}\n\nimpl<T> Queue<T> {\n  pub fn new() -> Self {\n    Queue { older: Vec::new(), younger: Vec::new() } \n  }\n  \n  pub fn push(&mut self, t:T){\n    self.younger.push(t);\n  }\n  \n  pub fn is_empty(&self) -> bool {\n    self.older.is_empty() && self.younger.is_empty()\n  }\n}\n#> NULLlet mut q1 = Queue {\n  older: Vec::new(), \n  younger: Vec::new()\n};\n\n// 也可以寫做：let mut q2 = Queue::<i32>::new();\nlet mut q2 = Queue::new();\n\nq2.push(2);\nq1.push(3);"},{"path":"day08---結構.html","id":"有常數參數的泛型結構","chapter":"9 Day08 - 結構","heading":"9.8 有常數參數的泛型結構","text":"常數也可以做結構的參數，參考下例：","code":"/// N-1度的多項式\nstruct Polynomial<const N: usize> {\n  /// 多項式的係數\n  ///\n  /// 多項式a+bx...\n  /// 多i個元素是...\n  cofficients: [f64; N]\n}"},{"path":"day08---結構.html","id":"為struct型態衍生trait","chapter":"9 Day08 - 結構","heading":"9.9 為struct型態衍生trait","text":"有的結構很容易寫，但隨之程式碼的擴展，你會發現用起來有點痛苦，因為它既不能複製(copy或clone)，也不能用print!(“{:?}”, point)印出來，也無法支援運算子比較。這些功能在Rust裡都有名稱：Copy、Clone、Debug與PatrialEq，他們叫做trait，再未來會講到如何親自撰寫trait，但一些標準的trait你不需要實作，只需加上#[derive]屬性即可當你貼上這些屬性，Rust會幫結構自動實作這些trait，前提是每個欄位都實用了該trait。例如，因為兩個欄位都是f64，而f64實作PpatrialEq，所以我們可以要求Rust也為Point衍生該trait。","code":"struct Point{\n  x: f64,\n  y: f64\n}#[derive(Copy, Clone, Debug, PartialEq)]\nstruct Point {\n  x: f64,\n  y: f64\n}"},{"path":"day09---enum與模式.html","id":"day09---enum與模式","chapter":"10 Day09 - enum與模式","heading":"10 Day09 - enum與模式","text":"","code":""},{"path":"day09---enum與模式.html","id":"enum","chapter":"10 Day09 - enum與模式","heading":"10.1 enum","text":"C風格的enum很簡單：它宣告有三種可能值的Ordering型態，enum的值稱為variant或costructor：Ordering::Less, Ordering::Equal, Ordering::Greater。它是標準程式庫的一部分，你可以直接匯入他或是匯入constructor，匯入constroctur可以讓你簡寫，但一般來說不匯入constructor是比較好的習慣enum結構也可以擁有方法：","code":"Ordering {\n    Less,\n    Equal,\n    Greater,\n}use std::cmp::Ordering;\n\nfn compare(n: i32, m: i32) -> Ordering {\n    if n < m { Ordering::Less }\n    else if n > m { Ordering::Greater }\n    else { Ordering::Equal }\n}use std::cmp::Ordering::{Less, Greater, Equal};\n\nfn compare(n: i32, m: i32) -> Ordering {\n    if n < m { Less }\n    else if n > m { Greater }\n    else { Equal }\n}#[derive (Copy, Clone, Debug, PartialEq)]\nenum TimeUnit {\n  Seconds, Minutes, Hours, Days, Months, Years\n}\n\nimpl TimeUnit {\n  fn plural(self) -> &'static str {\n    match self {\n      TimeUnit::Seconds => \"seconds\",\n      TimeUnit::Minutes => \"minutes\",\n      TimeUnit::Days => \"days\",\n      TimeUnit::Months => \"months\"\n    }\n  }\n  \n  fn singular(self) -> &'static str {\n    self.plural().trim_end_matches('s')\n  }\n}"},{"path":"day09---enum與模式.html","id":"含資料的enum","chapter":"10 Day09 - enum與模式","heading":"10.2 含資料的enum","text":"有些時候你不需要完整的時間，提供粗略的時間更方便用戶，例如「兩個月之前」，你可以寫一個enum實現：這個enum的其中兩個variant(InThePast, InTheFuture)可以接受參數，而以tuple接受接受參數的varint稱為tuple variant：第二種是strut variant，有具名欄位：","code":"#[derive (Copy, Clone, Debug, PartialEq)]\nenum RoughTime {\n  InThePast(TimeUnit, u32)\n  JustNow\n  InTheFuture(TimeUnit, u32)\n}let four_score_and_seven_years_ago = RoughTime::InThePast(TimeUnit::Year, 87);\nlet three_days_from_now = RoughTime::InTheFuture(TimeUnit::Day, 3);enum Shape {\n  Sphere {center: Point3d, radius: f32},\n  Cuboid { center1:Point3d, corner2: Point3d},\n}\n\nlet unit_sphere = Shape::Sphere {\n  center: ORIGIN,\n  radius: 1.0,\n};"},{"path":"day09---enum與模式.html","id":"泛型enum","chapter":"10 Day09 - enum與模式","heading":"10.3 泛型enum","text":"enum可以寫成泛型，在標準程式庫有兩個我們的老朋友我們都知道泛型可以為你節省多少功夫，以下例子為你講解BinaryTree型態與它的運作模式：BinaryTree的值有兩種可能，Empty或NoneEmpty，前者代表沒有沒有資料，後者則有一個Box指標，指向heap上的TreeNode。而每一個TreeNode又各有一個實際元素與兩個BinaryTree值。這代表可以形成一個無限伸展的樹狀結構。這個就是節點的概念，上例的Alan_tree為父節點，會擁有Alan_son_tree與Alan_daughter的所有權。本章的後面會展示怎麼進一步為BinaryTree型態實作與加入方法。這樣的結構需要時間熟悉，尤其是一開始不確定要把Box放在哪，你可能要事先規劃你的記憶體配置，熟悉這種結構能讓你自己控制記憶體的使用。接下來我們要來談enum的代價，那就是Rust不會不顧風險的試著存取欄位，不管有沒有值，只能透過模式來取得內部資料。","code":"enum Option<T> {\n    Some(T),\n    None,\n}\n\nenum Result<T, E> {\n    Ok(T),\n    Err(E),\n}enum BinaryTree<T> {\n  Empty,\n  NoneEmpty(Box<TreeNode<T>>),\n}\n\nstruct TreeNode<T> {\n  element: T,\n  left: BinaryTree<T>,\n  right: BinaryTree<T>\n}\n#> NULLuse BinaryTree::*;\nlet Alan_tree = NoneEmpty(Box::new(TreeNode {\n  element: \"Alan\",\n  left: Empty,\n  right: Empty\n}));\n\nlet Alan_son_tree = NoneEmpty(Box::new(TreeNode {\n  element: \"Alan_son\",\n  left: Empty,\n  right: Empty\n}));\n\nlet Alan_daughter_tree = NoneEmpty(Box::new(TreeNode {\n  element: \"Alan_daughter\",\n  left: Empty,\n  right: Empty\n}));\n\nlet Alan_tree = NoneEmpty(Box::new(TreeNode {\n  element: \"Alan\",\n  left: Alan_son_tree,\n  right: Alan_daughter_tree\n}));"},{"path":"day09---enum與模式.html","id":"模式","chapter":"10 Day09 - enum與模式","heading":"10.4 模式","text":"複習一下上面的RoughTime型態定義：match常用來為模式進行比對，在這個例子中，模式就是=>前面的部分。當模式使用units與count這種代號時，變成模式後面的區域變數。值裡面的東西會被複製或移到新變數內。假設你想進一步更正語法錯誤，你可以再加入其他分支，如：要注意將這個修正放在InTheFutrue(unit, count)之前，因為符合RoughTime::InTheFutrue(unit, 1)都會符合此項，Rust會給你一個unreachable pattern的警告。模式比對與enum合作無間，這也是match強大之處，而模式的功能遠不止次，參見下表","code":"fn enough_time_english(rt: RoughTime) -> String {\n  match rt {\n    RoughTime::InThePast(units, count) =>\n      format!(\"{} {} ago\",count, units.plural()),\n    RoughTime::JustNow => \n      format!(\"juat now\"),\n    RoughTime::InTheFuture(units, count) =>\n      format!(\"{} {} from now\", count, units.plural())\n  }\n}RoughTime::InTheFutrue(unit, 1) =>\n  format!(\"a {} from now\", unit.singular())"},{"path":"day09---enum與模式.html","id":"常值變數與萬用模式","chapter":"10 Day09 - enum與模式","heading":"10.5 常值、變數與萬用模式","text":"n代表區域變數，可以適用任何值，符合它的值會被移動或複製到新的區域變數，在這個例子裡，meadow.count_rabbits() 在超過一隻的情況下或被存入新區域變數n並印出。不只數字，包括布林、字元，甚至字串。下例的other與上例的n相同，可以匹配與其他不符合的值，稱為全包模式萬用模式可以匹配任何值，不同之處在，它不會將儲存到任何地方，僅作為你的備用處理","code":"match meadow.count_rabbits() {\n  0 => {},\n  1 => println!(\"A rabit is nosing around in the clover\"),\n  n => println!(\"there are {} rabbits hopping about in the meadow\", n),\n}let calendar = match settings.get_string(\"calendar\") {\n  \"gregorian\" => Calendar::Gregorian,\n  \"chinese\" => Calender::Chinese,\n  \"ethiopian\" => Calendar::Ethiopian,\n  other => return parse_error(\"calendar, other\"),\n};pub fn bmr_caculate(&self) -> Result<f64, ()>  {\n      let age = self.age as f64;\n      match self.gender {\n        'M' => Ok(10.0 * self.weight + 6.25 * self.height - 5.0 * age + 5.0),\n        'F' => Ok(10.0 * self.weight + 6.25 * self.height - 5.0 * age - 161.0),\n        _ => Err(())\n      }\n    }"},{"path":"day09---enum與模式.html","id":"tuple與結構模式","chapter":"10 Day09 - enum與模式","heading":"10.6 tuple與結構模式","text":"tuple模式就是比對tuple，在你需要處理多項資料時使用：結構模式使用大括號，很像結構運算式，比對每個欄位的子模式：Point{ x: x, y: y}容易造成誤認，你可以簡寫成Point{ x, y}，它仍然可以辨識x與y會是下面的新變數。有時候即使使用縮寫，如果我們只在乎一兩個欄位，程式會很冗長：為了避免這種狀況，你可以使用..來告訴Rust其餘部分你不在乎：","code":"pub fn compare_pinot(x: i32, y: i32) -> &'static str {\n  use std::cmp::Ordering::*;\n  match (x.cmp(&0), y.cmp(&0)) {\n    (Equal, Equal) => on the origin\" ,\n    (_, Equal) => \"on the x axis\",\n    (Equal, _) => \"on the y axis\",\n    (Greater, Greater) => \"in the first quadrant\",\n    (Less, Greater) => \"in the second quadrant\"\n  }\n}match balloon.location {\n  Point { x:0, y: height} => \n    println!(\"straight up {} meters\", height),\n  Point {x:x, y:y} =>\n    println!(\"at ({}m, {}m)\", x, y),\n}match get_account(id) {\n  ...,\n  Some(Account {\n    name, language,\n    id:_, status: _, adddress: _,birth: _,eye_color: _,\n    pet: _, security_question: _}) =>\n     \n  })\n}match get_accuount(id) {\n  ...,\n  Some(Account{ name, language, ...}) =>\n    language.show_custom_greeting(name),\n}"},{"path":"day09---enum與模式.html","id":"陣列與slice模式","chapter":"10 Day09 - enum與模式","heading":"10.7 陣列與slice模式","text":"陣列模式可以篩選特殊的值，特別是陣列的不同位置有不同意義的時後以下例子中，你想將色調、飽和度、亮度(HSL)顏色值轉換成了紅藍綠，亮度為零或最大值就是黑色或白色，我們可以輕鬆用match運算式來處這些例子：slice模式又與陣列相似，但sliceq長度可變，因此會比對長度，在slice模式中，..會比對任何運算：","code":"fn hsl_to_rgb(hsl: [u8; 3]) -> [u8; 3] {\n  match hsl {\n    [_, _, 0] => [0, 0, 0],\n    [_, _, 255] => [255, 255, 255],\n    ...\n  }\n}fn greet_people(names: &[&str]) {\n  match names {\n    [] => { println!(\"沒人在嗎\")}\n    [a] => { println!(\"你好{}\",a)},\n    [a, b] => { println!(\"你好，{}和{}\", a, b)}\n    [a, .., b] => { println!(\"哈囉 {}到{}\", a, b)}\n  } \n}"},{"path":"day09---enum與模式.html","id":"參考模式","chapter":"10 Day09 - enum與模式","heading":"10.8 參考模式","text":"Rust模式有兩種處理參考的模式。ref會借用部分匹配值，&則會比對參考匹配不可複製的值(非Copy)會移動該值，如下例中，在比對accuont.name與account.language會被移入區域變數name與language中，其餘不分會被卸除，因此不能借用它的參考。","code":"match account {\n  Account { name, language, .. } => {\n    ui.greet(&name, &language);\n    ui.show_settings(&account); //錯誤account已被移動\n  }\n}let mut x = 1;\nlet y = &mut x;\n*y = 2;\nrprintln!(\"{}\",x);\n\n#> 2"},{"path":"day10-tarit與泛型.html","id":"day10-tarit與泛型","chapter":"11 Day10-tarit與泛型","heading":"11 Day10-tarit與泛型","text":"","code":""},{"path":"day10-tarit與泛型.html","id":"使用trait","chapter":"11 Day10-tarit與泛型","heading":"11.1 使用trait","text":"Ruat是ㄧ種型態語言，你使用程式庫的標準型態或自訂型態，再為他們寫種方法。而trait代表一種功能，是型態可做的事，如：實作std::iter::Iterator的值能產生一系列值實作std::iter::Iterator的值能產生一系列值實作std::clone::Clone的值可以在記體裡面製作副本實作std::clone::Clone的值可以在記體裡面製作副本實作std::fmt::Debug可以用println!()與{:?}印出實作std::fmt::Debug可以用println!()與{:?}印出以上三種都是trait都是Rust標準庫的一部分，許多標準型態都實作了他們Range(0..10的型態)實作了Iterator trait，還有slice、Hashmap等Range(0..10的型態)實作了Iterator trait，還有slice、Hashmap等大多數的標準程式庫型態都實作了Clone，沒有實作的可能代表與記憶體資料無關大多數的標準程式庫型態都實作了Clone，沒有實作的可能代表與記憶體資料無關同樣的、大多數的標準程式庫型態都支援Debug同樣的、大多數的標準程式庫型態都支援Debugtrait方法必須在作用域內，否則你無法使用它的方法：編譯器會請你加入`use std::io::Write;。加入後可以修復這個問題。","code":"let mut buf: Vec<u8> = vec![];\nbuf.write_all(b\"hello\")?; //找不到write_aLL方法use std::io::Write;\n\nlet mut buf: Vec<u8> = vec![];\nbuf.write_all(b\"hello\")?;"},{"path":"day11-closure.html","id":"day11-closure","chapter":"12 Day11-closure","heading":"12 Day11-closure","text":"排序整數向量十分容易：但並非所有需要排序的資料都是向量，例如結構，你就無法使用sort方法，你可能需要指定方法sort_by_key會把參數cites丟給函式，在收集函式吐出來的資料做排序，這個key指的是sort接受key函式。因此你可以用更簡潔的方式處裡，匿名函式closureclosure的引數是city，回傳-city.population，系統會根據使用的方法來推斷引數的型態以及回傳型態","code":"\nintegers.sort();// 依人口數遞減排列\nstruct City {\n  name: String,\n  population: i64,\n  country: String,\n  ...\n}\n\nfn city_population_descending(cities: &mut Vec<City>) {\n  cities.sort_by_key(city_population_descending);\n}\n\nfn sort_cities(cities: &mut Vec<City>) {\n  cites.sort_by_key(city_population_descending);\n}fn sort_cities(cities: &mut Vec<City>){\n  cites.sort_by_key(|citiy| -city.population)\n}"},{"path":"day11-closure.html","id":"抓變數","chapter":"12 Day11-closure","heading":"12.1 抓變數","text":"closure可以使用包著它的函式的參數，例如下例，這個closure的使用stat，可以視為「捕捉capture到stat，但基於對生命週期的掌控，沒有垃圾回收的Rust使用closure抓變數使有限制的。","code":"fn sort_cities(cities: &mut Vec<City>, stat: Statistic){\n  cites.sort_by_key(|citiy| -city.get_statistic(stat));\n}"},{"path":"day11-closure.html","id":"借用的closure","chapter":"12 Day11-closure","heading":"12.1.1 借用的closure","text":"回顧上例，一般的closure使用參數時，會自動借用參考，並且這個行為符合過去所說的生命規則，closure使用stat參考，不能超過stat的生命週期。而此例closure在排序後消滅，沒有問題。這樣的做法既確保安全性，並且比垃圾回收的速度快，等等會詳細說明。","code":""},{"path":"day11-closure.html","id":"盜用的closure","chapter":"12 Day11-closure","heading":"12.1.2 盜用的closure","text":"thread::swpan會開啟新的執行緒，完全獨立於主要的執行緒，它接受一個closure。因此在這段程式中，有一些新的生命週期問題closure_fn會借用stat的參考，但新執行緒有自己的生命週期，即使仍在同一個函式中，無法確認stat的生命週期有超過。換句話說，當stat的參考被放入key_fn，再放入行執行緒中，無法判斷新執行緒與start_sorting_thread的執行(此函式執行結束stat會被耗用)哪個先結束。同樣的，我們也無法確認cities有被安全的共享，因此，我們應該是要將兩者盜用steal，而不是借用參考：我們要告訴Rust我們要移入stat與cities，只要在前面加上move關鍵字。第一個key_fn我們要取得stat的所有權，第二個thread::spwan我們要key_fn與cities的所有權。","code":"use std::thread;\n\nfn start_sorting_thread(mut cities: Vec<City>, stat: Statistic) \n-> thread::JoinHandle<Vec<City>>\n{\n    let key_fn = |city &City| -> i64 { -city.get_statistic(stat)};\n    \n    thread::spawn(|| {\n      cities.sort_by_key(key_fn);\n      cities\n    })\n    \n    \n}fn start_sorting_thread(mut cities: Vec<City>, stat: Statistic) \n-> thread::JoinHandle<Vec<City>>\n{\n    let key_fn = move |city &City| -> i64 { -city.get_statistic(stat)};\n    \n    thread::spawn(move || {\n      cities.sort_by_key(key_fn);\n      cities\n    })\n    \n    \n}"},{"path":"day11-closure.html","id":"closure性能","chapter":"12 Day11-closure","heading":"12.2 closure性能","text":"Rust的closure最大優點就是一個字：快多數程式語言會將closure放置在heap中，並且以函式般動態指派與垃圾回收處理，進而導致佔用cpu的時間在建立、呼叫與收集。而Rust，第一不需要垃圾回收，第二它不會被配置在heap中，除非你將他們放在Box、Vec或其他容器中。第三因為每個closure都”有特定的型態，因此可以藉由內連技術(讓closure直接插入調用點而不是動態呼叫)，讓你在緊密的回圈中也可以使用closure。()案例中，我們用closure找出既有taco又有tornado的程式，在記憶體內，就像一個小型結構，有它使用的變數參考注意，裡面沒有指向它的程式碼的指標，而是以型態來判斷呼叫的程式(b)同上例，只是以move來容納值，而不是參考。(c)不使用任何周遭環境變數，closure不佔用任何記憶體closure除了使用的參考或值之外，不會佔用記憶體，且加上內連的技術，連這張圖的簡的結構也可以優化。","code":""},{"path":"day11-closure.html","id":"closure安全性","chapter":"12 Day11-closure","heading":"12.3 Closure安全性","text":"雖然預設的情況是借用參考，但有些狀況下，closure會根據你所使用的方式決定是否移動該值，也就是即使不使用move，仍有可能封包行為必須獲取參數的所有權回歸到本質，會有獲取參考、所有權與可變參考，以trait的角度看：","code":"trait Fn() -> R {\n  fn call(&self) -> R;\n}\n\ntrait FnMut() -> R {\n  fn call_mut(&mut self) -> R;\n}\n\ntrait FnOnce -> R {\n  fn call_once(self) -> R;\n}"},{"path":"day11-closure.html","id":"fnonce","chapter":"12 Day11-closure","heading":"12.3.1 FnOnce","text":"FnOnce的概念是，因為耗用所有權，所以他們不能使用第二次dict 的所有權：當你在閉包中使用 dict 時，閉包試圖將 dict 的所有權轉移到閉包內部。這是因為你在閉包內部的 迴圈嘗試使用 dict，這種情況下 Rust 必須捕獲 dict 的所有權，因為它需要在閉包的執行過程中擁有 dict。dict 的所有權：當你在閉包中使用 dict 時，閉包試圖將 dict 的所有權轉移到閉包內部。這是因為你在閉包內部的 迴圈嘗試使用 dict，這種情況下 Rust 必須捕獲 dict 的所有權，因為它需要在閉包的執行過程中擁有 dict。無法重複使用：由於閉包捕獲了 dict 的所有權，dict 在第一次執行閉包時會被移動，這導致 dict 在閉包第一次調用後就不再有效。因此，你不能再次調用閉包，因為 dict 已經被移動了。無法重複使用：由於閉包捕獲了 dict 的所有權，dict 在第一次執行閉包時會被移動，這導致 dict 在閉包第一次調用後就不再有效。因此，你不能再次調用閉包，因為 dict 已經被移動了。要修正這樣的bug，就是使debug_dump_dict()變成Fn()，捕獲參考","code":"let dict = produce_glossary();\nlet debug_dump_dict = || {\n  for (key, value) in dict {\n    println!(\"{:?} - {:?}, key , value\");\n  }\n};\n\ndebug_dump_dict()\ndebug_dump_dict() //dict會被耗用let dict = produce_glossary();\nlet debug_dump_dict = || {\n    for (key, value) in &dict {  // 捕獲 dict 的不可變引用\n        println!(\"{:?} - {:?}\", key, value);\n    }\n};"},{"path":"day11-closure.html","id":"fnmut","chapter":"12 Day11-closure","heading":"12.3.2 FnMut","text":"共用包含mut資料的非mut closure是不安全的，因為讓多個執行緒同時呼叫時會有資料爭用的問題，尤其是同時對同一筆資料讀取和寫入時。因此，Rust的第三種closure是FnMut，又稱寫入closure，需要以mut的方式操作值(如寫入、修改)都會自動被判定為FnMut如果是有參數的閉包，你必須手動在前面加上mut：","code":"let mut i = 0;\nlet incr = || {\n  i += 1;\n  println!(\"Ding i is now\", i);\n}let i_plus_x = |x| { i += x;};// 錯誤\n\nlet mut i_plus_x = |x| { i += x;}; //正確\n\ni_plus_x(0);"},{"path":"day11-closure.html","id":"關係","chapter":"12 Day11-closure","heading":"12.3.3 關係","text":"如果我們想將寫一個函式來重覆使用兩次closure：它絕對不能放入FnOnce，因為FnOnce必定會卸除原本參數的值，那如果是放入FnMut呢？重新檢視一下call_twice，它的參數是where F: Fn()，我們所提供的事FnMut，因此有告訴call_twice我們要給的是FnMut!總結來說，closure類型分三種，並且三個是由於對閉包值處理性質不同，而有嚴格成度不一的結構：","code":"fn call_twice<F>(closure: F) where F: Fn() {\n  closure();\n  closure();\n};\nlet mut i = 1;\n\nlet i_plus_one = || { i += 1;};\n\ncall_twice(i_plus_one);// 錯誤！fn call_twice<F>(mut closure: F) where F: FnMut() {\n  closure();\n  closure();\n};\n\nlet mut i = 1;\n\nlet i_plus_one = || { i += 1;};\n\ncall_twice(i_plus_one);\nrprintln!(\"i = {}\", 1);\n#> i = 1"},{"path":"day11-closure.html","id":"closure的copy與clone","chapter":"12 Day11-closure","heading":"12.3.4 closure的Copy與Clone","text":"Rust將closure視為一種結構，裡面有它捕捉的值(對move)或值的參考(非move)。因此，它遵從一般結構的概念，以它內部行為來決定型態是Copy或Clone。不改變變數，僅保存共想參考的，因為共享參考既是Copy也是Clone，那個CLosure也是如此。相反，可變參考既不是Copy，也不是Clone，使用它的closure也不是。對於move closure，決定於move的值是哪種：clone()(...)看起來是很奇怪的語法，它其實只是代表我們複製closure，然後呼叫clone。在greet這個closure中，它內部有greeting的所有權。當你複製他們時，裡面的greeting也會被複製1份，因此每個函式的greeting都是自己擁有的。","code":"\nlet mut y = 10;\nlet add_y = |x|y+x; //僅借用y的參考與x的Copy\nlet copy_of_add_y = add_y; // 因此add_y也是Copy\nrprintln!(\"{}\",add_y(copy_of_add_y(22))); // add_y不會被耗用\n\n#> 42\n#> NULLlet mut i = 0;\nlet mut i_add_x = |x| i +=x; //要改變i的值，因此是FnMut\nlet copy_of_i_add_x = i_add_x; // i_add_x會移入，進而變成未宣告\nrprintln!(\"{}\",i_add_x(copy_of_i_add_x(1))); // 錯誤，i_add_x被移動let mut greeting = String::from(\"Hello, \");\nlet greet = move |name| {\n  greeting.push_str(name);\n  rprintln!(\"{}\", greeting);\n};\n\ngreet.clone()(\"Alan\");\ngreet.clone()(\"Blan\");\n#> Hello, Alan\n#> Hello, Blan"},{"path":"day11-closure.html","id":"回呼","chapter":"12 Day11-closure","heading":"12.4 回呼","text":"許多程式庫的API都使用回呼，呼回是由用戶提供函式，讓程式褲呼叫。路由器的概念是將網際網路傳來的請求傳給處理請求的Rust程式碼，在這個例子中，網際網路傳來/get請求時，傳遞給post_gcd處理，因此可以換成交由一個closur處理。這是因為actix-web接受任何執行緒安全的Fn引數。要如何在自己的程式這樣做？我們試著從零開始寫一個簡單的路由器，我們先宣告一些代表HTTP請求與回應的型態：目前，路由器的工作只是儲存一個將URL對映到回呼的表，按需求回應到正確的回呼但這樣做犯了致命的錯誤，我們宣告每一個BasicRouter都有一個回呼形態C，而所有HshMap都要是相同型態的回呼，這導致當你處理第二條路徑時，編譯器告訴你傳入的closure與預期的不同型態。我們想要支援各種型態，替代的方案是使用box與trait物件每一個box都可以容納不同型態的closure，所以一個HashMap可以容納各種回呼在add_route的簽章中，C有兩個bound：有一個Fn trait，以及一個’static生命期。如果沒有static生命期，呼叫Box:new(callbak)會是一個錯誤，因為當closure所借用的變數參考離開作用域，那麼整個closue將不再安全。接下來這個路由器就可以處理傳來的請求：如果要寫一個更節省空間但彈性較小的程式，試著用指標函式取代儲存trait物件，這些型態與closure的作用很像。函式指標的適用與不捕捉任何東西的closure完全相同，都不需要保存被捕捉變數的任何資訊。如果你適當使用，無論在binding或是函式簽章中，都可以讓程式簡潔。以下是以函式指標的路由表：看起來簡潔多了，沒有Box，也沒有動態配置，只有HashMap本身。這側面展示的訊息是，Closure本身就是一個獨特的型態，基於它所捕捉的變數不同，因此也需要較複雜的更動。或是在情況許可下，犧牲彈性，寫出如上面例子般，接收函式指標與不抓東西的closure。","code":"async fn get_index() -> HttpResponse {\n    HttpResponse::Ok()\n        .content_type(\"text/html\")\n        .body(\n            \"<meta charset=\"UTF-8\">\n             <title>猜猜數字<\/title>...\",)\n}\n\n\nApp::new()\n    .route(\"/\", web::get().to(get_index))\n    .route(\"/gcd\", web::post().to(post_gcd))\n    App::new()\n    .route(\"/\", web::get().to(||{\n      HttpResponse::Ok()\n          .content_type(\"text/html\")\n          .body(\"<title>GCD Caculator<\/title>...\")\n    }))\n    .route(\"/gcd\", web::post().to(|form: web::Form<GcdParameters>|{\n      HttpResponse::Ok()\n        .content_type(\"text/html\")\n        .body(format!(\"The Gcd of {} and {} is {}.\",\n                      form.n, form.m, gcd(form.n, form.m)))\n    }))struct Request {\n  method: String,\n  url: String,\n  headers: HashMap<String, String>,\n  body: Vec<u8>\n}\n\nstruct Response {\n  code: u32,\n  headers: HashMap<String, String>,\n  body: Vec<u8>\n}struct BasicRouter<C> where C: Fn(&Request) -> Response {\n  routes: HashMap<String, C>\n}\n\nimpl<C> BasicRouter<C> Where C: Fn(&Request) -> Response {\n  /// 建立空白路由器\n  fn new() -> BasicRouter<C> {\n    BasicRouter { routes: Hashmap::new() }\n  }\n  \n  fn add_route(&mut self, url: &str, callback: C) {\n    self.routes().insert(url.to_string(), callback);\n  }\n}let mut router = BasicRouter::new();\nrouter.add_route(\"/\", |_| get_form_response()); //編譯正確\nrouter.add_route(\"/gcd\", |req| get_gcd_response(req)); //錯誤type BoxedCallback = Box<dyn Fn(&Request) -> Response>;\n\nstruct BasicRouter {\n  routes: HashMap<String, BoxedCallback>\n}impl BasicRouter {\n  fn new() -> BasicRouter {\n      BasicRouter { routes: HashMap::new() }\n  }\n  \n  fn add_route<C>(&mut self, url: &str, callback: C)\n    where C: Fn(&Request) -> Response + 'static\n    {\n      self.routes.insert(url.to_string(), Box::new(callback));\n    }\n}impl BasicRouter {\n  fn handle_request(&self, request: &Request) -> Response {\n    match self.routes.get(&request,url) {\n      None => not_found_response(),\n      Some(callback) => callback(request)\n    }\n  }\n}fn add_ten(x: u32) -> u32 {\n  x + 10\n}\n\nlet fn_ptr: fn(u32) -> u32 = add_ten;\nlet eleven = fn_ptr(1);\nrprintln!(\"{}\", eleven);\n#> 11strut FnPoniterRouter {\n  routes: HashMap<String, fn(&Request) -> Response>\n}\n\nimpl FnPoniterRouter {\n  fn new() -> FnPoniterRouter {\n    FnPointerRouter { routes: HashMap::new() }\n  }\n  \n  fn add_route(&mut self, url: &str, callback:fn(&Request) -> Response)\n  {\n    self.routes.insert(url.to_string, callback);\n  }\n}"},{"path":"day12-iterator.html","id":"day12-iterator","chapter":"13 Day12-Iterator","heading":"13 Day12-Iterator","text":"iterator 就是實作了std::iter::Iterator trait的任何值Item 是iterator產生的值的型態。next方法會回傳Some(v)，v是iterator的下一個值，當序列結束，會回傳None。如果某個型態可以用自然的方式迭代，你可以為那個型態實作std::iter::IntoIterator，他的into_iter方法會接受一個值，並回傳它的iterator：Rust的for迴圈就是如此整合上面的元素，假設你要迭代一個向量印出他們：在底層，for迴圈其實就是呼叫IntoIterator與Iterator方法的簡寫而已我們來了解一下iterator的術語：之前說過，iterator是實作了Iterator的任何型態之前說過，iterator是實作了Iterator的任何型態iterable是可以實作Interator的任何型態。iterable是可以實作Interator的任何型態。iterator會產生值iterator會產生值iterator產生的值稱為項目(item)。在此，項目是””、“b”、“c”iterator產生的值稱為項目(item)。在此，項目是””、“b”、“c”接受iterator產生的值的項目是consumer，在上面例子，for迴圈是consumer接受iterator產生的值的項目是consumer，在上面例子，for迴圈是consumer","code":"trait Iterator {\n  type Item;\n  fn next(&mut self) -> Option<Self::Item>;\n  ...// 許多其他方法\n}trait IntoIterator where Self::IntoIter: Iterator<Item=Self::Item> {\n  typ Item;\n  type IntoIter: Iterator;\n  fn into_iter(self) -> Self::IntoIter;\n}println!(\"There's:\");\nlet v = vec![\"a\", \"b\", \"c\"];\n\nfor element in &v {\n  println!(\"{}\", element);\n}let mut iterator = (&v).into_iter();\nwhile let Some(element) = iterator.next {\n  println!(\"{}\", element);\n}"},{"path":"day12-iterator.html","id":"建立iterator","chapter":"13 Day12-Iterator","heading":"13.1 建立Iterator","text":"","code":""},{"path":"day12-iterator.html","id":"iter與iter_mut方法","chapter":"13 Day12-Iterator","heading":"13.1.1 iter與iter_mut方法","text":"大多數的集合型態都提供iter與iter_mut方法，這些方法會回傳迭代該型態的iterator，可產生每一個項目的共享或可變參考。&[T]與&mut [T]這種陣列slice也有iter與iter_mut方法，如果不用for迴圈，以下是最常用來取得iterator方法：每個型態實作的iter與iter_mut後的iterator可能有些不同，例如std::path::Path的iter方法回傳一個iterator，它每次會回傳一個路徑組件，這些項目型態是&std::ffi::OsStor。如果某種型態迭代不只一種，那種型態通常為各種遍歷方式提供轉數的方法，例如&str字串就沒有iter方法，而是有s.bytes()與s.chars()來取代。","code":"let v = vec![1,2,3,4,5];\nlet mut iterator = v.iter();\nrprintln!(\"{:?}\", iterator.next());\nrprintln!(\"{:?}\", iterator.next());\nrprintln!(\"{:?}\", iterator.next());\nrprintln!(\"{:?}\", iterator.next());\nrprintln!(\"{:?}\", iterator.next());\nrprintln!(\"{:?}\", iterator.next());\n#> Some(1)\n#> Some(2)\n#> Some(3)\n#> Some(4)\n#> Some(5)\n#> Noneuse std::ffi::OsStr;\nuse std::path::Path;\n\nlet path = Path::new(\"C:/User/JimB/Dowloads/Fedora.iso\");\nlet mut iterator = path.iter();\nrprintln!(\"{:?}\", iterator.next());\nrprintln!(\"{:?}\", iterator.next());\nrprintln!(\"{:?}\", iterator.next());\n#> Some(\"C:\")\n#> Some(\"User\")\n#> Some(\"JimB\")"},{"path":"day12-iterator.html","id":"intoiterator","chapter":"13 Day12-Iterator","heading":"13.1.2 IntoIterator","text":"如果型態實作了IntoIterator，你可以自己呼叫它的into_iter方法，就像for迴圈的做法不同狀況的iterator會產生不同的item，來處理共享參考(&T)、可變參考(&mut T)與移動(T)：當into_iter接收集合的共享參考後，它會回傳一個iterator，這個iterator會產生項目的共享參考。例如，上面的程式中，(&favorite).into_iter()會回傳一個iterator，它的Item型態是&String當into_iter接收集合的共享參考後，它會回傳一個iterator，這個iterator會產生項目的共享參考。例如，上面的程式中，(&favorite).into_iter()會回傳一個iterator，它的Item型態是&String當into_iter收到集合的可變參考後，它會回傳一個iterator，這個iterator會產生項目的可變參考。例如，如果vector是Vec，那麽呼叫(&mut vector).into_iter()會回傳一個iterator，它的Item型態是&mut String當into_iter收到集合的可變參考後，它會回傳一個iterator，這個iterator會產生項目的可變參考。例如，如果vector是Vec，那麽呼叫(&mut vector).into_iter()會回傳一個iterator，它的Item型態是&mut String當into_iter以值收到集合後，into_iter會回傳一個iterator，該iterator擁有集合的所有權，並以值回傳項目；項目的所有權會從集合移交給耗用者，原始的集合在過程中會被耗用。例如上述的程式中呼叫favorites.into_iter()會回傳一個iterator，它會以值產生每個字串，耗用者將每一個字串的所有權。當iterator被卸除時，在BTreeSet裡面剩餘的任何元素也會被卸除，然後集合的空殼也會被丟棄。當into_iter以值收到集合後，into_iter會回傳一個iterator，該iterator擁有集合的所有權，並以值回傳項目；項目的所有權會從集合移交給耗用者，原始的集合在過程中會被耗用。例如上述的程式中呼叫favorites.into_iter()會回傳一個iterator，它會以值產生每個字串，耗用者將每一個字串的所有權。當iterator被卸除時，在BTreeSet裡面剩餘的任何元素也會被卸除，然後集合的空殼也會被丟棄。也並非每一個型態都會實作三種情況，例如HashSet、BTreeSet與BinaryHeap未實作處理可變參考的Iterator，因為修改本身會違反型態的不可變性：如修改過後產生不同的雜湊值，或與臨值的排列不同。而有些僅部分可變，如HashMap產生的項目值的可變參考，但只有索引鍵是共享參考。slice本身不擁有它的元素，所以不能以值參考，只實作共享參考與可變參考另外，favorites.iter()與(&favorites).into_iter()都是以共享參考作為迭代，但前者更加簡潔與易懂IntoIterator在泛型程式也很有用，使用T: IntoIterator來將型態變數T限制為可以迭代的型態。進一步可以用T: IntoIterator<Item=U> 來要求迭代特並型態U。","code":"use std::collections::BTreeSet;\nlet mut favorites = BTreeSet::new();\nfavorites.insert(\"Lucky in the Sky With Diamonds\".to_string());\nfavorites.insert(\"Liebestraume No. 3\".to_string());\n\nlet mut it = favorites.into_iter();\nrprintln!(\"{:?}\", it.next());\nrprintln!(\"{:?}\", it.next());\nrprintln!(\"{:?}\", it.next());\n#> Some(\"Liebestraume No. 3\")\n#> Some(\"Lucky in the Sky With Diamonds\")\n#> Noneuse std::fmt::Debug;\n\nfn dump<T, U>(t: T)\n    where T: IntoIterator<Item=U>,\n    U: debug\n{\n  for u in t {\n    println!(\"{:?}\", u);\n  }\n}"},{"path":"day12-iterator.html","id":"form_fn-與-successors","chapter":"13 Day12-Iterator","heading":"13.2 form_fn 與 successors","text":"若要產生一系列的值，一種簡單的方式是提供一個回傳他們的closure。當std::iter::form_fn接受一個回傳Option<T>的closure，並回傳iterator不停呼叫這個函式來產生值，搭配take()函式可以限制產生的數字。如果每個項目依賴前一個項目，std::iter::successors函式可以很好的運作successors接受兩個參數，1是初始值，2是一個回傳值的closure。第一次迭代中，closure的參數是初始值(上例中的start)，隨後回傳值(回傳Some(start+2))。第二次迭代，closure的參數是上一次迭代的值(上例中的start+2)…form_fn與successor兩者都可以接受FnMut closure，用來捕捉作用域的變數並修改它。例如，這個fibonacci函式使用一個move closure來捕捉變數，並將它當成它的運作狀態來使用from_fn與successor方法很靈活，幾乎可以用在所有iterator的地方，來讓你的程式更簡潔與，但它們相較於常用模式，較難說明資料如何在計算過程中移動。","code":"use rand::random;\nuse std::iter::form_fn;\n\n// 產生1000個隨機線段的長度\n// 會在[0,1]區間內產生值\nlet lengths: Vec<f64> =\n    form_fn(|| Some((random::<f64>() - random::<f64>()).abs()))\n    .take(1000)\n    .collect();use std::iter::successors;\n\nlet start = 1;\n\nlet mut iter = successors(Some(start), |&x| Some(x+2) );\n\nfor _ in 0..5 {\n  if let Some(val) = iter.next() {\n    rprintln!(\"{}\", val);\n  }\n}\n#> 1\n#> 3\n#> 5\n#> 7\n#> 9\n#> NULLuse std::iter::from_fn;\n\nfn fibonacci() -> impl Iterator<Item=usize> {\n  let mut state = (0,1);\n  std::iter::from_fn(move || {\n    state = (state.1, state.0 + state.1);\n    Some(state.0)\n  })\n}\n\nlet mut x = fibonacci().take(0);\nfor _ in 0..8 {\n  if let Some(val) = x.next() {\n    rprintln!(\"{}\", val);\n  }\n}\n#> NULL"},{"path":"day12-iterator.html","id":"darin方法","chapter":"13 Day12-Iterator","heading":"13.2.1 darin方法","text":"如果型態可以用範圍檢索，例如String、向量與VecDeque，drain方法可以擷取範圍內的item。","code":"\nlet mut outer = \"Rust\".to_string();\nlet inner = String::from_iter(outer.drain(1..3));\n\nrprintln!(\"outer：{}\", outer);\nrprintln!(\"inner：{}\", inner);\n#> outer：Rt\n#> inner：us"},{"path":"day12-iterator.html","id":"iterator改造方法","chapter":"13 Day12-Iterator","heading":"13.3 Iterator改造方法","text":"關於Iterator有兩個重點：1.對著iterator呼叫adapter不會耗用任何值，而是回傳一個新iterator以下這段程式不會印出任何值：程式會警告你：note: iterators lazy nothing unless consumed。iter()方法會回傳ㄧ個迭代陣列元素吧iterator，接著map會回傳第二個iterator，但沒人呼叫鍵索取值，也就是完全沒有人呼叫next()來讓這個iterator工作。2.iterator是抽象零成本的。如map、filter都是泛型，所以執行它們時，當對著iterator執行它們時，Rust會根據參與其中的iterator類型量身打造程式碼，因此它有足夠的資訊將各個iterator的next方法內連至它的耗用者裡面，然後將整個安排視為一個單位，翻譯成機器碼，讓它與你親自撰寫函式來過濾執行ㄧ樣高效。","code":"[\"Java\", \"Rust\", \"css\", \"R\"]\n  .iter().map(|elt| println!(\"{}\", elt));"},{"path":"day12-iterator.html","id":"map與filter","chapter":"13 Day12-Iterator","heading":"13.3.1 map與filter","text":"map adapter可對iterator的項目執行一個closure，filter adpater則可從iterator篩選項目，用closure來決定保留項目。假設你要迭代多行文字，並省略每一行的空格與結尾，使用map來呼叫trim方法就非常適合map完的iterator還可以繼續改造，假如你想過濾有Java的字串，你可以使用filter：iterator的adapter的寫法很容易閱讀，每一個adapter都有一個目的，並且有續的把改造結果往下傳這些adpater的簽章：map iterator將每個項目以值傳給他的closure，並依序將closure產生的結果的所有權交給它的耗用者。filter iterator以共享參考傳給它的closure，因此有時在使用filter要注意解參考，如：filter(|s| *s != QQ);參數型是&&str，要解參考後才能直接比較。","code":"let text = \"hello, RUST!\\n 妳好，羅斯特\\n Java is better\\n QQ\".to_string();\n\nlet v: Vec<&str> = text.lines()\n    .map(str::trim)\n    .collect();\n    \nfor word in v {\n  rprintln!(\"{}\", word);\n}\n#> hello, RUST!\n#> 妳好，羅斯特\n#> Java is better\n#> QQ\n#> NULLlet text = \"hello, RUST!\\n 妳好，羅斯特\\n Java is better\\n QQ\".to_string();\n\nlet v: Vec<&str> = text.lines()\n    .map(str::trim)\n    .filter(|s| !s.contains(\"Java\"))\n    .collect();\n    \nfor word in v {\n  rprintln!(\"{}\", word);\n}\n#> hello, RUST!\n#> 妳好，羅斯特\n#> QQ\n#> NULLfn map<B, F>(self, f:F) -> impl Iterator<Item=B>\n  where Self: Sized, F: FnMut(Self::Item) -> B;\n\nfn filter<P>(self, predicate: P) -> impl Iterator<Item=Self::Item>\n    where Self: Sized, P: FnMut(&Self::Item) -> bool;"},{"path":"day12-iterator.html","id":"filter_map與fat_map","chapter":"13 Day12-Iterator","heading":"13.3.2 filter_map與fat_map","text":"map adapter最適合處理每一個項目都要產生下一個項目，而filter adapter適合回傳零或ㄧ個目，但如果以想將項目一次轉換成一個或多個項目呢？或是想刪除某個項目而不處理呢？filter_map就如語意上的使用方式，就是map+filter，它可以讓vlosure轉換成新項目或選擇卸除，以下是它的簽章：這個簽章與mapㄧ樣，但它回傳的是Option，而不是B。當closure回傳None時，項目會卸除值，當它回傳Some(b)時，b是filter_map iterator產生的下一個項目。例如，我們要從字串提取數字，必須先以空格分開後，找出單詞後卸除無法解析的詞：當filter_map的closure試著使用f64::from_str來解析各個以空白分開的slice，並回傳Result<f64, ParseFloatError>，它的.ok()會轉換成Option：解析錯誤會變成None，而成功的解析則是Some(v)而flat_map則是可以回傳不只一個項目或零個，而是任意數量的項目，它的簽章如此：傳給flat_map的closure必須回傳一個iterable，但任何形式的iterable都可以。","code":"fn filter_map<B, F>(self, f: F) -> impl Iterator<Item=B>\n    where Self: Sized, F: FnMut(Self::Item) -> Option<B>;use std::str::FromStr;\n\nlet text = \"11\\n found .25 289 \\n 3.1415 kkday\\n\";\n\nlet numbers: Vec<f64> = text.split_whitespace()\n    .filter_map(|t| f64::from_str(t).ok())\n    .collect();\n    \nrprintln!(\"{:?}\", numbers);\n    \n#> [11.0, 0.25, 289.0, 3.1415]fn flat_map<U, F>(self, f:F) -> impl Iterator<Item=U::Item>\n   where F: FnMut(Self::Item) -> U, U: IntoIterator;use std::collections::HashMap;\n\nlet mut major_cities = HashMap::new();\nmajor_cities.insert (\"Japan\", vec! [\"Tokyo\", \"Kyoto\"]);\nmajor_cities.insert(\"TheUnitedStates\", vec![\"Portland\",\"Nashville\"]);\nmajor_cities.insert(\"Brazil\", vec! [\"São Paulo\",\"Brasilia\"]);\nmajor_cities.insert(\"Kenya\", vec! [\"Nairobi\",\"Mombasa\" ]);\n\nlet countries = [\"Japan\", \"Brazil\", \"Kenya\"];\n\nfor &city in countries.iter().flat_map(|country| &major_cities[country]) {\n  rprintln!(\"{}\", city);\n}\n#> Tokyo\n#> Kyoto\n#> São Paulo\n#> Brasilia\n#> Nairobi\n#> Mombasa\n#> NULL"},{"path":"day12-iterator.html","id":"flatten","chapter":"13 Day12-Iterator","heading":"13.3.3 flatten","text":"flatten adapter會串接iterator的項目，將數個項目輾平成單層，回傳一個傳遞所有元素的iteratorflatten的簽章是長這樣的：換句話說，上一層的iterator必須實作IntoIterator，並且再沒有呼叫next的耗用者出現部會運作。flatten除了輾平雙層結構，有幾個神奇的運作方式，例如你有一個Vec<Option<…>>，而你只想迭代Some值，用一個簡單的flatten就可以做到這件事。flatten+map的組合很常見，將元素是iterator的集合先以map方法執行某個函式(closure)，之後用flatten來將iterator輾平取出元素，參考下面這段程式：要用這種組合技的原因是to::uppercase()不是回傳一個字元，而是回傳一個iterator，可產生ㄧ個或多個字元，flatten負責接受這些iterator，把他們輾平拼接成一個String。但不要忘了我們才剛介紹過的flat_map，事實上，它完全可以更輕鬆快速地做到這件事：","code":"use std::collections::HashMap;\n\nlet mut transportions = HashMap::new();\ntransportions.insert(\"陸地\", vec![\"火車\",\"公車\"]);\ntransportions.insert(\"海上\", vec![\"渡輪\", \"獨木舟\"]);\ntransportions.insert(\"空中\", vec![\"客機\", \"直升機\"]);\n\nlet all_transportions:Vec<_> = transportions.values().flatten().collect();\n\nfor transportion in &all_transportions {\n  rprintln!(\"{}\", transportion);\n}\n#> 火車\n#> 公車\n#> 客機\n#> 直升機\n#> 渡輪\n#> 獨木舟\n#> NULLfn flatten(self) -> impl Iterator<Item=Self::Item::Item>\n   when Self::Item: IntoIterator;let x = vec![None, Some(\"a\"), None, Some(\"b\")]\n        .into_iter()\n        .flatten()\n        .collect::<Vec<_>>();\n        \nfor item_x in x {\n  rprintln!(\"{:?}\", item_x);\n}\n\n#> \"a\"\n#> \"b\"\n#> NULLfn to_uppercase(&self) -> Sring {\n  self.chars()\n      .map(char::to_uppercase)\n      .flatten()\n      .collect()\n}fn to_uppercase(&self) -> Sring {\n  self.chars()\n      .flat_map(char::to_uppercase)\n      .collect()\n}"},{"path":"day12-iterator.html","id":"take與-take_while","chapter":"13 Day12-Iterator","heading":"13.3.4 take與 take_while","text":"你可以用這兩個方法告訴你的Iterator什麼時候結束迭代，在某個數量或某種情況，它們的簽章是：它們接受一個iterator的所有權，同時回傳一個新的iterator。take iterator會在產生最多n個項目後回傳None。take_while會對每個項目執行predicate，並在回傳第一個讓predicate回傳flase的地方回傳None。例如，如果有一封email中間與標題正文之間有空行，使用take_while來迭代標題：我們在過去說過，字串裡面的一行文字結尾是反斜線時，Rust不會加入下一排的縮排，所以字串的每一行的開頭都沒有空格。這意味訊息第三行是空的，take_while 在看到空行時立即終止迭代，只會印出前兩行","code":"fn take(self, n: usize) -> impl Iterator<Item=Self::Item>\n    where Self: Sized;\n\nfn take_while<P>(self, predicate: P) -> impl Iterator<Item=Self::Item>\n   where Self: Sized, P: FnMut(&Self::Item) -> bool;let message = \"To Tom\\r\\n\\\n              From: Bling<whoareyouman0.4@gmail.com>\\r\\n\\\n              \\r\\n\\\n              Did you get any writting done today?\\r\\n\n              when will you stop wasting time?\\r\\n\";\n\nfor headers in message.lines().take_while(|l| !l.is_empty()) {\n  rprintln!(\"{}\", headers);\n}\n#> To Tom\n#> From: Bling<whoareyouman0.4@gmail.com>\n#> NULL"},{"path":"day12-iterator.html","id":"skip與skip_while","chapter":"13 Day12-Iterator","heading":"13.3.5 skip與skip_while","text":"Iterator trait的skip與skip_while方法是take與take_while的相反：它們在迭代開始時卸出某個數量的項目，或是一直卸除項目，直到closure找到可接受時為止，將剩餘項目包在iterator傳出如果你知道要從哪裡開始，你可以用skip來指定要跳過的項目數：這是迭代命令引數，我們用skip跳過第一個命令(第一個字串是程式本身的名稱)take_while可以讓你決定在什麼狀況停止取值，skip_while則是在什麼狀況下開始取值：","code":"fn skip(self, n: usize) -> impl Iterator<Item=Self::Item>\n    where Self: Sized;\n\nfn slkip_while<P>(self, predicate: P) -> impl Iterator<Item=Self::Item>\n    where Self: Sized, P: FnMut(&Self::Item) -> boolfor arg in std::env::args().skip(1) {\n  ...\n}let message = \"To Tom\\r\\n\\\n              From: Bling<whoareyouman0.4@gmail.com>\\r\\n\\\n              \\r\\n\\\n              Did you get any writting done today?\\r\\n\n              when will you stop wasting time?\\r\\n\";\n\n\nfor body in message.lines().skip_while(|l| !l.is_empty()).skip(1) {\n  rprintln!(\"{}\", body);\n}\n#> Did you get any writting done today?\n#> \n#>               when will you stop wasting time?\n#> NULL"},{"path":"day12-iterator.html","id":"peekable","chapter":"13 Day12-Iterator","heading":"13.3.6 peekable","text":"peekable可以讓你偷看一下項目，而不實際耗用：這裡的Peekable實作了Iterator<Item=Self::Item>的結構，屬於一種iterator型態Peekable iterator有一個額外的peek方法，它會回傳一個Option<&Item>，","code":"fn peekable(self) -> std::iter::Peekable<Self>\n    where Self: Sized;"},{"path":"day12-iterator.html","id":"fuse","chapter":"13 Day12-Iterator","heading":"13.3.7 fuse","text":"Iterator在回傳None之後，trait並未規定再次呼叫它的next方法時該怎麼辦。大多數的iterator都會直接回傳None，當並非全都如此。fuse adapter接受任何iterator，並產生一個iterator，那個iterator會在第一次回傳None之後，繼續回傳None。因為Flaky的next方法會在true與false之間循環，導致並非item清空後不停回完None，如果你需要這樣的特性，fuse可以為你校正這件事。","code":"struct Flaky(bool);\n\nimpl Iterator for Flaky {\n  type Item = &'static str;\n  fn next(&mut self) -> Option<Self::Item> {\n    if self.0 {\n      self.0 = false;\n      Some(\"totally the last item)\n    }else{\n      self.0 = true; // 注意個行為\n      None\n    }\n  }\n}\n\nlet mut flaky = Flaky(true);\nrprintln!(\"{}\" ,flaky.next());\nrprintln!(\"{}\" ,flaky.next());\nrprintln!(\"{}\" ,flaky.next());\n\nlet mut flaky = Flaky(true).fuse();\nrprintln!(\"{}\" ,flaky.next());\nrprintln!(\"{}\" ,flaky.next());\nrprintln!(\"{}\" ,flaky.next());"},{"path":"day12-iterator.html","id":"可逆的iterator與rev","chapter":"13 Day12-Iterator","heading":"13.3.8 可逆的iterator與rev","text":"在有序的集合中，你可能會想從兩頭取出項目，只要實作std::iter::DoubleEndedIterator，它的簽章是：它繼承iterator，並有一個next_back方法，用來取出末端的值如果iterator是雙端的，你可以用rev adapter將它倒過來，它的簽章是：它回傳的iterator也是雙端，因爲它顛倒整個顛倒整個序列：","code":"trait DoubleEndedIterator: Iterator {\n  fn next_back(&mut self) -> Option<Self::item>;\n}let mut fruit = [\"apple\", \"banana\", \"grape\"];\nlet mut iter = fruit.into_iter();\n\nrprintln!(\"{:?}\", iter.next_back());\nrprintln!(\"{:?}\", iter.next_back());\n#> Some(\"grape\")\n#> Some(\"banana\")fn rev(self) -> impl Iterator<Item=Self>\n    where Self: Sized + DoubleEndedIterator;let mut fruit = [\"apple\", \"banana\", \"grape\"];\nlet mut iter = fruit.into_iter().rev();\nrprintln!(\"{:?}\", iter);\nrprintln!(\"{:?}\", iter.next());\n\n#> Rev { iter: IntoIter([\"apple\", \"banana\", \"grape\"]) }\n#> Some(\"grape\")"},{"path":"day12-iterator.html","id":"inspect","chapter":"13 Day12-Iterator","heading":"13.3.9 inspect","text":"inspect adapter可對iterator adapter進行流水線的偵錯，它僅將項目的共享參考傳給closure，不會影響項目，這適合拿來印出項目與製作它們斷言。在這個例子中，將一個字串轉換成大寫","code":"let uppercase: String = \"james\".chars()\n    .inspect(|c| rprint!(\"before : {:?}\\n\", c ))\n    .flat_map(char::to_uppercase)\n    .inspect(|c| rprint!(\"after :     {:?}\\n\", c ))\n    .collect();\nrprintln!(\"{}\", uppercase);\n#> before : 'j'\n#> after :     'J'\n#> before : 'a'\n#> after :     'A'\n#> before : 'm'\n#> after :     'M'\n#> before : 'e'\n#> after :     'E'\n#> before : 's'\n#> after :     'S'\n#> JAMES"},{"path":"day12-iterator.html","id":"chain","chapter":"13 Day12-Iterator","heading":"13.3.10 chain","text":"chain adapter可以將iterator附加至另一個iterator。更準確的說，i1.chain(i2)會回傳一個iterator，該iterator會從i1取出項目，耗盡之後再從i2取出項目，它的簽章是如此：換句話說，你可以將一個iterator與產生同一型態項目的任何iterable串接起來：","code":"fn chain<U>(self, other: U) -> impl Iterator<Item=Self::Item>\n    where Self: Sized, U: Intoiterator<Item=Self::Item>;let v: Vec<i32> = (1..4).chain([20, 30, 40]).collect();\nrprintln!(\"{:?}\", v);\n#> [1, 2, 3, 20, 30, 40]"},{"path":"day12-iterator.html","id":"enumerate","chapter":"13 Day12-Iterator","heading":"13.3.11 enumerate","text":"enumerate adapter可將ㄧ個運行索引附加至序列，如”apple”, “banana”, “grape”為item的iterator附加後回傳(0, “apple”)、(1, “banna”)、(2, “grape”)","code":"let mut fruit = [\"apple\", \"banana\", \"grape\"];\nfor (i, name) in fruit.into_iter().enumerate() {\n  rprintln!(\"i: {}, name: {}\", i, name);\n}\n#> i: 0, name: apple\n#> i: 1, name: banana\n#> i: 2, name: grape\n#> NULL"},{"path":"day12-iterator.html","id":"zip","chapter":"13 Day12-Iterator","heading":"13.3.12 zip","text":"zip adapter可以將兩個iterator結合成一個，但不是串接，而是類似enumerate產生一對值，例如下面例子中，我們將無界限的0..與另一個iterator來產生與enumerate adapter的效果：你可以把zip視為更廣義的enumerate，enumerate在可協助提供處理項目資訊時使用，zip可以附加任何東西，不需要是iterator，可以是iterable","code":"let mut fruit = [\"apple\", \"banana\", \"grape\"];\nlet mut iter: Vec<_> = (0..).zip(fruit).collect();\nfor (i, name) in fruit.into_iter().enumerate() {\n  rprintln!(\"i: {}, name: {}\", i, name);\n}\n#> i: 0, name: apple\n#> i: 1, name: banana\n#> i: 2, name: grape\n#> NULLuse std::iter::repeat;\n\nlet transportions = vec![\"car\", \"bus\", \"MRT\"];\n\nlet songs :Vec<_> = repeat(\"by\")\n    .zip(transportions)\n    .collect();\n    \nrprintln!(\"{:?}\", songs);\n#> [(\"by\", \"car\"), (\"by\", \"bus\"), (\"by\", \"MRT\")]"},{"path":"day12-iterator.html","id":"by_ref","chapter":"13 Day12-Iterator","heading":"13.3.13 by_ref","text":"當你將adapter附加至itrator，你通常不能解除取回底層iterator所有權。而iterator的by_ref方法可以借一個可變參考給iterator，在你使用adapter後，卸除它，結束借用並重新取得原始的iterator使用權。本章稍早曾使用take_while與skip_while分別截取正文與標題，你可以用不同的iterator來做這件事，或如下例中，iter.by_ref().take_while把一個可變參考給take_while，完成後，取回底下的iterator。","code":"\nlet message = \"To Tom\\r\\n\\\nFrom: Bling<whoareyouman0.4@gmail.com>\\r\\n\\\n\\r\\n\\\nDid you get any writting done today?\\r\\n\\\nwhen will you stop wasting time?\\r\\n\";\n\nlet mut iter = message.lines();\n\nrprintln!(\"Headers：\");\nfor body in iter.by_ref().take_while(|l| !l.is_empty()) {\n  rprintln!(\"{}\", body);\n}\n\nrprintln!(\"\\nBody：\");\nfor body in iter{\n  rprintln!(\"{}\", body);\n}\n\n#> Headers：\n#> To Tom\n#> From: Bling<whoareyouman0.4@gmail.com>\n#> \n#> Body：\n#> Did you get any writting done today?\n#> when will you stop wasting time?\n#> NULL"},{"path":"day12-iterator.html","id":"cloned-copied","chapter":"13 Day12-Iterator","heading":"13.3.14 cloned, copied","text":"cloned adapter接受一個產生參考的iterator，並回傳那些參考來產生值的iterator。當然，參考對象型態必須實作Clone。cloned adapter很像對iterator呼叫iter.map(|item| item.clone())，copied adapter的運作幾乎相同，但更嚴格。通常實作了copied的型態也會實作cloned。","code":"let a = ['1', '2', '3', '4'];\n\nrprintln!(\"{:?}\", a.iter().next());\nrprintln!(\"{:?}\", a.iter().cloned().next());\n#> Some('1')\n#> Some('1')"},{"path":"day12-iterator.html","id":"cycle","chapter":"13 Day12-Iterator","heading":"13.3.15 cycle","text":"cycle adapter可以讓iterataor無限循環，它利用的是Clone可以無限複製的特性，所以底層的iterator必須實作std::clone::Clone，好讓cycle可以儲存它的初始狀態。例如：另外是要設計一個小小的公因數遊戲，可被3整除的數字換成fizz，可倍5整除的換成buzz，兩者皆可的萬成fizzbuzz","code":"let fruit = [\"apple\", \"banana\", \"grape\"];\nlet mut iter = fruit.iter().cycle();\nfor _ in 0..10 {\n  if let Some(val) = iter.next() {\n    rprintln!(\"{}\", val);\n  }\n}\n#> apple\n#> banana\n#> grape\n#> apple\n#> banana\n#> grape\n#> apple\n#> banana\n#> grape\n#> apple\n#> NULLuse std::iter::{once, repeat};\n\nlet fizzes = repeat(\"\").take(2).chain(once(\"fizz\")).cycle();\nlet buzzes = repeat(\"\").take(4).chain(once(\"buzz\")).cycle();\nlet fizzes_buzzes = fizzes.zip(buzzes);\n\nlet fizz_buzz  = (1..16).zip(fizzes_buzzes)\n    .map(|tuple|\n           match tuple {\n             (i, (\"\", \"\")) => i.to_string(),\n             (_, (fizz, buzz)) => format!(\"{}{}\", fizz, buzz)\n           });\n\nfor x in fizz_buzz {\n  rprintln!(\"{}\", x);\n}\n\n#> 1\n#> 2\n#> fizz\n#> 4\n#> buzz\n#> fizz\n#> 7\n#> 8\n#> fizz\n#> buzz\n#> 11\n#> fizz\n#> 13\n#> 14\n#> fizzbuzz\n#> NULL"},{"path":"day12-iterator.html","id":"耗用iterator","chapter":"13 Day12-Iterator","heading":"13.4 耗用iterator","text":"你可以用for迴圈來耗用iterator，或明確的呼叫next，並用它們實作其他方法。但在標準庫中有許多已建立的方法能節省你重複標寫的時間。","code":""},{"path":"day12-iterator.html","id":"簡單累計count-sum-product","chapter":"13 Day12-Iterator","heading":"13.4.1 簡單累計：count, sum, product","text":"count方法會從iterator取出項目直至回傳None為止，並告訴你總共取得多少，下面此裡是在計算標準輸入的行數：sum與product可以計算總和與乘積，那些項目必須是整數或浮點數：","code":"use std::io::prelude::*;\n\nfn main() {\n  let stdin = std::io::stdin();\n  println!(\"{}\", stdin.lock().lines().count());\n}fn triangle(n: u64) -> u64 {\n  (1..=n).sum()\n}\n\nrprintln!(\"{}\", triangle(10));\n\nfn factorial(n: u64) -> u64 {\n  (1..=n).product()\n}\n\nrprintln!(\"{}\", factorial(10));\n#> 55\n#> 3628800"},{"path":"day12-iterator.html","id":"max-min","chapter":"13 Day12-Iterator","heading":"13.4.2 max, min","text":"Iterator的max與min方法回傳iterator最小與最大的項目。iterator必須實作std::cmp::Ord，以便讓項目可互相比較：f64與f32只實作了std::cmp::PartialOrd，因此你不能用這兩個方法，這樣看起來很不討喜，但它為你避免遇到IEEe與NaN時發生錯誤。假如你決定處理NaN值，你可以改用max_by與min_by。","code":"let mut x = [-1, 0, 2, 3].iter();\nrprintln!(\"{:?}\", x.clone().max());\nrprintln!(\"{:?}\", x.min());\n#> Some(3)\n#> Some(-1)"},{"path":"day12-iterator.html","id":"max_by-min_by","chapter":"13 Day12-Iterator","heading":"13.4.3 max_by, min_by","text":"max_by與min_by方法可以回傳iterator產生的最大或最小項目，它接受你提供的比較函式來決定結果：","code":"use std::cmp::Ordering;\n\nfn cmp(lhs: &f64, rhs: &f64) -> Ordering {\n  lhs.partial_cmp(rhs).unwrap()\n}\n\nlet numbers = [1.0, 2.0, 3.0];\nrprintln!(\"{:?}\", numbers.iter().copied().max_by(cmp));\nrprintln!(\"{:?}\", numbers.iter().copied().min_by(cmp));\n#> Some(3.0)\n#> Some(1.0)"},{"path":"day12-iterator.html","id":"max_by_key-min_by_key","chapter":"13 Day12-Iterator","heading":"13.4.4 max_by_key, min_by_key","text":"","code":"use std::collections::HashMap;\n\nlet mut populations = HashMap::new();\npopulations.insert(\"台北\", 555_555);\npopulations.insert(\"南投\", 321_321);\npopulations.insert(\"高雄\", 428_428);\n\nlet max_city = &populations.iter().max_by_key(|&(name, pop)| pop);\nlet min_city = &populations.iter().min_by_key(|&(name, pop)| pop);\n\nrprintln!(\"人口最多的城市是：{:?}\", max_city.unwrap().0);\nrprintln!(\"人口最多的城市是：{:?}\", min_city.unwrap().0);\n#> 人口最多的城市是：\"台北\"\n#> 人口最多的城市是：\"南投\""},{"path":"day12-iterator.html","id":"any與all","chapter":"13 Day12-Iterator","heading":"13.4.5 any與all","text":"any對iterator產生的項目呼叫一個closure，並在得到第一次true時回傳。all則在所有項目皆回傳true時才會回傳true","code":"let id = \"Iterator\";\nassert!( id.chars().any(char::is_uppercase));\nassert!(!id.chars().all(char::is_uppercase));"},{"path":"day12-iterator.html","id":"position-rposistion與-exactsizeiterator","chapter":"13 Day12-Iterator","heading":"13.4.6 position, rposistion與 ExactSizeIterator","text":"position方法會接受item並呼叫ㄧ個closure，當clousre回傳true時回傳該item的索引。確切來說，它是回傳一個Option，當所有項目都無法讓closure回傳true時回傳None。rposition也相同，只是會從右方開始：要注意，使用rposition方法必須實作std::iter::ExactSizeIterator trait，也就是有精確數量的迭代器：len方法會回傳剩餘的項目數量，is_empty方法則會在迭代完成後回傳true。當一個iterator無法預先知道它將產生多少項目，例如str::chars iterator就無法知道，所以你不能對字串使用rposition。","code":"let text = \"Allies\";\n\nrprintln!(\"{:?}\", text.chars().position(|c| c == 'l'));\nrprintln!(\"{:?}\", text.chars().position(|c| c == 'b'));\n#> Some(1)\n#> Nonelet text = b\"Allies\";\n\nrprintln!(\"{:?}\", text.iter().rposition(|&c| c == b'l'));\nrprintln!(\"{:?}\", text.iter().rposition(|&c| c == b'b'));\n#> Some(2)\n#> Nonetrait ExactSizeIterator: Iterator {\n  fn len(&self) -> usize {...}\n  fn is_empty(&self) -> bool {...}\n}"},{"path":"day12-iterator.html","id":"fold與rfold","chapter":"13 Day12-Iterator","heading":"13.4.7 fold與rfold","text":"fold方法可以實現許多基礎功能，用來對整個項目做累計結果。你提供一個初始值(accumulator)給fold，它會反覆用closure來處理當前的accumulator與iterator產生的下一個項目。此時accummulartor會變成新的，當所有項目都處理完成時accumulator就是回傳值。前面提到的許多耗用accumulator也可以用fold完成：fold的簽章是：A是accumulator型態。init引數是個A，closure的第一個引數和回傳值以及fold本身的回傳值也是A。rfold方法與fold很像，但是它需要雙端iterator，它會從最後面到最前面處理項目","code":"let a = [1, 2, 3, 4];\nlet count = a.iter().fold(0, |n, _| n+1);\nlet sum = a.iter().fold(0, |n, i| n+i);\nlet product = a.iter().fold(1, |n, i| n*i);\n\nrprintln!(\"count:{}\\nsum:{}\\nproduct:{}\", count, sum, product);\n#> count:4\n#> sum:10\n#> product:24fn fold<A, F>(self, init: A, f: F) -> A\n    where Self: Sized, F: FnMut(A, Self::Item) -> Alet a = [\"你好\", \"，\", \"我是一個機器人\", \"，\", \"很高興為您服務\"];\n\nlet String = a.iter().fold(String::new(), |s,w| s+w);\nrprintln!(\"{}\", String);\n#> 你好，我是一個機器人，很高興為您服務let a = [\"你好\", \"，\", \"我是一個機器人\", \"，\", \"很高興為您服務\"];\n\nlet String = a.iter().rfold(String::new(), |s,w| s+w);\nrprintln!(\"{}\", String.chars().count());\nrprintln!(\"{}\", String.chars().count());\n#> 18\n#> 18let String = (\"哈囉你好\\n我是機器人\\n趁熱吃比較好\\n比比怎麼中吃\\n\").to_string();\nfor line in String.lines() {\n  for b in line.bytes() {\n    rprintln!(\"{b}\");\n  } \n}\n#> 229\n#> 147\n#> 136\n#> 229\n#> 155\n#> 137\n#> 228\n#> 189\n#> 160\n#> 229\n#> 165\n#> 189\n#> 230\n#> 136\n#> 145\n#> 230\n#> 152\n#> 175\n#> 230\n#> 169\n#> 159\n#> 229\n#> 153\n#> 168\n#> 228\n#> 186\n#> 186\n#> 232\n#> 182\n#> 129\n#> 231\n#> 134\n#> 177\n#> 229\n#> 144\n#> 131\n#> 230\n#> 175\n#> 148\n#> 232\n#> 188\n#> 131\n#> 229\n#> 165\n#> 189\n#> 230\n#> 175\n#> 148\n#> 230\n#> 175\n#> 148\n#> 230\n#> 128\n#> 142\n#> 233\n#> 186\n#> 188\n#> 228\n#> 184\n#> 173\n#> 229\n#> 144\n#> 131\n#> NULL"},{"path":"day13-集合.html","id":"day13-集合","chapter":"14 Day13-集合","heading":"14 Day13-集合","text":"Rust的集合大多行為與其他語言相同，有所差異的在於我們重複強調的安全與性能：1.移動與借用在前面章節提到，Rust以移動避免深度複製，如在過去章節中提到Vec::push(item)以值接受引數，而不是以參考接受引數的原因。以此，不只省去複製字元資料的時間，也確保所有權始終明確。2.沒有失效錯誤：失效錯誤是一種懸空指標的bug，當集合被改變大小或以其他方式改變，但程式仍然持有指向它資料的指標。3.沒有nullRust沒有null，而是以Option取代","code":""},{"path":"day13-集合.html","id":"vec","chapter":"14 Day13-集合","heading":"14.1 Vec","text":"建立向量最簡單的方式是用vec!巨集：向量有三個欄位：長度、容量、儲存元素的heap指標。空向量numbers的初始向量是0，在沒有實際元素前不會配置heap記憶體。所有集合都實作了std::iter::FromIterator，所以你可以用.collect()方法來建立向量。","code":"// 建立空向量\nlet mut numbers:Vec<i32> = vec![];\n\n\n// 指定內容建立向量\nlet words = vec![\"step\", \"on\", \"no\", \"pets\"];\nlet mut buffer = vec![0u8; 1024]; // 1024個歸零的byteslet my_vec = my_set.into_iter().collect::<Vec<String>>();"},{"path":"day13-集合.html","id":"存取","chapter":"14 Day13-集合","heading":"14.1.1 存取","text":"當索引超出邊界時，這些寫法會panic。所有索引都必須是usize，適當的n usize是必須的。下面幾種方法也是取得向量元素的好做法：slice.first()、slice.last()：回傳slice的第一個、最後一個元素的參考，型態是Option，空回傳None，不是空的則回傳Some(&slice[0])slice.get(index)：回傳slice[index]的Some參考，型態是Option，當索引元素是空的會回傳Noneslice.first_mut()、slice.last_mut()、slice.get_mut(index)類似上面的方法，只是借用值可變參考slice.to_vec()複製整個slice，回傳一個新向量這個方法只能用在元素都是cloneable時","code":"// 取得元素的參考\nlet first_line = &lines[0];\n\n// 取得副本\nlet fifth_number = numbers[4];\nlet second_line = lines[1].clone();\n\n// 取得一個slice的參考\nlet my_ref = &buffer[4..12];\n\n// 取得一個slice的副本\nlet my_copy = buffer[4..12].to_vec();//需要Cloneif let Some(item) = v.first() {\n  println!(\"We got one {item}\");\n}let slice = [0,1,2,3];\nassert_eq!(slice.get(2), Some(&2));\nassert_eq!(slice.get(4), None);let mut slice = [0, 1, 2, 3];\n{\n  let last = slice.last_mut().unwrap(); // last的型態是: &mut i32\n  assert_eq!(*last, 3);\n  *last = 100;\n}\nassert_eq!(slice, [0, 1, 2, 100]);let mut slice = [0, 1, 2, 3];\nassert_eq!(slice.to_vec(), [0, 1, 2, 3]);\nassert_eq!(slice[0..2].to_vec(), [0, 1]);"},{"path":"day13-集合.html","id":"迭代","chapter":"14 Day13-集合","heading":"14.1.2 迭代","text":"向量、陣列與slice都是iterable，無論是以值還是以參考，都遵循上一章節所講的模式：迭代Vec或陣列[T; N]會產生T型態的N個項目，元素會被一個接一個移出向量或陣列並耗用迭代Vec或陣列[T; N]會產生T型態的N個項目，元素會被一個接一個移出向量或陣列並耗用迭代&[T; N]、&[T]或&Vec型態的值(也就是陣列、slice或向量的參考)會產生&T型態的項目，即指向個個元素的參考，它們不會被移除迭代&[T; N]、&[T]或&Vec型態的值(也就是陣列、slice或向量的參考)會產生&T型態的項目，即指向個個元素的參考，它們不會被移除迭代&mut [T; N]、&mut[T]或&mut Vec型態的值會產生&mut T型態的參考迭代&mut [T; N]、&mut[T]或&mut Vec型態的值會產生&mut T型態的參考要創建產生參考的iterator可以用.iter()與iter_mut方法","code":""},{"path":"day13-集合.html","id":"增長與收縮向量","chapter":"14 Day13-集合","heading":"14.1.3 增長與收縮向量","text":"陣列、slice與向量的長度是他們裡面元素的數量slice.len()回傳slice的長度，單位是usizeslice.is_empty()若slice裡面沒有元素，回傳true。因為只有向量可以增長與收縮，建立之後就無法改變大小的slice與陣列都沒有這些方法。向量的元蘇被存放在一個連續的heap記憶體裡面。向量的容量是可放入的最大元素數量。一般情況下Vec會自動管理容量，例如在需要更多空間時配置更大緩衝區。你可以用以下方法來明確記憶體管理Vec::with_capacity(n)建立一個新的、空的向量，容量為nvec.capacity()回傳一個usize的容量，其必定大於或等於vec.len()vec.reserve(n)確保向量能至少有足夠的空間可再容納n個元素。也就是說，vec.capacity()至少是vec.len() + n。如果空間足夠，這個函式不做任何事情。如果不夠，則會配置足夠大的緩衝區vec.reserve_exact(n)與vec.reserve(n)相似，但會要求vec不要配置超出n的任何而外空間。之後，vec.capcity()就是vec.len()+nvec.shrink_to_fit()如果vec.capacity()大於vec.len()，則會釋出額外記憶體Vec有許多加入與移除元素的方法，都是用mut參考來接受它的self引數。vec.push(value)將value加入vec的結尾vec.pop()移除並回傳最後一個元素。它的回傳型態是Option。如果pop出來的元素是x，它會回傳Some(x)要注意，以上兩個方法與接下來的都是以值移出與移入，如push(n)會將n移入，pop()會移出值如果你想指定移出與移入元素，考慮insert與remove：vec.insert(index, value)在vec[index]插入value，其餘元素會後移如果index > vec.len()，則會panicvec.remove(index)移除並回傳vec[index]元素，將後面元素前移如果index >= vec.len()，則會panic當向量元素越來越多，多次remove(n)會讓運行變慢，如果需奧要多次執行可改用VecDequeT>有四個方法可以改變vec的長度：vec.resize(new_len, value)將長度改為new_len，空餘的空間塞入value，注意value必須實作Clonevec.resize_with(new_len, closure)ㄧ樣將長度改變為new_len，特別用在要傳入的value不是clone type。vec.truncate(new_len)將長度改為new_len，多的元素會被清除vec.clear()會清除所有元素，相當於truncate(0)如果你想要一次加入或移除多值，考慮：vec.extend(iterable)在結尾加入iterable的所有項目，它很像多值版本的.pushvec.spilt_off(index)與vec.truncate(index)相似，但是回傳一個Vecvec.append(&mut vec2)它會將vec2的元素傳入vec，vec2在事後會被淨空與extend不同的是，vec2的殼會留下來vec.drain(range)將vec[range]從vec移除，並回傳一個迭代被移除的元素的itertor，其中的range是範圍值，如..或0..4此外還有一些方法能更進階的刪除值vec.retain(test)移除未通過指定測試的項目，方法會呼叫test(&element)函式或closure，回傳bool的項目留下。撇開性能不談，這個方法接近這段程式：vec.dedup()卸除重複的元素：要注意的是，它只會確認相鄰的元素是否重複，若你要移除所有重複，有三個選項：先排序再呼叫ded_up()、將資料移入集合，或使用.retain技巧(可以保持出現順序)這個魔法在於，.insert()會在集合已經正在插入的項目時回傳falsevec.dedup_by()透過same(&mut element1, &mut element2)來檢視兩元素是否相符。vec_dedup_by_key(key)若key(&mut element1) == key(&mut element2)，將兩個元素視為相等。例如，如果errors是Vec<Box>，你可以這樣寫：","code":"vec = vec.into_iter().filter(test).collect();let mut byte_vec = b\"Misssssissippi\"\nbyte_vec.dedup();\nassert_eq!(&byte_vec, b\"Misisipi\");let mut byte_vec = b\"Misssssissippi\"\n\nlet mut seen = HashSet::new();\nbyte_vec.retain(|r| seen.insert(*r));\n\nassert_eq!(&byte_vec, b\"Misp\")errors.dedup_by_key(|err| err.to_string());"},{"path":"day13-集合.html","id":"連接","chapter":"14 Day13-集合","heading":"14.1.4 連接","text":"有兩種方式處理陣列的陣列：slices.conact()串接所有slice來製作新向量並回傳：slices.join(&seperator)與conact相同功能，但在slice之間插入一個seperator的副本","code":"assert_eq!([[1,2], [3,4], [5,6]].conact(), \n           vec![1, 2, 3, 4, 5, 6]);assert_eq!([[1,2], [3,4], [5,6]].join(&0), \n           vec![1, 2, 0, 3, 4, 0, 5, 6]);"},{"path":"day13-集合.html","id":"拆分","chapter":"14 Day13-集合","heading":"14.1.5 拆分","text":"當涉及參考與可變參考時，拆分的動作要更注意。為了安全，所以拆分的方法都有mut與非mut版本。這些方法都不直接修改陣列、slice或向量，只回傳裡面部分資料的參考。slice.iter()、slice.iter_mut()產生slice各個元素的參考slice.split_at(index)、slice.split_at_mut(index)在指定位子拆分成兩個slice，slice.split_at(index)相當於(&slice[..index], &slice[index..])。當index超出邊界，方法會panic，slice.split_first(), slice.spilt_first_mut()回傳一對參考：一個指向第一個元素(slice[0])的參考，另一個是指向其他所有元素的參考(slice[1..])的slice參考準確的說，回傳型態是Option<(&T, &[T])>，當slice是空的時，結果是Noneslice.split_last(), slice.spilt_last_mut()與上一對方法相似，只是拆開最後一個元素slice.split(is_sep), slice.split_mut(is_sep)將slice分成一個或多個子slice，使用函式或closure_is_sep來決定拆開的位子，回傳一個迭代子slice的iterator呼叫is_sep(&element)，當回傳true時，該元素會變成分隔符號，不加入新的sliceslice.split_inclusive(), slice.spilt_inclusive_mut()它們的動作與split相似，但是在上一個子slice結尾加上分隔符號，而不是排除它slice.rsplit(is_sep), slice.rsplit_mut(is_sep)從slice結尾開始slice.splitn(n, is_sep), slice.splitn_mut(n,is_sep)限制分解slice的數量，在找到n-1個slice之後，就不會再呼叫closure，剩下的元素全部塞進最後一個slice:::slice.rsplitn(n, is_sep), slice.rsplitn_mut(n,is_sep)反向順序掃描slice.chunks(n), slice.chunks_mut(n)回傳iterator來迭代不重疊且長度為n的子slice，若slice.len()無法被n整除，則最後一個區域將少於n個slice.rchunks(n), slice.rchunks_mut(n)從結尾開始分slice.windows(n)回傳跨越連續n個元素的子slice，它產生的第一個值是&slice[0..n]，第二個是&slice[1….n+1]，以此類推若n大於slice的長度，此方法不產生slice，若n為0則panic如果你想知道探索兩個資料間的關係與變化，大小為2的窗口就很適合：","code":"let numbers = [11, 22, 33, 0, 44, 55, 0, 0, 66];\n    \nlet parts: Vec<_> = numbers.split(|&item| item == 0).collect();\n\nfor (i, part) in parts.iter().enumerate() {\n  rprintln!(\"Part {}: {:?}\", i, part);\n}\n#> Part 0: [11, 22, 33]\n#> Part 1: [44, 55]\n#> Part 2: []\n#> Part 3: [66]\n#> NULLlet numbers = [11, 22, 33, 0, 44, 55, 0, 0, 66];\n    \nlet parts: Vec<_> = numbers.split_inclusive(|&item| item == 0).collect();\n\nfor (i, part) in parts.iter().enumerate() {\n  rprintln!(\"Part {}: {:?}\", i, part);\n}\n#> Part 0: [11, 22, 33, 0]\n#> Part 1: [44, 55, 0]\n#> Part 2: [0]\n#> Part 3: [66]\n#> NULLlet numbers = [11, 22, 33, 0, 44, 55, 0, 0, 66];\n    \nlet parts: Vec<_> = numbers.rsplit(|&item| item == 0).collect();\n\nfor (i, part) in parts.iter().enumerate() {\n  rprintln!(\"Part {}: {:?}\", i, part);\n}\n#> Part 0: [66]\n#> Part 1: []\n#> Part 2: [44, 55]\n#> Part 3: [11, 22, 33]\n#> NULLlet numbers = [11, 22, 33, 0, 44, 55, 0, 0, 66];\n    \nlet parts: Vec<_> = numbers.splitn(2, |&item| item == 0).collect();\n\nfor (i, part) in parts.iter().enumerate() {\n  rprintln!(\"Part {}: {:?}\", i, part);\n}\n#> Part 0: [11, 22, 33]\n#> Part 1: [44, 55, 0, 0, 66]\n#> NULLlet numbers = [11, 22, 33, 0, 44, 55, 0, 0, 66];\n    \nlet parts: Vec<_> = numbers.rsplitn(2, |&item| item == 0).collect();\n\nfor (i, part) in parts.iter().enumerate() {\n  rprintln!(\"Part {}: {:?}\", i, part);\n}\n#> Part 0: [66]\n#> Part 1: [11, 22, 33, 0, 44, 55, 0]\n#> NULLlet numbers = [11, 22, 33, 0, 44, 55, 0, 0, 66];\n    \nlet parts: Vec<_> = numbers.chunks(2).collect();\n\nfor (i, part) in parts.iter().enumerate() {\n  rprintln!(\"Part {}: {:?}\", i, part);\n}\n#> Part 0: [11, 22]\n#> Part 1: [33, 0]\n#> Part 2: [44, 55]\n#> Part 3: [0, 0]\n#> Part 4: [66]\n#> NULLlet numbers = [11, 22, 33, 0, 44, 55, 0, 0, 66];\n    \nlet parts: Vec<_> = numbers.rchunks(2).collect();\n\nfor (i, part) in parts.iter().enumerate() {\n  rprintln!(\"Part {}: {:?}\", i, part);\n}\n#> Part 0: [0, 66]\n#> Part 1: [55, 0]\n#> Part 2: [0, 44]\n#> Part 3: [22, 33]\n#> Part 4: [11]\n#> NULL\nlet temperatures = [20, 22, 24, 28, 26, 27];\n    \nlet changes: Vec<_> = temperatures\n    .windows(2)\n    .collect();\n\nfor (i, part) in changes.iter().enumerate() {\n  rprintln!(\"Part {}: {:?}\", i, part);\n  rprintln!(\"Changes:{}\", part[1] - part[0]);\n}\n    \n\n#> Part 0: [20, 22]\n#> Changes:2\n#> Part 1: [22, 24]\n#> Changes:2\n#> Part 2: [24, 28]\n#> Changes:4\n#> Part 3: [28, 26]\n#> Changes:-2\n#> Part 4: [26, 27]\n#> Changes:1\n#> NULL"},{"path":"day13-集合.html","id":"對換","chapter":"14 Day13-集合","heading":"14.1.6 對換","text":"參考以下對換方法：slice.swap(, j)將slice[]與slice[j]元素對換slice_a.swap_with_slice(&mut slice_b)將slice[]與slice[j]元素兌換","code":"let mut numbers = [1, 2, 3];\nnumbers.swap(0, 2);\nrprintln!(\"{:?}\", numbers);\n\n#> [3, 2, 1]let mut numbers_a = [1, 2, 3];\nlet mut numbers_b = [0, 0, 0];\nnumbers_a.swap_with_slice(&mut numbers_b);\nrprintln!(\"{:?}\", numbers_a);\n\n#> [0, 0, 0]"},{"path":"day13-集合.html","id":"排序與搜尋","chapter":"14 Day13-集合","heading":"14.1.7 排序與搜尋","text":"slice有三種排序方式：slice.sort()按遞增順序來排序元素，元素必須實作Ord。slice.sort_by使用函式或closure cmp來指定排序順序，以排序slice的元素。cmp必須實作Fn(&T, &T) -> std::cmp::Ordering。親手撰寫cmp是痛苦的，但你可以善用.cmp()方法。若要用一個欄位來排順序，你可以使用第二個欄位作為分界符號(次要比較項目)，比較tupleslice.sort_by_key(key)用函式或closure key提供的排序鍵來將slice元素按遞增順序排列。key的型態必須實作Fn(&T) -> K，其中K; Ord。這個方法很適合在T有一個或多個有序欄位，你想用多種方式排序它:slice.reverse()將slice倒過來，如果你想反向排序，可以先用正邏輯sort_by()之後再reverseslice.binary_search(&value)二元查找法用於查找有排序過的資料，可以高效查詢，或是指出新資料的排序位置回傳型態是Result<usize, usize>，若slice[index]等於value，則回傳Ok(index)，若無則回傳Err(insertion)，讓後續插入動作能保持順序。slice.binary_search_by(cmp)回傳型態與上面相同，只是以回傳Ordering的函式來自訂比較自訂比較slice.binary_search_by(cmp)回傳型態與上面相同，只是以回傳Ordering的函式來自訂比較自訂比較slice.binary_search_by_key(&value, key)多一個指定value來避免手動提取鍵slice.contains(&value)若純粹要確認元素是否存在，可以使用contains，若該元素存在會回傳true若僅要尋找符合元素的位置，可以使用上一章節提到的position","code":"students.sort_by(|a, b| a.last_name.cmp(&b.last_name));students.sort_by(|a, b| {\n  let a_key = (&a.last_name, &a.first_name);\n  let b_key = (&b.last_name, &b.first_name);\n  a_key.cmp(&b_key)\n});students.sort_by_key(|s| s.grade_point_average());let numbers = vec![1, 2, 3, 4, 6, 7, 8, 9, 10];\n\nrprintln!(\"{:?}\", numbers.binary_search(&4));\nrprintln!(\"{:?}\", numbers.binary_search(&5));\n\n#> Ok(3)\n#> Err(4)students.binary_search_by(|student| {\n    if student.score < target_score {\n            Ordering::Less\n    } else if student.score > target_score {\n            Ordering::Greater\n    } else {\n            Ordering::Equal\n  }\n});students.binary_search_by(|student| {\n    if student.score < target_score {\n            Ordering::Less\n    } else if student.score > target_score {\n            Ordering::Greater\n    } else {\n            Ordering::Equal\n  }\n});slice.iter().position(|x| *x == value);"},{"path":"day13-集合.html","id":"隨機元素","chapter":"14 Day13-集合","heading":"14.1.8 隨機元素","text":"Rust標準程式庫為內建元素，但rand crate有，可以協助從向量中隨機取得元素雖然兩種方法都要Rng，所幸用&mut rand::thread_rng()，要記得匯入rand crate。slice.choose(&mut rng)回傳一個Option<&T>slice.shuffle(&mut rng)將vec重新洗牌","code":"use rand::seq::SliceRandom; // 0.7.2\n\nlet vs = vec![0, 1, 2, 3, 4];\nlet rand_num = vs.choose(&mut rand::thread_rng());let mut vs = vec![0, 1, 2, 3, 4];\nvs.shuffle(&mut rand::thread_rng());"},{"path":"r_unique.html","id":"r_unique","chapter":"15 R_unique","heading":"15 R_unique","text":"","code":""},{"path":"r_unique.html","id":"part1","chapter":"15 R_unique","heading":"15.1 part1","text":"輸出檔2.輸入檔或Stdout3.是否顯示字數","code":""}]
