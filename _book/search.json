[{"path":"index.html","id":"about","chapter":"1 About","heading":"1 About","text":"本冊是我本人學習Rust的筆記，出稿是我在2024夏天，打工無聊時，開啟幾天的Rust學習之旅。","code":""},{"path":"index.html","id":"參考資料","chapter":"1 About","heading":"1.1 參考資料","text":"","code":""},{"path":"day1---到處看看.html","id":"day1---到處看看","chapter":"2 Day1 - 到處看看","heading":"2 Day1 - 到處看看","text":"1~10猜數字！\n請輸入數字\n1\n你猜的數字是: 1\n太小了!\n請輸入數字\n7\n你猜的數字是: 7\n太大了!\n請輸入數字\n5\n你猜的數字是: 5\n太小了!\n請輸入數字\n6\n你猜的數字是: 6\n恭喜獲勝!","code":"use rand::Rng;\nuse std::cmp::Ordering;\nuse std::io;\n\nfn main() {\n    println!(\"1~10猜數字！\");\n\n    let secret_number = rand::thread_rng().gen_range(1..=10);\n\n    loop {\n        println!(\"請輸入數字\");\n\n        let mut guess = String::new();\n\n        io::stdin()\n            .read_line(&mut guess)\n            .expect(\"解析失敗\");\n\n        let guess: u32 = match guess.trim().parse() {\n            Ok(num) => num,\n            Err(_) => continue,\n        };\n\n        println!(\"你猜的數字是: {guess}\");\n\n        match guess.cmp(&secret_number) {\n            Ordering::Less => println!(\"太小了!\"),\n            Ordering::Greater => println!(\"太大了!\"),\n            Ordering::Equal => {\n                println!(\"恭喜獲勝!\");\n                break;\n            }\n        }\n    }\n}"},{"path":"day1---到處看看.html","id":"安裝rust","chapter":"2 Day1 - 到處看看","heading":"2.1 安裝rust","text":"這會安裝最新版本的Rust，並且會自動更新。如果成功，會得到以下訊息：檢查版本","code":"curl --proto '=https' --tlsv1.2 https://sh.rustup.rs -sSf | shRust is installed now. Great!rustc --version"},{"path":"day1---到處看看.html","id":"相關工具","chapter":"2 Day1 - 到處看看","heading":"2.1.1 相關工具","text":"安裝完Rust，我們來檢查其他三個相關的指令工具如預期的，他應該要跟我們分別回報版本，而這三個工具分別用來:cargo是Rust專門的編譯管理器與萬能的工具包，例如建立新專案，組建專案與執行專案，之後我們會頻繁使用。cargo是Rust專門的編譯管理器與萬能的工具包，例如建立新專案，組建專案與執行專案，之後我們會頻繁使用。rustc也是rust的編譯器，但我們通常都是透過cargo來為我們統一編譯及管理。rustc也是rust的編譯器，但我們通常都是透過cargo來為我們統一編譯及管理。rustdoc是文件工具，你以特定代碼在rs檔裡撰寫文件，rustdoc可以用它們來建立正確的HTML，但這件事我們同樣交由cargo處理。rustdoc是文件工具，你以特定代碼在rs檔裡撰寫文件，rustdoc可以用它們來建立正確的HTML，但這件事我們同樣交由cargo處理。","code":"cargo --version\nrustc --version\nrustdoc --version\n#> cargo 1.75.0 (1d8b05cdd 2023-11-20)\n#> rustc 1.75.0 (82e1608df 2023-12-21)\n#> rustdoc 1.75.0 (82e1608df 2023-12-21)"},{"path":"day1---到處看看.html","id":"hello.rs","chapter":"2 Day1 - 到處看看","heading":"2.2 hello.rs","text":"首先，執行以下指令，建立一個暫時新的專案：接著。寫入一個如下列的程式碼，並且儲存成 hello.rs：fn代表定義的函式，這裡的函式就是main()println!是顯示文字的巨集接著，讓我們來編譯這個代碼：","code":"mkdir tmp\ncd tmpfn main() {\n    println!(\"Hello, world!\");\n}rustc hello.rs\n./hellorprintln!(\"Hello, world!\");"},{"path":"day1---到處看看.html","id":"第一個專案-猜猜數字","chapter":"2 Day1 - 到處看看","heading":"2.3 第一個專案-猜猜數字","text":"跳往新目錄並且檢視新建成的專案目錄結構如下：Cargo.toml 是專案的設定檔，src/main.rs 是程式碼的檔案。使用指令創建的main.rs內容如下：所有的執行黨都是從main函數開始執行的而所有函式都會回傳一個值，在rust中，我們以箭頭與型別名稱表示例如：-> u32 表示回傳一個無符號(unsigned integer)32位元整數而main函數的回傳值是()，表示沒有回傳值，因此回傳的是Rust unit type接著，我們來執行這個專案：","code":"cargo new guess # create a new projectcd guess\ntree.\n├── Cargo.toml\n└── src\n    └── main.rsfn main() {\n    println!(\"Hello, world!\");\n}cargo run#> Hello, world!"},{"path":"day1---到處看看.html","id":"宣告變數","chapter":"2 Day1 - 到處看看","heading":"2.3.1 宣告變數","text":"Rust的變數型態是精華，我們會在明天討論它，但現在我們先來看看如何宣告變數。接著，我們宣告一個隨機數，我們會用到rand crate所以，請打開Cargo.toml，並且加入rand依賴，讓編譯器知道我們要使用這個套件：現在有一個隨機數了！接下來，我們要處理如何讓使用者輸入數字。這裡我們會用到std::io這個標準程式庫，因此只需引用它，而不需要再cargo.toml中加入依賴。use std::io;在terminal接收任何輸入，會被預期是字串，思路是：先接收字串，並且用字串提供的方法轉換成數字。guess在第ㄧ次被宣告是一個字串，並且接受使用者的輸入接著，第二次將其宣告為u32整數，是透過將字串轉換成數字。parrse()會回傳一個Result型別，成功的OK(num)或是失敗的Err(_)，我們用match來處理這兩種情況。接著我們要比較使用者輸入的數字與隨機數，並且給予提示。你可以用if-else來處理這個問題。或是用match與odering來處理(記得聲明引用程式庫use std::cmp::Ordering;)完整的程式碼與執行結果應該如下：","code":"let x = 5;\nprintln!(\"The value of x is: {}\", x);[package]\nname = \"guess\"\nversion = \"0.1.0\"\nedition = \"2021\"\n\n# See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html\n[dependencies]\nrand = \"0.8.4\"use rand::Rng;\n\nlet secret_number = rand::thread_rng().gen_range(1..=10);\nprintln!(\"The secret number is: {}\", secret_number);let mut guess = String::new();\n\nio::stdin().read_line(&mut guess)\n    .expect(\"閱讀失敗！請輸入數字\");\n  \nlet guess: u32 = match guess.trim().parse() {\n    Ok(num) => num,\n    Err(_) => continue,\n};if guess < secret_number {\n    rprintln!(\"太小了！\");\n} else if guess > secret_number {\n    rprintln!(\"太大了！\");\n} else {\n    rprintln!(\"猜對了！\");\n    break;\n}match guess.cmp(&secret_number){\n    Ordering:Less => rprintln!(\"太小了！\"),\n    Ordering:Greater => rprintln!(\"太大了！\"),\n    Ordering:Equal => {\n        rprintln!(\"猜對了！\");\n        break;\n    }\n}"},{"path":"day1---到處看看.html","id":"程式碼","chapter":"2 Day1 - 到處看看","heading":"2.4 程式碼","text":"","code":"use rand::Rng;\nuse std::cmp::Ordering;\nuse std::io;\n\nfn main() {\n    println!(\"1~10猜數字！\");\n\n    let secret_number = rand::thread_rng().gen_range(1..=10);\n\n    loop {\n        println!(\"請輸入數字\");\n\n        let mut guess = String::new();\n\n        io::stdin()\n            .read_line(&mut guess)\n            .expect(\"解析失敗\");\n\n        let guess: u32 = match guess.trim().parse() {\n            Ok(num) => num,\n            Err(_) => continue,\n        };\n\n        println!(\"你猜的數字是: {guess}\");\n\n        match guess.cmp(&secret_number) {\n            Ordering::Less => println!(\"太小了!\"),\n            Ordering::Greater => println!(\"太大了!\"),\n            Ordering::Equal => {\n                println!(\"恭喜獲勝!\");\n                break;\n            }\n        }\n    }\n}"},{"path":"day1---到處看看.html","id":"結果","chapter":"2 Day1 - 到處看看","heading":"2.5 結果","text":"1~10猜數字！\n請輸入數字\n1\n你猜的數字是: 1\n太小了!\n請輸入數字\n7\n你猜的數字是: 7\n太大了!\n請輸入數字\n5\n你猜的數字是: 5\n太小了!\n請輸入數字\n6\n你猜的數字是: 6\n恭喜獲勝!","code":""},{"path":"day2---型態.html","id":"day2---型態","chapter":"3 Day2 - 型態","heading":"3 Day2 - 型態","text":"本章介紹rust基本型態，他們的型態都有具體的機器等級對映物，因此他們的成本皆是可預測的。種類相當繁多，沒必要都「背」下來，隨著寫多了就記得下來了！Rust語言某種程度上是圍繞型態打造的，在簡單性和成本之間取得平衡，能保持記憶體與執行緒安全，同時透過泛型型態和trait保持彈性。本章介紹Rust基本型態，他們的型態都有具體的機器等級對映物，因此他們的成本皆是可預測的。目前，你大概知道Rust是一種靜態語言，且對型態有強烈的意識。你必須在編譯前就對型態有所規劃，這與動態語言例如R或JavaScript有很大的不同。不過與另外一門以安全興著稱的Java相比，rust的型態系統更為靈活，且更為強大。Rust內建有型態推斷機制，在實務上，有許多變數或運算實際上只適合一種型態，於此，Rust允許你省略型態宣告，而由編譯器推斷型態。你當然可以把每個型態都寫下來，但這樣做會讓程式碼變得冗長，且不易閱讀。從函式的回傳型態看來，v必定是Vec，也就是16-bit帶正負號整數向量，而推入之元素也必定是i16因此，Rust允許你省略型態宣告，而由編譯器推斷型態。","code":"fn build_vector() -> Vec<i16>{\n  let mut v: Vec<i16> = Vec::<i16>::new();\n  v.push(10i16);\n  v.push(20i16);\n}fn build_vector() -> Vec<i16>{\n  let mut v = Vec::new();\n  v.push(10);\n  v.push(20);\n}"},{"path":"day2---型態.html","id":"定寬數字型態","chapter":"3 Day2 - 型態","heading":"3.1 定寬數字型態","text":"字寬數字型態是Rust的基礎，是配合絕大多數的現代處理器的硬體所實作的型態。雖然定寬的數字型態有可能溢出或失去準度，但在多數情況下已經夠用，但這比任意精度準數和精確的有理數型態款幾千倍。如果你還是想這樣表示，你可以試試num crate。arch型態是指機器字寬，通常是32或64位元，usize和isize是指機器字寬的無正負號整數型態，通常用來表示記憶體位置。","code":""},{"path":"day2---型態.html","id":"整數型態","chapter":"3 Day2 - 型態","heading":"3.1.1 整數型態","text":"Rust的整數型態分為有無帶正負號的整數，而他們都是使用2的補數表示法。\n例如：i8的範圍是\\(-2^7\\)到\\(2^7-1\\)，u8的範圍是\\(0\\)到\\(2^8-1\\)Rust的整數常數可以加上後綴詞來表示型態，例如：10u8表示8-bit無正負號整數10，10i16表示16-bit帶正負號整數10。如果沒有後綴詞明確指出該型態，Rust會嘗試推斷型態，但如果無法推斷，則會報錯。另外，前綴0x表示16進位，0o表示8進位，0b表示2進位。有一個提升閱讀性的小技巧，你可以使用下底線來分隔數字或型態後綴詞，例如：1_000_000_u32表示32-bit無正負號整數1000000。如果你想要轉換整數型態，你可以使用as關鍵詞，之後會詳細介紹。標準程式庫提供了一些整數運算的method例如：abs()返回絕對值，wrapping_add()返回溢出時的結果，saturating_add()返回飽和時的結果，checked_add()返回溢出時的None，否則返回Some。","code":"assert_eq!(  10_i8 as u16, 10_u16);\n\nassert_eq!(  -1_i16 as i32, -1_i32);//符號擴展\nassert_eq!(65535_u16 as i32, 65535_i32);//零擴展"},{"path":"day2---型態.html","id":"checked-wrapping-saturing與overflowing算術","chapter":"3 Day2 - 型態","heading":"3.1.2 checked, wrapping, saturing與overflowing算術","text":"當整數運算溢出時，在debug buid裡，Rust會panic，而在release build裡，Rust會進行溢出檢查，並返回一個未定義的結果，我們將這種模式稱作wrap around，該結果相當於「在數學上正確的結果」modulo「值得範圍」。例如，以下程式在debug build裡會panic，而在release build裡會環繞為負數，而且迴圈會無期限地執行下去。如果你不想要這種預設行為，整數型態提供你一些方法，這些方法共分4類checked_XXX()：返回Option，若數學上正確的結果無法用該型態到值來表示，則返回None，否則返回Some(值)。wrapping_XXX()：返回值，當溢位時，返回「在數學上正確的結果」modulo「值得範圍」。這個法的優勢在於：他們在所有的buid裡面都會是相同的saturating_XXX()：返回值，當溢位時，返回最大或最小值，也就是計算結果被限制在該型態可以表示的最大與最小值範圍內除法、餘數逐位元移位沒有saturating版本overflowing_XXX()：返回一個tuple，第一個元素是計算結果，第二個元素是一個bool，當溢位時，bool為true，否則為false。overflowing在處理位元移動時稍有不同，他們的overflowed只會在移動距離與型態本身的位元寬或更大時才會回傳true，而實際的移動距離是你請求移動距離mod型態的位元寬度。","code":"let mut i = 1;\nloop{\n  i *= 10;//panic：試著執行溢位乘法\n          //(但只有在debug build裡)\n}// 10+20=30，結果在u8的範圍內\nassert_eq!(10_u8.checked_add(20), Some(30));\n\n\n// 255+1=256，結果超出u8的範圍\nassert_eq!(255_u8.checked_add(1), None);\n\n// 進行加法，當它溢位時panic\n\nlet sum = x.checked_add(y).unwrap();//第一個在範圍值內沒有問題\n// 第二個超出範圍，因此我們獲得250000 modulo$2^16$。\nassert_eq!(10000_u16.wrapping_mul(200), 250000);\nassert_eq!(10000_u16.wrapping_mul(500), 250000);\n\n// 針對正負運算有可能wrap成負數\nassert_eq!(500_i16.wrapping_sub(1000), -500);assert_eq!(100_u8.saturating_add(200), 255);\nassert_eq!(100_u8.saturating_sub(200), 0);assert_eq!(100_u8.overflowing_add(200), (44, true));\nassert_eq!(100_u8.overflowing_sub(200), (156, true));// 移動17 bit對u16而言太大，而17 mod 16 = 1\nassert_eq!(100_u16.overflowing_shl(17), (200, true));"},{"path":"day2---型態.html","id":"浮點數型態","chapter":"3 Day2 - 型態","heading":"3.2 浮點數型態","text":"一個非常標準的Rust浮點數長這樣：314.926e-4f64整數：314\n小數：926\n指數：e-4\n後綴：f64Rust的浮點數分為f32和f64，相當於Java的float和double，他們分別是32-bit和64-bit的IEEE754浮點數。要讓編譯器知道值為浮點數，你不一定明文型態，但必須要有指數、小數點或後綴型態，如：5.就是合法的浮點數，但5不是。如果沒有指定型態，但從脈絡可推斷為浮點數，則編譯器會推斷為f64。f32與f64型態有一些關聯常數是IEEE規定的特殊值，例如INFINITY、NEG_INFINITY、NAN、MIN、MAX等。另外，浮點數也提供一些method，例如sqrt()是開根號，exp()是指數函數請注意，方法呼叫的順位比運算子高，因此在對帶負號的浮點數值做運算時，務必加括號。Rust不會做隱性轉換，如果你丟給預期做浮點數運算的函式一個整數，Rust會大聲地抱怨給你聽，因此，請善用as關鍵字。雖然不做隱性運算會讓程式碼更加攏長，但這也減少許多bug的發生。最後，std::f32::consts和std::f64::consts提供了一些常數，例如：PI、E、LOG2_E、LOG10_E、LN_2、LN_10等。","code":"assert_eq!(f32::INFINITY, 1.0/0.0);\nassert!((-1. / f32::INFINITY).is_sign_negative());let x = 2.0_f64.exp();\nassert_eq!(x, std::f64::consts::E.powf(2.0));\nassert_eq!((-1.22f64).sqrt(), std::f64::NAN);"},{"path":"day2---型態.html","id":"布林型態","chapter":"3 Day2 - 型態","heading":"3.3 布林型態","text":"Rust的布林值，分為true和false，透過一些比較運算子產生許多語言都為布林判斷偷偷開了後門，如C將字元、整數、指標等隱性轉換為布林值，讓你在if或while裡直接將他們當作條件。但Rust不准你這樣做，即使在短路邏輯用算子&&和||裡也不行。你必須寫出if x!=0{…}，而不是if x{…}。但你可以可以用as運算子將bool轉換為整數型態，但數字不能反向轉換為布林值。","code":"assert_eq!(true as i32, 1);\nassert_eq!(false as i32, 0);"},{"path":"day2---型態.html","id":"tuple型態","chapter":"3 Day2 - 型態","heading":"3.4 tuple型態","text":"tuple可以是一對、三個、四個各種不同型態的值組合成的值例：(“Taipei”, 25, 100.0)這個tuple的型態是(&str, i32, f64)，你可以用tuple.0、tuple.1、tuple.2來取得裡面的值。但可惜你只能用常數來獲取值，而非變數，如tuple.0是合法的，但tuple.i是不合法的。這樣的tuple型態在rust中通常來幫函式回傳多個值，假如你有一個string slice要處理，你可以使用split_at()，這個函式會回傳一個tuple，裡面包含了兩個string slice，分別是原始string slice的前半部和後半部。該宣告式應該長這樣fn split_at(&self, mid: usize) -> (&str, &str)，你可以用let (first, second) = s.split_at(3);來取得這兩個string slice。我們常常不自覺的使用tuple，例如我們想要將一個file的檔名(&str,pixel(u8),和長寬(usize, usize)，最正規的是寫一個struct，但若作為過渡的資料結構，tuple為你做簡單明確的橋樑。另外一種是當作零tuple，也稱單元型態，只有一個值，寫成()。他出現在Rust需要某種型態，但又缺乏有意義的值可以使用。例如，不回傳值的函式回傳型態有些回傳這個型態，在std::men::swap函式中，沒有「有意義」的回傳值，而是單純的交換兩個變數的值，他的宣告式如下：另外我們常寫的Result<(), std::io::Error>，出錯時回傳std::io::Error的值，而成功則不回傳有意義的值。","code":"let tuple = (\"Taipei\", 25, 100.0);\ntuple.0\n#> [1] \"Taipei\"let s = \"Taipei\";\nlet (first, second) = s.split_at(3);\nrprintln!(\"{} {}\", first, second);\n#> Tai peifn write_image(filename: &str, pixels: &[u8], width: usize, height: usize)//<T>代表swap的「泛型」，可以處理任何型態的T參考值。\nfn swap<T>(x: &mut T, y: &mut T)\n//其實有回傳()，但寫的時候省略"},{"path":"day2---型態.html","id":"指標型態","chapter":"3 Day2 - 型態","heading":"3.5 指標型態","text":"Rust有幾種代表記憶體地址的型態，這是Rust和具備垃圾桶(garbage collection:記憶體回收)機制的語言之巨大差異，也是Rust看似繁瑣的型態系統的一部分。在Java中，如果class Rectangle中Vector2D upperleft; upperleft是分別建立的另一個Vector2D物件的參考，Java物件內部絕對不會有實際的其他物件。而Rust為管理並減少記憶體配置，在預設情況，值是崁套的，假設一個((0,0), (144, 122))值存成4個相鄰的整數。如果你將它存入一個區域變數，你會得到一個寬為四個整數的「區域變數」。Rust不會在heap上配置記憶體，除非你明確要求。這樣的做法是記憶體友好的，但如果要讓一個值指向另一個值，你必須明確的使用指標。強大的是，在safe Rust裡的標型態都受到約束，以消除為定義行為。","code":""},{"path":"day2---型態.html","id":"reference","chapter":"3 Day2 - 型態","heading":"3.5.1 Reference","text":"在入門段，我們常常使用簡單的ref來做參考，在執行期，一個指向i32的參考是一個機器word，保存的是i32的「地址」，該位子可能在stack也可能在heap。運算式&x產生一個指向x的參考，而*ptr則是取得ptr指向的值。多提一嘴，Rust參考絕對不會是null，並會記錄所有權與生命期，諸如懸空指標、重複釋出與無效指標的會在編譯期被排除。兩種參考型態：&T：不可變參考，你不能透過它來修改值。一個值可以有多個共享參考&T：不可變參考，你不能透過它來修改值。一個值可以有多個共享參考&mut T：可變參考，你可以透過它來修改值。一個值只能有一個可變參考，且在該參考存在期間，不可有其他參考存在。&mut T：可變參考，你可以透過它來修改值。一個值只能有一個可變參考，且在該參考存在期間，不可有其他參考存在。這兩種區別在編譯器檢查與執行時，可以確保程式的安全。","code":""},{"path":"day2---型態.html","id":"box","chapter":"3 Day2 - 型態","heading":"3.5.2 Box","text":"若你想在heap上配置值，最簡單的就是呼叫Box::new()b的型態是Box，當b離開作用域時，記憶體會被立刻釋出，除非移動，例如被回傳。移動是Rust非常重要的概念會提到，我們會在後面章節詳細介紹。","code":"let x = 10;\nlet b = Box::new(x);// 在heap上配置一個i32\n\nlet c = *b;// 取得b指向的值\nlet z = &b;// 取得b的參考\n\nrprintln!(\"{} {} {}\", c, b, z);\n\n#> 10 10 10"},{"path":"day2---型態.html","id":"原始指標","chapter":"3 Day2 - 型態","heading":"3.5.3 原始指標","text":"原始指標像C++同款，這在Rust是unsafe的，因爲程式不會追蹤它，因此他容易出錯，例如指向null或未初始化的記憶體。","code":""},{"path":"day2---型態.html","id":"陣列","chapter":"3 Day2 - 型態","heading":"3.5.4 陣列","text":"陣列的型態是[T; N]，T就像前面所述代表型態，N是長度，大小是執行期決定的常數，不能擴增或縮減。陣列有多種寫法，最簡單也常見的就是放在中括號裡如果要寫一個長陣列，裏面放差不多的值，可以寫成[V; N]，V是值，N是長度，例如：有些時候會用這種方法代表緩衝區，如上例就是1KB的緩衝區。如上述，因爲判斷長度在編譯期就是固定的，所以你不能用變數n來產生有n個值的陣列。陣列的方法其實都是Rust偷偷將陣列的參考轉換成silce，因此你才能在陣列上使用slice的方法。","code":"let a [u8; 3] = [1, 2, 3];[0_u8; 1024]let mut a = [5, 4, 3, 2, 1];\n\na.sort();\n\nfor x in a {\n  rprintln!(\"{}\", x);\n}\n#> 1\n#> 2\n#> 3\n#> 4\n#> 5\n#> NULL"},{"path":"day2---型態.html","id":"向量","chapter":"3 Day2 - 型態","heading":"3.5.5 向量","text":"最原始的向量是長這樣ＬVec，看到了嗎，只有型態沒長度，這代表你可以隨著時變去改變大小，他會在heap上配置記憶體，並且會在不需要時自動釋放。如果你知道向量的長度，你可以用vec!宏來建立，例如：因為他是向量，你可以繼續加入值：另外一種方式是呼叫Vec::new()來產生新的向量，然後用push()來加入值。也可以用iterator產的生的值來建立向量，例如：向陣列一樣，向量也會找到slice的方法。如果你事先知道向量的長度，你可以使用Vec::with_capacity()來代替Vec::new()，這樣預先留下夠大的緩衝區，可以減少向量擴增時的記憶體配置次數。在設計函式時常常用到這樣的優勢，如colloect()，iterator會事先知道向量有幾個值，以正確的預先配置回傳向量。向量的len()會告訴你向量的長度，capacity()會告訴你在不重新配置的情況下可以容納的元素。你可以用insert(位置, 值)來插入元素，用remove(位置)來移除元素最後介紹pop()，他會從Vec pop值會得到Option，如果最後一個值是v，則回傳Some(v)，否則回傳None。","code":"let vec = vec![1, 2, 3, 4, 5];\nvec.push(6);let mut vec = Vec::new();\nvec.push(1);\nvec.push(2);let a = [5, 4, 3, 2, 1];\nlet mut vec = Vec::new();\n\nfor x in a {\n  vec.push(x);\n}\n\nfor x in vec {\n  rprintln!(\"{}\", x);\n}\n#> 5\n#> 4\n#> 3\n#> 2\n#> 1\n#> NULLlet mut vec = Vec::with_capacity(2);\nrprintln!(\"len:{}, capacity:{}\", vec.len(), vec.capacity());\n\nvec.push(1);\nvec.push(2);\nrprintln!(\"len:{}, capacity:{}\", vec.len(), vec.capacity());\n\nvec.push(3);\nrprintln!(\"len:{}, capacity:{}\", vec.len(), vec.capacity());\n\n#> len:0, capacity:2\n#> len:2, capacity:2\n#> len:3, capacity:4let mut vec = vec![1, 2, 3, 4, 5];\n\n//在1與2之間插入0\nvec.insert(1, 0);\n\n//移除3\nvec.remove(3);\n\nrprintln!(\"{:?}\", vec);\n#> [1, 0, 2, 4, 5]let mut vec = vec![\"哈囉\", \"世界\"];\n\nrprintln!(\"{:?}\", vec.pop());\nrprintln!(\"{:?}\", vec.pop());\nrprintln!(\"{:?}\", vec.pop());\n#> Some(\"世界\")\n#> Some(\"哈囉\")\n#> Noneuse std::process::Command;\n\nlet mut cmd = Command::new(\"ls\");\nlet res = cmd.output();\nrprintln!(\"{:?}\", res);\n#> Ok(Output { status: ExitStatus(unix_wait_status(0)), stdout: \"01-Day1.Rmd\\n01-Day1.md\\n02-Day2.Rmd\\n03-Day3.Rmd\\n04-Day04.Rmd\\nREADME.md\\nRust書.Rproj\\nRust書.rds\\nUntitledRMD.Rmd\\n_book\\n_bookdown.yml\\n_common.R\\n_output.yml\\nartist\\nbook.bib\\nchicago-fullnote-bibliography.csl\\nguess\\nindex.Rmd\\nindex.md\\npackages.bib\\npreamble.tex\\nrender136b12b6d2f5c.rds\\nrender45366c2bc29f.rds\\nstyle.css\\ntmp\\n\", stderr: \"\" })"},{"path":"所有權與移動.html","id":"所有權與移動","chapter":"4 所有權與移動","heading":"4 所有權與移動","text":"","code":""},{"path":"所有權與移動.html","id":"所有權與移動-1","chapter":"4 所有權與移動","heading":"4.1 所有權與移動","text":"為了讓整個程式能更好的運用記憶體，我們指望程式能做到兩件事：1.指標絕對不能指向已釋出的物件，避免未定義行為造成安全漏洞2.用有自行決定記憶體何時釋放與速度的權利，減少無意義的損耗但想同時擁有這兩項優勢並不容易，尤其是高度的記憶體自由，由你掌控何時釋出，容易造成值的指標懸空。目前的程式可依者兩種優點而分為兩種陣營。安全派：使用垃圾回收的技術來管理記憶體，當所有指向該物件的指標消失時，它會自動釋放該物件，如此你不必為懸空指標憂慮，但同時你也失去了「自行決定何時將物件回收」的權利。目前幾乎所有程式都屬於這個派別，如C#、python、R、Java自由派：你能選擇何時釋出記憶體，但避免懸空指標的出現全都是你的責任。此派主流語言只有：C和C++而Rust生來就是要同時獲取兩種優勢，不然也沒必要學。因此，Rust用限制指標的使用來解決問題。這勢必會造成困擾，許多我們過去隨意使用的型態與寫法都將放棄。但也就是這些「困擾」，讓Rust能用編譯檢查機制來確保沒有安全混亂，如懸空指標、重複釋出、使用未初始化記憶體。這一套秩序也是並行設計的根基，如執行緒基元(threading primitibve)確保沒有資料爭用問題。在這些限制下寫出安全且靈活的程式，是你在學習Rust之路最大的挑戰，同時也是優勢。本章將帶你了解所有權的概念，比較不同語言的運作方式，進而學習如何處理與追蹤所有權的改變。","code":""},{"path":"所有權與移動.html","id":"所有權","chapter":"4 所有權與移動","heading":"4.2 所有權","text":"C++與C是由所有權人決定何時釋出物件，當所有權人銷毀時，物件也被毀滅。在堆疊中，std::string的長是3 word，分別裝的是緩衝區、容量、長度，他們都會指向heap，而hello就被放在heap中。當字串被銷毀時，字串的解構式(destructor)會被呼叫，這時std::string會釋放heap中的記憶體。你可以建立臨時指標來指向他人擁有的記憶體(如s擁有的h字元)，但當s字串被註銷時，指標就會無效，不得再使用。這種賦予所有權人絕對性的權利決定擁有物件的生命週期的方式，也是Rust的核心概念。每個值都需有決定期生命週期的所有權人，當所有權人被釋出(dropped)時，值也會被釋出。讓編譯器可以ㄧ眼看穿每一個值的生命週期，並以此檢測漏洞。在Rust中，當控制離開宣告該變數的區塊時，變數銷毀，同時卸除值。以Rust的Box為例，Box指向heap裡T型態值的指標。當你呼叫Box::new(v)的時候，系統會配置空間將v塞入，並且回傳一個指向該空間的Box。當box銷毀時，空間釋出。堆疊框本身保有變數(point、label)，兩個Box指向個別的heap空間。而在變數被卸除時，他們擁有的空間也會被釋放。舉另外一個複雜的例子，同時有tuple、struct、String、向量在這個結構中，最上層的堆疊匡是composers，擁有一個向量，而緩衝區則指向放有各個以Person為型態的heap空間。接著，如birth：i32的定寬數字直接配置在heap中，而string則有其容量、長度、緩衝區指向heap中的字串。當控制離開宣告composers的作用域後，composers會被卸除，連帶地卸除整個配置。如前所述，Rust會強迫每個值都有一個所有權人，但每一個所有人可以擁有多個值，如composers擁有3個Person元素。並且在複雜的架構中，會形成樹狀的架構，成為父子關係。當父親被銷毀時，他的子女也會被銷毀。如composers是3個元素的父輩，而3個元素又有個別的String子輩。因此在Rust中，你不會看到雜亂的架構，每一個值都是某棵樹的一分子。上述講述的例子可能讓你覺得Rust是一個僵化語言，但實作上可以作出靈活的延伸透過所有權的移動，重新排列樹狀結構，透過所有權的移動，重新排列樹狀結構，使用整數、浮點數、字元等簡單的型態，他們不受所有權的限制，稱為Copy型態使用整數、浮點數、字元等簡單的型態，他們不受所有權的限制，稱為Copy型態透過借用一個值的參考，使用這種無所有權、具有限生命週期的指標透過借用一個值的參考，使用這種無所有權、具有限生命週期的指標利用標準程式庫提供的參考計數(reference-counted)指標型態Rc與Arc，在特殊情況下讓值有多個所有權人利用標準程式庫提供的參考計數(reference-counted)指標型態Rc與Arc，在特殊情況下讓值有多個所有權人","code":"std :: string s = \"hello\";{\n   let point = Box::new((11, 13));  //ponit在此配置\n   let label = format!(\"{:?}\", point); //label在此配置\n   println!(\"label：{}\", label);\n   println!(\"point：{:?}\", point);\n}  //point與label在此銷毀\n#> NULLstrut Person {\n    name: String,\n    birth: i32,\n}\n\nlet mut composers = Vec::new();\ncomposers.push(Person {name: \"Palestrina\".to_string(), birth: 1525});\ncomposers.push(Person {name: \"Dowland\".to_string(), birth: 1563});\ncomposers.push(Person {name: \"Lully\".to_string(), birth: 1632});\n\nfor composer in &composers {\n    println!(\"{}, born {}\", composer.name, composer.birth);\n}"},{"path":"所有權與移動.html","id":"移動","chapter":"4 所有權與移動","heading":"4.3 移動","text":"在Rust中，大多數型態下，諸如將值指派給變數、將值回傳函式、從函式回傳值、將值傳遞給函式等操作，都不是複製，而是移動。當值被移動時，原本的變數為未初始化，該值的所有權被轉移。因此在以下例子，s1的所有權被轉移給s2，s1變成未初始化，無法再使用，當你再嘗試把s1傳給s3時，編譯器會報錯。✖ error[E0382]: use moved value: s1\n–> src/lib.rs:7:10\n|\n5 | let s1 = vec[“aaa”.to_string(), “bbb”.to_string()];\n| – move occurs s1 type Vec<String>, implement Copy trait\n6 | let s2 = s1;\n| – value moved \n7 | let s3 = s1;\n| ^^ value used move為什麽要有這種特性呢？我們可以先看兩個主流陣營的做法，比較優缺。","code":"let s1 = vec![\"aaa\".to_string(), \"bbb\".to_string()];\nlet s2 = s1;\nlet s3 = s1;"},{"path":"所有權與移動.html","id":"python","chapter":"4 所有權與移動","heading":"4.3.1 python","text":"python的每個物件都有一個參考數量，以此來記錄有多少值引用他。ㄧ開始初始化s1時，PyListObject的參考數量為1，當s2=s1時，參考數量變為2，s3=s1時，參考數量變為3。這讓python的賦值成本很低，但因為每次都會建立新參考，也代表著必須紀錄參考數才能知道何時釋出。","code":"s1 = ['aaa', 'bbb']\ns2 = s1\ns3 = s1"},{"path":"所有權與移動.html","id":"c","chapter":"4 所有權與移動","heading":"4.3.2 C++","text":"在C++中，當你將s1指派給s2時，會將整個副本都複製給s2。因此s1與s2都是獨立的，短短的幾行已經有3個向量、6個字串，如此的深度複製會造成損耗，但程式也容易決定何時釋出所有記憶體。","code":"using namespace std;\nvector<string> s1 = {\"aaa\", \"bbb\"};\nvector<string> s2 = s1;\nvector<string> s3 = s1;"},{"path":"所有權與移動.html","id":"rust","chapter":"4 所有權與移動","heading":"4.3.3 Rust","text":"如果你想要像C++一樣進行深複製，而不是移動，你應該呼叫向量的clone方法。你也可以使用我們前面提到的參考計數指標來模仿python的行為，也就是共享所有權。","code":"let s1 = vec![\"aaa\".to_string(), \"bbb\".to_string()];\nlet s2 = s1.clone();\nlet s3 = s1.clone();"},{"path":"所有權與移動.html","id":"移動與控制","chapter":"4 所有權與移動","heading":"4.3.4 移動與控制","text":"因為Rust會移動值，因此在預到控制流程時，你必須把握「如果值可能被移動，則必須考慮初始化的風險」迴圈也會有類似的問題，有可能在回圈中s1就會被移動，導致s2會被賦予未初始化的值(空的s)。","code":"let s1 = vec![\"aaa\".to_string(), \"bbb\".to_string()];\nif c {\n    let s2 = s1;\n} else {\n    let s3 = s1;\n}\ns4 = s1;// 錯誤，s1可能已經被移動let s1 = vec![\"aaa\".to_string(), \"bbb\".to_string()];\nwhile c {\n    let s2 = s1;\n    break;\n}"},{"path":"所有權與移動.html","id":"移動與檢索","chapter":"4 所有權與移動","heading":"4.3.5 移動與檢索","text":"一般來說，移動會將值的來源端變成未初始化，但許多情況下，所有權人會阻止隨意地移動。以上這段程式會出錯，並建議你改用參考，如果你還是想要將向量的值移出，你可以參考以下的寫法。再以上面Person的例子中，編譯器無法追蹤以struct包裝的string的所有權的移動狀況，但可以考慮用Option來動態追蹤。","code":"let mut v = Vec::new();\nfor i in 101..106 {\n    v.push(i.to_string());\n}\n\nlet third = v[2];\nlet fifth = v[4];let mut v = Vec::new();\nfor i in 101..106 {\n    v.push(i.to_string());\n}\n\n//1.pop method\n//移出向量的最後一個值\nlet fifth = v.pop().expect(\"no fifth element\");\nrprintln!(\"fifth: {}\", fifth);\n\n//2. swap_remove method\n//移出向量的指定位置值\nlet second = v.swap_remove(1);\nrprintln!(\"second: {}\", second);\n\n// 3.replace method\n// 用一個值來做交換\n\nlet third = std::mem::replace(&mut v[2], \"substitute\".to_string());\nrprintln!(\"third: {}\", third);\n\nrprintln!(\"v: {:?}\", v);\n#> fifth: 105\n#> second: 102\n#> third: 103\n#> v: [\"101\", \"104\", \"substitute\"] #[derive(Debug)]\nstruct Person {\n    name: Option<String>,\n    birth: i32,\n}\n\nlet mut composers = Vec::new();\ncomposers.push(Person {name: Some(\"Palestrina\".to_string()), birth: 1525});\ncomposers.push(Person {name: Some(\"Dowland\".to_string()), birth: 1563});\n\nlet first_name = std::mem::replace(&mut composers[0].name, None);\nrprintln!(\"first_name: {:?}\", first_name);\nrprintln!(\"composers: {:?}\", composers);\n\n// option提供給你take方法，，讓整體更簡潔\nlet second_name = composers[1].name.take();\nrprintln!(\"second_name: {:?}\", second_name);\nrprintln!(\"composers: {:?}\", composers);\n#> first_name: Some(\"Palestrina\")\n#> composers: [Person { name: None, birth: 1525 }, Person { name: Some(\"Dowland\"), birth: 1563 }]\n#> second_name: Some(\"Dowland\")\n#> composers: [Person { name: None, birth: 1525 }, Person { name: None, birth: 1563 }]"},{"path":"所有權與移動.html","id":"複製型態","chapter":"4 所有權與移動","heading":"4.3.6 複製型態","text":"剛剛我們提過Copy型態，他們不受所有權的限制，可以隨意複製，例如整數、浮點數、字元，這些型態不會像字串、向量等佔用大量的記憶體，以下例子比較：在上面的例子中，s1被賦值時，會在heap中配置一個字串。相反x不會在heap中配置，而是直接在堆疊匡裡配置。另外，當s1給s2時，hello字串的所有權被移轉。而x給y時，不會發生所有權的轉移，而是產生一個完全獨立的副本。這樣的區分除了在為記憶體空間的考量外，非Copy型態的值在被卸除時都要做某些特別的事。例如前面所述的Vec，卸除時須要讓元素釋放、File型態要關閉檔案控制碼、MutexGuard需要解鎖等等。那如果是自己定義的型態呢？✖ error[E0382]: borrow moved value: p\n–> src/lib.rs:16:28\n|\n14 | let p = Point {x: 1, y: 2};\n| - move occurs p type Point, implement Copy trait\n15 | print(p);\n| - value moved \n16 | rprintln!(“({}, {})”, p.x, p.y);\n| ^^^ value borrowed move\n|這裡的抱錯告訴你，在print(p)後，p的所有權被移動，所以你不能再使用p。所以在預設情況下，自定義的型態都是非Copy型態。但明明point型態裡放的都是整數，沒有必要動來動去！因此，你可以加入#[derive(Copy, Clone)]來讓point型態成為Copy型態。不過注意，如果你的型態裡有非Copy型態的成員，那麽你可不能用#[derive(Copy, Clone)]，而是要自己實作Copy與Clone trait。","code":"let s1 = \"hello\".to_string();\nlet s1 = s2;\n\nlet x = 5;\nlet y = x;struct Point {\n    x: i32,\n    y: i32,\n}\n\nfn print(p: Point) {\n    rprintln!(\"({}, {})\", p.x, p.y);\n}\n\nlet p = Point {x: 1, y: 2};\nprint(p);//\nrprintln!(\"({}, {})\", p.x, p.y);"},{"path":"所有權與移動.html","id":"rc與arc共享所有權","chapter":"4 所有權與移動","heading":"4.4 Rc與Arc：共享所有權","text":"所有權帶來安全，但設計程式免不了遇到需要保留值到最後，卻找不到適合的單一所有權人，又或著需要在多個執行緒間共享值。這時你可以使用Rc與Arc，他們是參考計數指標，可以讓值有多個所有權人。Rc與Arc的差別在於Arc可以在不同的執行緒間共享，Rc則是以高速在單執行緒間更改參數量，除此之外，兩者是等效，因此我們以Rc示範。Rc就是重現python的參考數管理生命週期的方式Rc是一個指向heap裡的指標，並且附帶一個參考數量。當你呼叫clone時，並非移動或複製，而是另外一個指向同個heap的指標，並且增加參考數。Rc的值並不可變，於此來確立執行緒安全的保障。所以，「任何值不可以是既共享又可變」。參考管理記憶體最大的問題是：當兩個參考計數的值互指，導致計數永遠不會歸零，卡在記憶體不被釋出。這種情況通常出現在舊值可變的情況，因為這樣才會出現此種循環，剛好Rust的機制讓這種情況很難發生。","code":"use std::rc::Rc;\n\nlet s = Rc::new(\"shirataki\".to_string());\nlet s2 = s.clone();\nlet s3 = s.clone();"},{"path":"所有權與移動.html","id":"總結","chapter":"4 所有權與移動","heading":"4.5 總結","text":"在此章節中，我們先學會了Rust的所有權概念，並且比較了不同語言的運作方式。接著，了解移動、複製與共享3種讓所有權更彈性。下一章節我們將討論最後一招：借用值的參考。","code":""},{"path":"參考.html","id":"參考","chapter":"5 參考","heading":"5 參考","text":"在上一章看到的所有指標，從Boxheap指標，以及String與Vec的內部指標，都擁有所有權：也就是說，當所有權人被卸除時，他的參考對象也隨之卸除。Rust也有無所有權指標，稱為參考，不會影響參考對象的生命週期。參考的概念就是取得位址，但在Rust中，參考的生命週期絕對不能超過參考的生命週期，來保證運作的安全性，換言之，正確理解Rust參考的方式是「借用值」，總有一天要歸還給所有權人。","code":""},{"path":"參考.html","id":"值的參考","chapter":"5 參考","heading":"5.1 值的參考","text":"我們要製作單曲與其歌手的表格，可以用雜湊表(HashMap)來儲存，並寫一個show函式來顯示表格在主要函式中，只要插入元素，並使用上面的函式即可輕鬆執行在看完前一章後，你會問HashMap的值如何傳遞的？那恭喜你，HashMap是以動態配置一個表，當你呼叫show(table)時，整個table會被移入函式，由for取得所有權，並ㄧ層ㄧ層的耗用，直到全部被銷毀。會產生錯誤告訴你，table已經被用掉了，應該用reference來取代那又要使用哪種參考呢？共享參考(shared reference)：可以讓任意數量的共享參考指向同一個值，但不能修改參考值。&e會產生e的共享參考，e的型態是T，&e的型態是&T。共享參考(shared reference)：可以讓任意數量的共享參考指向同一個值，但不能修改參考值。&e會產生e的共享參考，e的型態是T，&e的型態是&T。可變參考(mut reference)：只能有一個可變參考指向同一個值，但可以修改參考值。&mut e會產生e的可變參考，e的型態是T，&mut e的型別是&mut T。他不是Copy可變參考(mut reference)：只能有一個可變參考指向同一個值，但可以修改參考值。&mut e會產生e的可變參考，e的型態是T，&mut e的型別是&mut T。他不是Copy你可以用「多個讀取方」與「單一寫入方」來區分，當你使用共享參考時，「任何人」都無法修改值，即使是原本的所有權人。相反，在可變參考出現時，只有在其消滅時，方能再次使用。回到上面範例，show函式僅需要讀取table，因此我們已共享參考的方式改寫，只需要將show函式的參數型態改為&Table即可，同時記得在主要函式中，要放入&table。只需改變最上層的型態，如當Table變為&Table時，Vec會變為&Vec，String會變為&String，這樣就可以達到「借用值」的目的。而如果你想修改或是用方法，記得用可變參考，如用sort方法來排序歌曲","code":"use std::collections::HashMap;\ntype Table = HashMap<String, Vec<String>>;\n\nfn show(table: Table){\n  for(artist, album) in table {\n    rprintln!(\"{}的單曲：\", artist);\n    for song in album {\n      rprintln!(\" {}\", song);\n    }\n  }\n}\nfn main() {\n  let mut table = Table::new();\n  \n  table.insert(\"周杰倫\".to_string(), vec![\"青花瓷\".to_string(), \"稻香\".to_string()]);\n  table.insert(\"蔡依林\".to_string(), vec![\"倒帶\".to_string(), \"愛情三十六計\".to_string()]);\n  table.insert(\"張學友\".to_string(), vec![\"吻別\".to_string(), \"當愛已成往事\".to_string()]);\n  \n  show(table);\n  \n}#>  [1m [32m    Finished [0m dev [unoptimized + debuginfo] target(s) in 0.00s\n#>  [1m [32m     Running [0m `artist/target/debug/artist`\n#> 周杰倫的單曲：\n#>  青花瓷\n#>  稻香\n#> 蔡依林的單曲：\n#>  倒帶\n#>  愛情三十六計\n#> 張學友的單曲：\n#>  吻別\n#>  當愛已成往事show(table);\nassert_eq!(table[\"周杰倫\"], [\"青花瓷\", \"稻香\"]);error[E0382]: borrow of moved value: `table`\n  --> src/main.rs:23:14\n   |\n16 |   let mut table = Table::new();\n   |       --------- move occurs because `table` has type `HashMap<String, Vec<String>>`, which does not implement the `Copy` trait\n...\n22 |   show(table);\n   |        ----- value moved here\n23 |   assert_eq!(table[\"周杰倫\"], [\"青花瓷\", \"稻香\"]);\n   |              ^^^^^ value borrowed here after move\n   |\nnote: consider changing this parameter type in function `show` to borrow instead if owning the value isn't necessary\n  --> src/main.rs:5:16\n   |\n5  | fn show(table: Table){\n   |    ----        ^^^^^ this parameter takes ownership of the value\n   |    |\n   |    in this function\nhelp: consider cloning the value if the performance cost is acceptable\n   |\n22 |   show(table.clone());\n   |             ++++++++fn show(table: &Table){\n  for(artist, album) in table {\n    println!(\"{}的單曲：\", artist);\n    for song in album {\n      println!(\" {}\", song);\n    }\n  }\n}\n\nfn main() {\n  \n  ...\n  \n  show(&table);\n  assert_eq!(table[\"周杰倫\"], [\"青花瓷\", \"稻香\"]);\n}fn sort_album(table: &mut Table){\n  for(_, album) in table {\n    album.sort();\n  }\n})"},{"path":"參考.html","id":"隱性參考","chapter":"5 參考","heading":"5.2 隱性參考","text":"在可變參考時也相同：請再次觀察第一個例子，我們為何不用在使用元素時解參考呢？答案是，因為參考在Rust裡太常出現，運算子.可以用來隱性解參考","code":"let x = 5;\nlet y = &x;  //必須要嚴明參考\nassert!(*y == 5); //解參考時要明確\n#> NULLlet mut x = 5;\nlet n = &mut x;\n*n += 32;\nassert!(*n == 37);struct Person {\n  name: String,\n  age: i32,\n}\nlet p = Person {name: \"John\".to_string(), age: 32};\nlet p_ref = &p;\n\nassert_eq!(p_ref.name, \"John\");\n//相當於\nassert_eq!((*p_ref).name, \"John\");"},{"path":"參考.html","id":"參考的參考","chapter":"5 參考","heading":"5.3 參考的參考","text":"Rust允許多重參考，可以一層一層直到借到一個值：上面例子，r1借用p的值，r2會穿過r1到p借用值，也就是說，兩者值相同，但位址不同下面例子告訴你，==會自動指向最後的值，但std::ptr::eq會比較位址","code":"let p:i32 = 1;\nlet r1: &i32 = &p;\nlet r2: &&i32 = &r1;\nlet r3: &&&i32 = &r2;\nrprintln!(\"{} {} {}\", r1, r2, r3);\n#> 1 1 1let p:i32 = 1;\nlet c:i32 = 1;\n\nlet r1: &i32 = &p;\nlet r2: &i32 = &c;\n\nrprintln!(\"{} {}\", r1, r2);\nrprintln!(\"{}\", r1 == r2);\nrprintln!(\"{}\",std::ptr::eq(r1, r2));\n#> 1 1\n#> true\n#> false"},{"path":"參考.html","id":"借用任意運算式的參考","chapter":"5 參考","heading":"5.3.1 借用任意運算式的參考","text":"在Rust裡，你可以直接借用運算式的值(的參考)在借用的對象是運算式時，Rust會產生ㄧ個匿名變數來保存值，而這個變數的生命週期取決於使用參考的方式，若如同上面的&factorial(6)，直接指派給r，那麽他的生命週期就隨r。反之，如&(1+2)在封閉陳述式內，他的生命週期就是這個陳述式。","code":"fn factorial(n: usize) -> usize {\n  (1..n+1).product()\n}\n\nlet r = &factorial(6);\nrprintln!(\"{}\", r+&(1+2));\n#> 723"},{"path":"參考.html","id":"借用區域變數","chapter":"5 參考","heading":"5.4 借用區域變數","text":"下面的案例，告訴你注意借用值的生面週期會告訴你，因為x掛點了，但借用他值的r還活著，導致出現了懸空指標在處理一般的資料結構時，會順理成章的避免發生者種狀況，因為都是先有資料，參考都是在資料之後產生，因此解決這種「限制」的最好方式，就是安排好資料的生命週期與宣告順序。","code":"let r;\n  {\n  let x = 5;\n  r = &x;\n  }\n\nrprintln!(\"{}\", *r);✖ error[E0597]: `x` does not live long enough\n  --> src/lib.rs:8:7\n   |\n7  |   let x = 5;\n   |       - binding `x` declared here\n8  |   r = &x;\n   |       ^^ borrowed value does not live long enough\n9  |   }\n   |   - `x` dropped here while still borrowed\n10 |\n11 | rprintln!(\"{}\", *r);\n   |                 -- borrow later used herelet x = 1;\n{\n  let r = &x;\n  rprintln!(\"{}\", r);\n}\n#> 1\n#> NULL"},{"path":"參考.html","id":"用函式引數來接收參考","chapter":"5 參考","heading":"5.5 用函式引數來接收參考","text":"以函式引數接收參考時，同樣注意生命週期、可變性、型態等問題你可以將static理解為全域變數，會ㄧ直存在於整個執行期。而可變的static是不安全的，你只能在unsafe區塊中使用。其二，每一個static都必須初始化。如果型態的問題已解決，讓我們來看看生命週期：完整的f是長fn f<'>(p : &'i32)’a的概念是任何生命週期，只要涵蓋f的區域即可。但static必須是整個生命週期，你必須很明確的指出，我們要的生命週期是static退一步來說，雖然略為麻煩，但你可以從簽章看出一個函式的意圖，如從fn f<'>(p : &'i32)到fn f(p: &'static i32)，你可以從中看出生命週期，而不用重新閱讀一長串程式。","code":"// 以下無法成功編譯\nstatic mut STASH:&i32;\nfn f(p : &i32) {\n  STASH = p;\n}// 修改後依然有小錯誤\nstatic mut STASH:&i32 = &10;\nfn f(p : &i32) {\nunsafe{\n  STASH = p;\n  }\n}// 終於解決問題\nstatic mut STASH:&i32 = &10;\nfn f(p: &'static i32) {\nunsafe{\n  STASH = p;\n  }\n}"},{"path":"參考.html","id":"回傳參考值","chapter":"5 參考","heading":"5.6 回傳參考值","text":"在處理資料時，我們常傳入一部分資料，並回傳一個結果，例如以下要取得整個slice裡的最小值同樣的，以上函式省略了週期，明確地寫出會是fn smallest<'>(v:&'i32) -> &'i32，你可以看到，回傳值的生命週期與引數的生命週期相同，這是Rust預設的概念。因此，當回傳值的生命週期大於引數的生命週期，就會提醒你發生錯誤解決以上問題，只要注意生命週期即可","code":"fn smallest(v:&[i32]) -> &i32{\n  let mut s = &v[0];\n  for r in &v[1..] {\n    if *r < *s {\n      s = r;\n    }\n  }\n  s\n}\n#> NULLlet s;\n  {\n    let v = [1, 2, 3, 4, 5];\n    s = smallest(&v);\n  }\n\nrprintln!(\"{}\", s);✖ error[E0597]: `v` does not live long enough\n  --> src/lib.rs:20:18\n   |\n19 |     let v = [1, 2, 3, 4, 5];\n   |         - binding `v` declared here\n20 |     s = smallest(&v);\n   |                  ^^ borrowed value does not live long enough\n21 |   }\n   |   - `v` dropped here while still borrowed\n22 |\n23 | rprintln!(\"{}\", s);\n   |                 - borrow later used herelet s;\n  {\n    let v = [1, 2, 3, 4, 5];\n    s = smallest(&v);\n    rprintln!(\"{}\", s);\n  }\n#> 1\n#> NULL"},{"path":"參考.html","id":"包含參考的結構","chapter":"5 參考","heading":"5.7 包含參考的結構","text":"以下是過去錯誤的例子Rust就是如此嚴謹，即使放入結構中，也要注意週期的概念我們再次把完整的內容寫出來struct S<'> { r: &'i32 }，於此，s的週期’a不會超過x如果我們要將有週期的參數型態，就要明確的指出，有兩個方法","code":"struct S {\n r: &i32\n}\n\nlet s;\n{\n  let x = 10;\n  s = S{r: &x};\n}\nrprintln!(*s.r, 10);// 錯誤：x已被卸除struct S {\n r: &i32\n}\n\n//Rust會要求你寫出生命週期\nstruct D {\n s: S\n}\n\n//可以指定s為static\nstruct D {\n s: S<'static>\n}\n\n//編譯器會提供你這個做法\nstruct D<'a> {\n s: S<'a>\n}"},{"path":"參考.html","id":"不同生命週期的結構","chapter":"5 參考","heading":"5.7.1 不同生命週期的結構","text":"上面我們講到結構也要注意週期問題，以下例子有些弔詭，r與x的生命週期最長，次為y，最後是a。我們賦予r結構a的x值，並且在x未死亡前，在最後印出r的值。照理來說，牽涉r值的，僅有r本身與x，所以應該不會有問題。但是，Rust會告訴你，r的生命週期不夠長，因為y已經死亡…其實，秘密就在預設結構的生命週期。結構中，x與y被預設為’，而Rust會以較小的生命週期為主，如同上例中，即使x尚未死亡，但y的生命週期結束，結構中的x也被視為死亡。所以，你可以在結構中就預設不同的生命週期，可以避免這種窘境，並且讓所有人都知道這個結構的生命週期","code":"struct s<'a>{\n  x: &'a i32,\n  y: &'a i32,\n}\n\nlet x = 20;\nlet r;\n{\n  let y = 10;\n  {\n    let a = s{x: &x, y: &y};\n    r = a.x;\n  }\n}\nrprintln!(\"{}\", r);✖ error[E0597]: `y` does not live long enough\n  --> src/lib.rs:15:25\n   |\n13 |   let y = 10;\n   |       - binding `y` declared here\n14 |   {\n15 |     let a = s{x: &x, y: &y};\n   |                         ^^ borrowed value does not live long enough\n...\n18 | }\n   | - `y` dropped here while still borrowed\n19 | rprintln!(\"{}\", r);\n   |                 - borrow later used herestruct s<'a, 'b>{\n  x: &'a i32,\n  y: &'b i32,\n}\n\nlet x = 20;\nlet r;\n{\n  let y = 10;\n  {\n    let a = s{x: &x, y: &y};\n    r = a.x;\n  }\n}\nrprintln!(\"{}\", r);\n#> 20"},{"path":"參考.html","id":"共用與可變性的衝突","chapter":"5 參考","heading":"5.8 共用與可變性的衝突","text":"再次強調兩點：共用參考是唯獨的：你可以讓任意數兩的變數指向，但他不會是可變的，因為可變參考必定會修改或更動原本的值。共用參考是唯獨的：你可以讓任意數兩的變數指向，但他不會是可變的，因為可變參考必定會修改或更動原本的值。可變參考是唯一的：只有一個可變參考指向同一個值，所以也不會出現與共用參考重疊生命週期。可變參考是唯一的：只有一個可變參考指向同一個值，所以也不會出現與共用參考重疊生命週期。所以，上面的例子中，錯誤訊息告訴你，你不能再指向s1(共用參考)，因為在函式內已經建立「唯一」路徑(可變參考)。以機器面來說，當extend獲取第一個參數&mut s1時，因為要加入更多元素，因此要重新配置記憶體。舊的記憶體會先被釋出，此時extend要讀取第二個參數&s1，但這個參數指向的記憶體早已被釋出。","code":"fn extend(v:&mut Vec<f64>, slice:&[f64]){\n  for s in slice {\n    v.push(*s);\n  }\n}\n#> NULLlet mut s1 = Vec::new();\nlet s2 = [1.0, 2.0, 3.0];\nlet s3 = [4.0, 5.0, 6.0];\n\nextend(&mut s1, &s2);\nextend(&mut s1, &s3);\nrprintln!(\"{:?}\", s1);\n#> [1.0, 2.0, 3.0, 4.0, 5.0, 6.0]extend(&mut s1, &s1);✖ error[E0502]: cannot borrow `s1` as immutable because it is also borrowed as mutable\n  --> src/lib.rs:18:17\n   |\n18 | extend(&mut s1, &s1);\n   | ------ -------  ^^^ immutable borrow occurs here\n   | |      |\n   | |      mutable borrow occurs here\n   | mutable borrow later used by calllet mut v = (1,3);\nlet mut r = &v.0;\nlet r1 = &mut r;\n*r1 = &2;\nrprintln!(\"{}\", v.0);\n#> 1"},{"path":"參考.html","id":"結論","chapter":"5 參考","heading":"5.9 結論","text":"總言之，此章節對Rust的參考做了全面性的介紹，尤其注意到生命週期與可變性的概念，揭示了這是一門需要詳細規劃的預言。從自動記憶體管理出現的年代，物件之海成為習以為常的架構模式，它的確可以幫助我們快速開發。但同時，因為物件相互彼此依賴共生，要測試、修改、測試變得困難。而Rust的限制，讓你的架構從一開使就井然有序，因為Rust喜歡讓指標、所有權、資料等朝向同一個地方，這並不容易，所以請繼續往下努力，總有一天你可以建立起架構之海。","code":""},{"path":"r_unique.html","id":"r_unique","chapter":"6 R_unique","heading":"6 R_unique","text":"","code":""},{"path":"r_unique.html","id":"part1","chapter":"6 R_unique","heading":"6.1 part1","text":"輸出檔2.輸入檔或Stdout3.是否顯示字數","code":""}]
