# 09




## enum

C風格的enum很簡單：


```rust
Ordering {
    Less,
    Equal,
    Greater,
}
```

它宣告有三種可能值的Ordering型態，enum的值稱為variant或costructor：Ordering::Less, Ordering::Equal, Ordering::Greater。它是標準程式庫的一部分，你可以直接匯入他


```rust
use std::cmp::Ordering;

fn compare(n: i32, m: i32) -> Ordering {
    if n < m { Ordering::Less }
    else if n > m { Ordering::Greater }
    else { Ordering::Equal }
}
```

或是匯入constructor，匯入constroctur可以讓你簡寫，但一般來說不匯入constructor是比較好的習慣



```rust
use std::cmp::Ordering::{Less, Greater, Equal};

fn compare(n: i32, m: i32) -> Ordering {
    if n < m { Less }
    else if n > m { Greater }
    else { Equal }
}
```

enum結構也可以擁有方法：


```rust
#[derive (Copy, Clone, Debug, PartialEq)]
enum TimeUnit {
  Seconds, Minutes, Hours, Days, Months, Years
}

impl TimeUnit {
  fn plural(self) -> &'static str {
    match self {
      TimeUnit::Seconds => "seconds",
      TimeUnit::Minutes => "minutes",
      TimeUnit::Days => "days",
      TimeUnit::Months => "months"
    }
  }
  
  fn singular(self) -> &'static str {
    self.plural().trim_end_matches('s')
  }
}
```




## 含資料的enum

有些時候你不需要完整的時間，提供粗略的時間更方便用戶，例如「兩個月之前」，你可以寫一個enum實現：


```rust
#[derive (Copy, Clone, Debug, PartialEq)]
enum RoughTime {
  InThePast(TimeUnit, u32)
  JustNow
  InTheFuture(TimeUnit, u32)
}
```

這個enum的其中兩個variant(InThePast, InTheFuture)可以接受參數，而以tuple接受接受參數的varint稱為tuple variant：


```rust
let four_score_and_seven_years_ago = RoughTime::InThePast(TimeUnit::Year, 87);
let three_days_from_now = RoughTime::InTheFuture(TimeUnit::Day, 3);
```

第二種是strut variant，有具名欄位：


```rust
enum Shape {
  Sphere {center: Point3d, radius: f32},
  Cuboid { center1:Point3d, corner2: Point3d},
}

let unit_sphere = Shape::Sphere {
  center: ORIGIN,
  radius: 1.0,
};
```

## 泛型enum


enum可以寫成泛型，在標準程式庫有兩個我們的老朋友


```rust
enum Option<T> {
    Some(T),
    None,
}

enum Result<T, E> {
    Ok(T),
    Err(E),
}
```


我們都知道泛型可以為你節省多少功夫，以下例子為你講解BinaryTree型態與它的運作模式：


```rust
enum BinaryTree<T> {
  Empty,
  NoneEmpty(Box<TreeNode<T>>),
}

struct TreeNode<T> {
  element: T,
  left: BinaryTree<T>,
  right: BinaryTree<T>
}
#> NULL
```

BinaryTree的值有兩種可能，Empty或NoneEmpty，前者代表沒有沒有資料，後者則有一個Box指標，指向heap上的TreeNode。

而每一個TreeNode又各有一個實際元素與兩個BinaryTree值。這代表可以形成一個無限伸展的樹狀結構。


```rust
use BinaryTree::*;
let Alan_tree = NoneEmpty(Box::new(TreeNode {
  element: "Alan",
  left: Empty,
  right: Empty
}));

let Alan_son_tree = NoneEmpty(Box::new(TreeNode {
  element: "Alan_son",
  left: Empty,
  right: Empty
}));

let Alan_daughter_tree = NoneEmpty(Box::new(TreeNode {
  element: "Alan_daughter",
  left: Empty,
  right: Empty
}));

let Alan_tree = NoneEmpty(Box::new(TreeNode {
  element: "Alan",
  left: Alan_son_tree,
  right: Alan_daughter_tree
}));
```

這個就是節點的概念，上例的Alan_tree為父節點，會擁有Alan_son_tree與Alan_daughter的所有權。

本章的後面會展示怎麼進一步為BinaryTree型態實作與加入方法。

這樣的結構需要時間熟悉，尤其是一開始不確定要把Box放在哪，你可能要事先規劃你的記憶體配置，熟悉這種結構能讓你自己控制記憶體的使用。

接下來我們要來談enum的代價，那就是Rust不會不顧風險的試著存取欄位，不管有沒有值，只能透過**模式**來取得內部資料。

## 模式

複習一下上面的RoughTime型態定義：


```rust
fn enough_time_english(rt: RoughTime) -> String {
  match rt {
    RoughTime::InThePast(units, count) =>
      format!("{} {} ago",count, units.plural()),
    RoughTime::JustNow => 
      format!("juat now"),
    RoughTime::InTheFuture(units, count) =>
      format!("{} {} from now", count, units.plural())
  }
}
```

match常用來為模式進行比對，在這個例子中，模式就是`=>`前面的部分。

當模式使用units與count這種**代號**時，變成模式後面的區域變數。值裡面的東西會被複製或移到新變數內。


假設你想進一步更正語法錯誤，你可以再加入其他分支，如：


```rust
RoughTime::InTheFutrue(unit, 1) =>
  format!("a {} from now", unit.singular())
```

要注意將這個修正放在InTheFutrue(unit, count)之前，因為符合`RoughTime::InTheFutrue(unit, 1)`都會符合此項，Rust會給你一個unreachable pattern的警告。

模式比對與enum合作無間，這也是match強大之處，而模式的功能遠不止次，參見下表

## 常值、變數與萬用模式


```rust
match meadow.count_rabbits() {
  0 => {},
  1 => println!("A rabit is nosing around in the clover"),
  n => println!("there are {} rabbits hopping about in the meadow", n),
}
```

n代表區域變數，可以適用任何值，符合它的值會被移動或複製到新的區域變數，在這個例子裡，meadow.count_rabbits() 在超過一隻的情況下或被存入新區域變數n並印出。

不只數字，包括布林、字元，甚至字串。下例的other與上例的n相同，可以匹配與其他不符合的值，稱為**全包模式**


```rust
let calendar = match settings.get_string("calendar") {
  "gregorian" => Calendar::Gregorian,
  "chinese" => Calender::Chinese,
  "ethiopian" => Calendar::Ethiopian,
  other => return parse_error("calendar, other"),
};
```

萬用模式可以匹配任何值，不同之處在，它不會將儲存到任何地方，僅作為你的備用處理


```rust
pub fn bmr_caculate(&self) -> Result<f64, ()>  {
      let age = self.age as f64;
      match self.gender {
        'M' => Ok(10.0 * self.weight + 6.25 * self.height - 5.0 * age + 5.0),
        'F' => Ok(10.0 * self.weight + 6.25 * self.height - 5.0 * age - 161.0),
        _ => Err(())
      }
    }
```

## tuple與結構模式

tuple模式就是比對tuple，在你需要處理多項資料時使用：


```rust
pub fn compare_pinot(x: i32, y: i32) -> &'static str {
  use std::cmp::Ordering::*;
  match (x.cmp(&0), y.cmp(&0)) {
    (Equal, Equal) => on the origin" ,
    (_, Equal) => "on the x axis",
    (Equal, _) => "on the y axis",
    (Greater, Greater) => "in the first quadrant",
    (Less, Greater) => "in the second quadrant"
  }
}
```

結構模式使用大括號，很像結構運算式，比對每個欄位的子模式：


```rust
match balloon.location {
  Point { x:0, y: height} => 
    println!("straight up {} meters", height),
  Point {x:x, y:y} =>
    println!("at ({}m, {}m)", x, y),
}
```

`Point{ x: x, y: y}`容易造成誤認，你可以簡寫成`Point{ x, y}`，它仍然可以辨識x與y會是下面的新變數。

有時候即使使用縮寫，如果我們只在乎一兩個欄位，程式會很冗長：


```rust
match get_account(id) {
  ...,
  Some(Account {
    name, language,
    id:_, status: _, adddress: _,birth: _,eye_color: _,
    pet: _, security_question: _}) =>
     
  })
}
```

為了避免這種狀況，你可以使用..來告訴Rust其餘部分你不在乎：


```rust
match get_accuount(id) {
  ...,
  Some(Account{ name, language, ...}) =>
    language.show_custom_greeting(name),
}
```

## 陣列與slice模式

陣列模式可以篩選特殊的值，特別是陣列的不同位置有不同意義的時後

以下例子中，你想將色調、飽和度、亮度(HSL)顏色值轉換成了紅藍綠，亮度為零或最大值就是黑色或白色，我們可以輕鬆用match運算式來處這些例子：


```rust
fn hsl_to_rgb(hsl: [u8; 3]) -> [u8; 3] {
  match hsl {
    [_, _, 0] => [0, 0, 0],
    [_, _, 255] => [255, 255, 255],
    ...
  }
}
```

slice模式又與陣列相似，但sliceq長度可變，因此會比對長度，在slice模式中，..會比對任何運算：


```rust
fn greet_people(names: &[&str]) {
  match names {
    [] => { println!("沒人在嗎")}
    [a] => { println!("你好{}",a)},
    [a, b] => { println!("你好，{}和{}", a, b)}
    [a, .., b] => { println!("哈囉 {}到{}", a, b)}
  } 
}
```


## 參考模式

Rust模式有兩種處理參考的模式。ref會借用部分匹配值，&則會比對參考

匹配不可複製的值(非Copy)會移動該值，如下例中，在比對accuont.name與account.language會被移入區域變數name與language中，其餘不分會被卸除，因此不能借用它的參考。


```rust
match account {
  Account { name, language, .. } => {
    ui.greet(&name, &language);
    ui.show_settings(&account); //錯誤account已被移動
  }
}
```


```rust
let mut x = 1;
let y = &mut x;
*y = 2;
rprintln!("{}",x);

#> 2
```



