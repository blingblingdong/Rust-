<!DOCTYPE html>
<html lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<title>Chapter 3 Day2 - 型態 | Rust之書</title>
<meta name="author" content="董宸賓">
<meta name="description" content="本章介紹rust基本型態，他們的型態都有具體的機器等級對映物，因此他們的成本皆是可預測的。種類相當繁多，沒必要都「背」下來，隨著寫多了就記得下來了！ Rust語言某種程度上是圍繞型態打造的，在簡單性和成本之間取得平衡，能保持記憶體與執行緒安全，同時透過泛型型態和trait保持彈性。 本章介紹Rust基本型態，他們的型態都有具體的機器等級對映物，因此他們的成本皆是可預測的。...">
<meta name="generator" content="bookdown 0.36.2 with bs4_book()">
<meta property="og:title" content="Chapter 3 Day2 - 型態 | Rust之書">
<meta property="og:type" content="book">
<meta property="og:description" content="本章介紹rust基本型態，他們的型態都有具體的機器等級對映物，因此他們的成本皆是可預測的。種類相當繁多，沒必要都「背」下來，隨著寫多了就記得下來了！ Rust語言某種程度上是圍繞型態打造的，在簡單性和成本之間取得平衡，能保持記憶體與執行緒安全，同時透過泛型型態和trait保持彈性。 本章介紹Rust基本型態，他們的型態都有具體的機器等級對映物，因此他們的成本皆是可預測的。...">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Chapter 3 Day2 - 型態 | Rust之書">
<meta name="twitter:description" content="本章介紹rust基本型態，他們的型態都有具體的機器等級對映物，因此他們的成本皆是可預測的。種類相當繁多，沒必要都「背」下來，隨著寫多了就記得下來了！ Rust語言某種程度上是圍繞型態打造的，在簡單性和成本之間取得平衡，能保持記憶體與執行緒安全，同時透過泛型型態和trait保持彈性。 本章介紹Rust基本型態，他們的型態都有具體的機器等級對映物，因此他們的成本皆是可預測的。...">
<!-- JS --><script src="https://cdnjs.cloudflare.com/ajax/libs/clipboard.js/2.0.6/clipboard.min.js" integrity="sha256-inc5kl9MA1hkeYUt+EC3BhlIgyp/2jDIyBLS6k3UxPI=" crossorigin="anonymous"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/fuse.js/6.4.6/fuse.js" integrity="sha512-zv6Ywkjyktsohkbp9bb45V6tEMoWhzFzXis+LrMehmJZZSys19Yxf1dopHx7WzIKxr5tK2dVcYmaCk2uqdjF4A==" crossorigin="anonymous"></script><script src="https://kit.fontawesome.com/6ecbd6c532.js" crossorigin="anonymous"></script><script src="libs/jquery-3.6.0/jquery-3.6.0.min.js"></script><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<link href="libs/bootstrap-4.6.0/bootstrap.min.css" rel="stylesheet">
<script src="libs/bootstrap-4.6.0/bootstrap.bundle.min.js"></script><script src="libs/bs3compat-0.5.1/transition.js"></script><script src="libs/bs3compat-0.5.1/tabs.js"></script><script src="libs/bs3compat-0.5.1/bs3compat.js"></script><link href="libs/bs4_book-1.0.0/bs4_book.css" rel="stylesheet">
<script src="libs/bs4_book-1.0.0/bs4_book.js"></script><link href="libs/panelset-0.2.6/panelset.css" rel="stylesheet">
<script src="libs/panelset-0.2.6/panelset.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/autocomplete.js/0.38.0/autocomplete.jquery.min.js" integrity="sha512-GU9ayf+66Xx2TmpxqJpliWbT5PiGYxpaG8rfnBEk1LL8l1KGkRShhngwdXK1UgqhAzWpZHSiYPc09/NwDQIGyg==" crossorigin="anonymous"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/mark.js/8.11.1/mark.min.js" integrity="sha512-5CYOlHXGh6QpOFA/TeTylKLWfB3ftPsde7AnmhuitiTX4K5SqCLBeKro6sPS8ilsz1Q4NRx3v8Ko2IBiszzdww==" crossorigin="anonymous"></script><!-- CSS --><style type="text/css">
    
    div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
  </style>
<link rel="stylesheet" href="style.css">
</head>
<body data-spy="scroll" data-target="#toc">

<div class="container-fluid">
<div class="row">
  <header class="col-sm-12 col-lg-3 sidebar sidebar-book"><a class="sr-only sr-only-focusable" href="#content">Skip to main content</a>

    <div class="d-flex align-items-start justify-content-between">
      <h1>
        <a href="index.html" title="">Rust之書</a>
      </h1>
      <button class="btn btn-outline-primary d-lg-none ml-2 mt-1" type="button" data-toggle="collapse" data-target="#main-nav" aria-expanded="true" aria-controls="main-nav"><i class="fas fa-bars"></i><span class="sr-only">Show table of contents</span></button>
    </div>

    <div id="main-nav" class="collapse-lg">
      <form role="search">
        <input id="search" class="form-control" type="search" placeholder="Search" aria-label="Search">
</form>

      <nav aria-label="Table of contents"><h2>Table of contents</h2>
        <ul class="book-toc list-unstyled">
<li><a class="" href="index.html"><span class="header-section-number">1</span> About</a></li>
<li><a class="" href="day1---%E5%88%B0%E8%99%95%E7%9C%8B%E7%9C%8B.html"><span class="header-section-number">2</span> Day1 - 到處看看</a></li>
<li><a class="active" href="day2---%E5%9E%8B%E6%85%8B.html"><span class="header-section-number">3</span> Day2 - 型態</a></li>
<li><a class="" href="%E6%89%80%E6%9C%89%E6%AC%8A%E8%88%87%E7%A7%BB%E5%8B%95.html"><span class="header-section-number">4</span> 所有權與移動</a></li>
<li><a class="" href="%E5%8F%83%E8%80%83.html"><span class="header-section-number">5</span> 參考</a></li>
<li><a class="" href="day5-%E9%81%8B%E7%AE%97%E5%BC%8F.html"><span class="header-section-number">6</span> Day5-運算式</a></li>
<li><a class="" href="day06---%E9%8C%AF%E8%AA%A4.html"><span class="header-section-number">7</span> Day06 - 錯誤</a></li>
<li><a class="" href="day07---crate%E8%88%87%E6%A8%A1%E7%B5%84.html"><span class="header-section-number">8</span> Day07 - crate與模組</a></li>
<li><a class="" href="day08---%E7%B5%90%E6%A7%8B.html"><span class="header-section-number">9</span> Day08 - 結構</a></li>
<li><a class="" href="day09---enum%E8%88%87%E6%A8%A1%E5%BC%8F.html"><span class="header-section-number">10</span> Day09 - enum與模式</a></li>
<li><a class="" href="day10-tarit%E8%88%87%E6%B3%9B%E5%9E%8B.html"><span class="header-section-number">11</span> Day10-tarit與泛型</a></li>
<li><a class="" href="day11-closure.html"><span class="header-section-number">12</span> Day11-closure</a></li>
<li><a class="" href="day12-iterator.html"><span class="header-section-number">13</span> Day12-Iterator</a></li>
<li><a class="" href="day13-%E9%9B%86%E5%90%88.html"><span class="header-section-number">14</span> Day13-集合</a></li>
<li><a class="" href="r_unique.html"><span class="header-section-number">15</span> R_unique</a></li>
</ul>

        <div class="book-extra">
          <p><a id="book-repo" href="https://github.com/rstudio/bookdown-demo">View book source <i class="fab fa-github"></i></a></p>
        </div>
      </nav>
</div>
  </header><main class="col-sm-12 col-md-9 col-lg-7" id="content"><div id="day2---型態" class="section level1" number="3">
<h1>
<span class="header-section-number">3</span> Day2 - 型態<a class="anchor" aria-label="anchor" href="#day2---%E5%9E%8B%E6%85%8B"><i class="fas fa-link"></i></a>
</h1>
<p>本章介紹rust基本型態，他們的型態都有具體的機器等級對映物，因此他們的成本皆是可預測的。種類相當繁多，沒必要都「<strong>背</strong>」下來，隨著寫多了就記得下來了！</p>
<p><link href="https://fonts.googleapis.com/icon?family=Material+Icons" rel="stylesheet"></p>
<p>Rust語言某種程度上是圍繞型態打造的，在簡單性和成本之間取得平衡，能保持記憶體與執行緒安全，同時透過泛型型態和trait保持彈性。</p>
<p>本章介紹Rust基本型態，他們的型態都有<strong>具體的機器等級對映物</strong>，因此他們的成本皆是可預測的。</p>
<p>目前，你大概知道Rust是一種靜態語言，且對型態有強烈的意識。你必須在編譯前就對型態有所規劃，這與動態語言例如R或JavaScript有很大的不同。</p>
<p>不過與另外一門以安全興著稱的Java相比，rust的型態系統更為靈活，且更為強大。</p>
<p>Rust內建有<strong>型態推斷機制</strong>，在實務上，有許多變數或運算實際上只適合一種型態，於此，Rust允許你省略型態宣告，而由編譯器推斷型態。</p>
<p>你當然可以把每個型態都寫下來，但這樣做會讓程式碼變得冗長，且不易閱讀。</p>
<div class="sourceCode" id="cb22"><pre class="sourceCode rust"><code class="sourceCode rust"><span id="cb22-1"><a href="day2---%E5%9E%8B%E6%85%8B.html#cb22-1" tabindex="-1"></a><span class="kw">fn</span> build_vector() <span class="op">-&gt;</span> <span class="dt">Vec</span><span class="op">&lt;</span><span class="dt">i16</span><span class="op">&gt;{</span></span>
<span id="cb22-2"><a href="day2---%E5%9E%8B%E6%85%8B.html#cb22-2" tabindex="-1"></a>  <span class="kw">let</span> <span class="kw">mut</span> v<span class="op">:</span> <span class="dt">Vec</span><span class="op">&lt;</span><span class="dt">i16</span><span class="op">&gt;</span> <span class="op">=</span> <span class="dt">Vec</span><span class="pp">::</span><span class="op">&lt;</span><span class="dt">i16</span><span class="op">&gt;</span><span class="pp">::</span>new()<span class="op">;</span></span>
<span id="cb22-3"><a href="day2---%E5%9E%8B%E6%85%8B.html#cb22-3" tabindex="-1"></a>  v<span class="op">.</span>push(<span class="dv">10i16</span>)<span class="op">;</span></span>
<span id="cb22-4"><a href="day2---%E5%9E%8B%E6%85%8B.html#cb22-4" tabindex="-1"></a>  v<span class="op">.</span>push(<span class="dv">20i16</span>)<span class="op">;</span></span>
<span id="cb22-5"><a href="day2---%E5%9E%8B%E6%85%8B.html#cb22-5" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>從函式的回傳型態看來，v必定是Vec<i16>，也就是16-bit帶正負號整數向量，而推入之元素也必定是i16</i16></p>
<p>因此，Rust允許你省略型態宣告，而由編譯器推斷型態。</p>
<div class="sourceCode" id="cb23"><pre class="sourceCode rust"><code class="sourceCode rust"><span id="cb23-1"><a href="day2---%E5%9E%8B%E6%85%8B.html#cb23-1" tabindex="-1"></a><span class="kw">fn</span> build_vector() <span class="op">-&gt;</span> <span class="dt">Vec</span><span class="op">&lt;</span><span class="dt">i16</span><span class="op">&gt;{</span></span>
<span id="cb23-2"><a href="day2---%E5%9E%8B%E6%85%8B.html#cb23-2" tabindex="-1"></a>  <span class="kw">let</span> <span class="kw">mut</span> v <span class="op">=</span> <span class="dt">Vec</span><span class="pp">::</span>new()<span class="op">;</span></span>
<span id="cb23-3"><a href="day2---%E5%9E%8B%E6%85%8B.html#cb23-3" tabindex="-1"></a>  v<span class="op">.</span>push(<span class="dv">10</span>)<span class="op">;</span></span>
<span id="cb23-4"><a href="day2---%E5%9E%8B%E6%85%8B.html#cb23-4" tabindex="-1"></a>  v<span class="op">.</span>push(<span class="dv">20</span>)<span class="op">;</span></span>
<span id="cb23-5"><a href="day2---%E5%9E%8B%E6%85%8B.html#cb23-5" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<div id="定寬數字型態" class="section level2" number="3.1">
<h2>
<span class="header-section-number">3.1</span> 定寬數字型態<a class="anchor" aria-label="anchor" href="#%E5%AE%9A%E5%AF%AC%E6%95%B8%E5%AD%97%E5%9E%8B%E6%85%8B"><i class="fas fa-link"></i></a>
</h2>
<p>字寬數字型態是Rust的基礎，是配合絕大多數的<strong>現代處理器</strong>的硬體所實作的型態。雖然定寬的數字型態有可能溢出或失去準度，但在多數情況下已經夠用，但這比任意精度準數和精確的有理數型態款幾千倍。如果你還是想這樣表示，你可以試試num crate。</p>
<div class="inline-table"><table class="table table-sm">
<tr>
<th>
大小
</th>
<th>
無正負好整數
</th>
<th>
帶正負號整數
</th>
<th>
浮點數
</th>
</tr>
<tr>
<td>
8-bit
</td>
<td>
u8
</td>
<td>
i8
</td>
<td>
x
</td>
</tr>
<tr>
<td>
16-bit
</td>
<td>
u16
</td>
<td>
i16
</td>
<td>
x
</td>
</tr>
<tr>
<td>
32-bit
</td>
<td>
u32
</td>
<td>
i32
</td>
<td>
f32
</td>
</tr>
<tr>
<td>
64-bit
</td>
<td>
u64
</td>
<td>
i64
</td>
<td>
f64
</td>
</tr>
<tr>
<td>
128
</td>
<td>
u128
</td>
<td>
i128
</td>
<td>
x
</td>
</tr>
<tr>
<td>
arch
</td>
<td>
usize
</td>
<td>
isize
</td>
<td>
x
</td>
</tr>
</table></div>
<p>arch型態是指機器字寬，通常是<strong>32</strong>或<strong>64</strong>位元，usize和isize是指機器字寬的無正負號整數型態，通常用來表示記憶體位置。</p>
<div id="整數型態" class="section level3" number="3.1.1">
<h3>
<span class="header-section-number">3.1.1</span> 整數型態<a class="anchor" aria-label="anchor" href="#%E6%95%B4%E6%95%B8%E5%9E%8B%E6%85%8B"><i class="fas fa-link"></i></a>
</h3>
<p>Rust的整數型態分為<strong>有無帶正負號</strong>的整數，而他們都是使用2的補數表示法。<br>
例如：i8的範圍是<span class="math inline">\(-2^7\)</span>到<span class="math inline">\(2^7-1\)</span>，u8的範圍是<span class="math inline">\(0\)</span>到<span class="math inline">\(2^8-1\)</span></p>
<p>Rust的整數常數可以加上<strong>後綴詞</strong>來表示型態，例如：<code>10u8</code>表示8-bit無正負號整數10，<code>10i16</code>表示16-bit帶正負號整數10。</p>
<p>如果沒有後綴詞明確指出該型態，Rust會嘗試推斷型態，但如果無法推斷，則會報錯。</p>
<p>另外，前綴0x表示16進位，0o表示8進位，0b表示2進位。</p>
<p>有一個提升閱讀性的小技巧，你可以使用下<strong>底線來分隔數字或型態後綴詞</strong>，例如：<code>1_000_000_u32</code>表示32-bit無正負號整數1000000。</p>
<p>如果你想要轉換整數型態，你可以使用<strong>as</strong>關鍵詞，之後會詳細介紹。</p>
<div class="sourceCode" id="cb24"><pre class="sourceCode rust"><code class="sourceCode rust"><span id="cb24-1"><a href="day2---%E5%9E%8B%E6%85%8B.html#cb24-1" tabindex="-1"></a><span class="pp">assert_eq!</span>(  <span class="dv">10_i8</span> <span class="kw">as</span> <span class="dt">u16</span><span class="op">,</span> <span class="dv">10_u16</span>)<span class="op">;</span></span>
<span id="cb24-2"><a href="day2---%E5%9E%8B%E6%85%8B.html#cb24-2" tabindex="-1"></a></span>
<span id="cb24-3"><a href="day2---%E5%9E%8B%E6%85%8B.html#cb24-3" tabindex="-1"></a><span class="pp">assert_eq!</span>(  <span class="op">-</span><span class="dv">1_i16</span> <span class="kw">as</span> <span class="dt">i32</span><span class="op">,</span> <span class="op">-</span><span class="dv">1_i32</span>)<span class="op">;</span><span class="co">//符號擴展</span></span>
<span id="cb24-4"><a href="day2---%E5%9E%8B%E6%85%8B.html#cb24-4" tabindex="-1"></a><span class="pp">assert_eq!</span>(<span class="dv">65535_u16</span> <span class="kw">as</span> <span class="dt">i32</span><span class="op">,</span> <span class="dv">65535_i32</span>)<span class="op">;</span><span class="co">//零擴展</span></span></code></pre></div>
<p>標準程式庫提供了一些整數運算的method</p>
<p>例如：abs()返回絕對值，wrapping_add()返回溢出時的結果，saturating_add()返回飽和時的結果，checked_add()返回溢出時的None，否則返回Some。</p>
</div>
<div id="checked-wrapping-saturing與overflowing算術" class="section level3" number="3.1.2">
<h3>
<span class="header-section-number">3.1.2</span> checked, wrapping, saturing與overflowing算術<a class="anchor" aria-label="anchor" href="#checked-wrapping-saturing%E8%88%87overflowing%E7%AE%97%E8%A1%93"><i class="fas fa-link"></i></a>
</h3>
<p><strong>當整數運算溢出時，在debug buid裡，Rust會panic</strong>，而在release build裡，Rust會進行溢出檢查，並返回一個<strong>未定義的結果</strong>，我們將這種模式稱作<strong>wrap around</strong>，該結果相當於「在數學上正確的結果」modulo「值得範圍」。</p>
<p>例如，以下程式在debug build裡會panic，而在release build裡會環繞為負數，而且迴圈會無期限地執行下去。</p>
<div class="sourceCode" id="cb25"><pre class="sourceCode rust"><code class="sourceCode rust"><span id="cb25-1"><a href="day2---%E5%9E%8B%E6%85%8B.html#cb25-1" tabindex="-1"></a><span class="kw">let</span> <span class="kw">mut</span> i <span class="op">=</span> <span class="dv">1</span><span class="op">;</span></span>
<span id="cb25-2"><a href="day2---%E5%9E%8B%E6%85%8B.html#cb25-2" tabindex="-1"></a><span class="cf">loop</span><span class="op">{</span></span>
<span id="cb25-3"><a href="day2---%E5%9E%8B%E6%85%8B.html#cb25-3" tabindex="-1"></a>  i <span class="op">*=</span> <span class="dv">10</span><span class="op">;</span><span class="co">//panic：試著執行溢位乘法</span></span>
<span id="cb25-4"><a href="day2---%E5%9E%8B%E6%85%8B.html#cb25-4" tabindex="-1"></a>          <span class="co">//(但只有在debug build裡)</span></span>
<span id="cb25-5"><a href="day2---%E5%9E%8B%E6%85%8B.html#cb25-5" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>如果你不想要這種預設行為，整數型態提供你一些方法，這些方法共分4類</p>
<ol style="list-style-type: decimal">
<li>
<strong>checked_XXX()</strong>：返回Option<t>，若數學上正確的結果無法用該型態到值來表示，則返回None，否則返回Some(值)。</t>
</li>
</ol>
<div class="sourceCode" id="cb26"><pre class="sourceCode rust"><code class="sourceCode rust"><span id="cb26-1"><a href="day2---%E5%9E%8B%E6%85%8B.html#cb26-1" tabindex="-1"></a><span class="co">// 10+20=30，結果在u8的範圍內</span></span>
<span id="cb26-2"><a href="day2---%E5%9E%8B%E6%85%8B.html#cb26-2" tabindex="-1"></a><span class="pp">assert_eq!</span>(<span class="dv">10_u8</span><span class="op">.</span>checked_add(<span class="dv">20</span>)<span class="op">,</span> <span class="cn">Some</span>(<span class="dv">30</span>))<span class="op">;</span></span>
<span id="cb26-3"><a href="day2---%E5%9E%8B%E6%85%8B.html#cb26-3" tabindex="-1"></a></span>
<span id="cb26-4"><a href="day2---%E5%9E%8B%E6%85%8B.html#cb26-4" tabindex="-1"></a></span>
<span id="cb26-5"><a href="day2---%E5%9E%8B%E6%85%8B.html#cb26-5" tabindex="-1"></a><span class="co">// 255+1=256，結果超出u8的範圍</span></span>
<span id="cb26-6"><a href="day2---%E5%9E%8B%E6%85%8B.html#cb26-6" tabindex="-1"></a><span class="pp">assert_eq!</span>(<span class="dv">255_u8</span><span class="op">.</span>checked_add(<span class="dv">1</span>)<span class="op">,</span> <span class="cn">None</span>)<span class="op">;</span></span>
<span id="cb26-7"><a href="day2---%E5%9E%8B%E6%85%8B.html#cb26-7" tabindex="-1"></a></span>
<span id="cb26-8"><a href="day2---%E5%9E%8B%E6%85%8B.html#cb26-8" tabindex="-1"></a><span class="co">// 進行加法，當它溢位時panic</span></span>
<span id="cb26-9"><a href="day2---%E5%9E%8B%E6%85%8B.html#cb26-9" tabindex="-1"></a></span>
<span id="cb26-10"><a href="day2---%E5%9E%8B%E6%85%8B.html#cb26-10" tabindex="-1"></a><span class="kw">let</span> sum <span class="op">=</span> x<span class="op">.</span>checked_add(y)<span class="op">.</span>unwrap()<span class="op">;</span></span></code></pre></div>
<ol start="2" style="list-style-type: decimal">
<li>
<strong>wrapping_XXX()</strong>：返回值，當溢位時，返回「在數學上正確的結果」modulo「值得範圍」。</li>
</ol>
<div class="sourceCode" id="cb27"><pre class="sourceCode rust"><code class="sourceCode rust"><span id="cb27-1"><a href="day2---%E5%9E%8B%E6%85%8B.html#cb27-1" tabindex="-1"></a><span class="co">//第一個在範圍值內沒有問題</span></span>
<span id="cb27-2"><a href="day2---%E5%9E%8B%E6%85%8B.html#cb27-2" tabindex="-1"></a><span class="co">// 第二個超出範圍，因此我們獲得250000 modulo$2^16$。</span></span>
<span id="cb27-3"><a href="day2---%E5%9E%8B%E6%85%8B.html#cb27-3" tabindex="-1"></a><span class="pp">assert_eq!</span>(<span class="dv">10000_u16</span><span class="op">.</span>wrapping_mul(<span class="dv">200</span>)<span class="op">,</span> <span class="dv">250000</span>)<span class="op">;</span></span>
<span id="cb27-4"><a href="day2---%E5%9E%8B%E6%85%8B.html#cb27-4" tabindex="-1"></a><span class="pp">assert_eq!</span>(<span class="dv">10000_u16</span><span class="op">.</span>wrapping_mul(<span class="dv">500</span>)<span class="op">,</span> <span class="dv">250000</span>)<span class="op">;</span></span>
<span id="cb27-5"><a href="day2---%E5%9E%8B%E6%85%8B.html#cb27-5" tabindex="-1"></a></span>
<span id="cb27-6"><a href="day2---%E5%9E%8B%E6%85%8B.html#cb27-6" tabindex="-1"></a><span class="co">// 針對正負運算有可能wrap成負數</span></span>
<span id="cb27-7"><a href="day2---%E5%9E%8B%E6%85%8B.html#cb27-7" tabindex="-1"></a><span class="pp">assert_eq!</span>(<span class="dv">500_i16</span><span class="op">.</span>wrapping_sub(<span class="dv">1000</span>)<span class="op">,</span> <span class="op">-</span><span class="dv">500</span>)<span class="op">;</span></span></code></pre></div>
<p>這個法的優勢在於：他們在所有的buid裡面都會是相同的</p>
<ol start="3" style="list-style-type: decimal">
<li>
<strong>saturating_XXX()</strong>：返回值，當溢位時，返回最大或最小值，也就是計算結果被限制在該型態可以表示的最大與最小值範圍內</li>
</ol>
<div class="sourceCode" id="cb28"><pre class="sourceCode rust"><code class="sourceCode rust"><span id="cb28-1"><a href="day2---%E5%9E%8B%E6%85%8B.html#cb28-1" tabindex="-1"></a><span class="pp">assert_eq!</span>(<span class="dv">100_u8</span><span class="op">.</span>saturating_add(<span class="dv">200</span>)<span class="op">,</span> <span class="dv">255</span>)<span class="op">;</span></span>
<span id="cb28-2"><a href="day2---%E5%9E%8B%E6%85%8B.html#cb28-2" tabindex="-1"></a><span class="pp">assert_eq!</span>(<span class="dv">100_u8</span><span class="op">.</span>saturating_sub(<span class="dv">200</span>)<span class="op">,</span> <span class="dv">0</span>)<span class="op">;</span></span></code></pre></div>
<p>除法、餘數逐位元移位沒有saturating版本</p>
<ol start="4" style="list-style-type: decimal">
<li>
<strong>overflowing_XXX()</strong>：返回一個tuple，第一個元素是計算結果，第二個元素是一個bool，當溢位時，bool為true，否則為false。</li>
</ol>
<div class="sourceCode" id="cb29"><pre class="sourceCode rust"><code class="sourceCode rust"><span id="cb29-1"><a href="day2---%E5%9E%8B%E6%85%8B.html#cb29-1" tabindex="-1"></a><span class="pp">assert_eq!</span>(<span class="dv">100_u8</span><span class="op">.</span>overflowing_add(<span class="dv">200</span>)<span class="op">,</span> (<span class="dv">44</span><span class="op">,</span> <span class="cn">true</span>))<span class="op">;</span></span>
<span id="cb29-2"><a href="day2---%E5%9E%8B%E6%85%8B.html#cb29-2" tabindex="-1"></a><span class="pp">assert_eq!</span>(<span class="dv">100_u8</span><span class="op">.</span>overflowing_sub(<span class="dv">200</span>)<span class="op">,</span> (<span class="dv">156</span><span class="op">,</span> <span class="cn">true</span>))<span class="op">;</span></span></code></pre></div>
<p>overflowing在處理位元移動時稍有不同，他們的overflowed只會在移動距離與型態本身的位元寬或更大時才會回傳true，而實際的移動距離是你請求移動距離mod型態的位元寬度。</p>
<div class="sourceCode" id="cb30"><pre class="sourceCode rust"><code class="sourceCode rust"><span id="cb30-1"><a href="day2---%E5%9E%8B%E6%85%8B.html#cb30-1" tabindex="-1"></a><span class="co">// 移動17 bit對u16而言太大，而17 mod 16 = 1</span></span>
<span id="cb30-2"><a href="day2---%E5%9E%8B%E6%85%8B.html#cb30-2" tabindex="-1"></a><span class="pp">assert_eq!</span>(<span class="dv">100_u16</span><span class="op">.</span>overflowing_shl(<span class="dv">17</span>)<span class="op">,</span> (<span class="dv">200</span><span class="op">,</span> <span class="cn">true</span>))<span class="op">;</span></span></code></pre></div>
<div class="inline-table"><table class="table table-sm">
<tr>
<th>
運算
</th>
<th>
method前綴
</th>
<th>
範例
</th>
<th>
結果
</th>
</tr>
<tr>
<td>
加法
</td>
<td>
add
</td>
<td>
10_u8.checked_add(20)
</td>
<td>
Some(30)
</td>
</tr>
<tr>
<td>
減法
</td>
<td>
sub
</td>
<td>
10_u8.checked_sub(20)
</td>
<td>
None
</td>
</tr>
<tr>
<td>
乘法
</td>
<td>
mul
</td>
<td>
128_u8.wrapping_mul(3)
</td>
<td>
255
</td>
</tr>
<tr>
<td>
除法
</td>
<td>
div
</td>
<td>
64_u16.saturating_div(8)
</td>
<td>
8
</td>
</tr>
<tr>
<td>
餘數
</td>
<td>
rem
</td>
<td>
64_u16.overflowing_rem(8)
</td>
<td>
(0, false)
</td>
</tr>
<tr>
<td>
負數
</td>
<td>
neg
</td>
<td>
10_i8.neg()
</td>
<td>
-10
</td>
</tr>
<tr>
<td>
絕對值
</td>
<td>
abs
</td>
<td>
-10_i8.abs()
</td>
<td>
10
</td>
</tr>
<tr>
<td>
取冪
</td>
<td>
pow
</td>
<td>
2_u8.checked.pow(8)
</td>
<td>
Some(256)
</td>
</tr>
<tr>
<td>
位元右移
</td>
<td>
shr
</td>
<td>
40_u32.wrapping_shr(34)
</td>
<td>
10
</td>
</tr>
<tr>
<td>
位元左移
</td>
<td>
shl
</td>
<td>
10_u32.overflowing_shl(34)
</td>
<td>
(0, true)
</td>
</tr>
</table></div>
</div>
</div>
<div id="浮點數型態" class="section level2" number="3.2">
<h2>
<span class="header-section-number">3.2</span> 浮點數型態<a class="anchor" aria-label="anchor" href="#%E6%B5%AE%E9%BB%9E%E6%95%B8%E5%9E%8B%E6%85%8B"><i class="fas fa-link"></i></a>
</h2>
<p>一個非常標準的Rust浮點數長這樣：314.926e-4f64</p>
<p>整數：314<br>
小數：926<br>
指數：e-4<br>
後綴：f64</p>
<p>Rust的浮點數分為f32和f64，相當於Java的float和double，他們分別是32-bit和64-bit的IEEE754浮點數。</p>
<p>要讓編譯器知道值為浮點數，你不一定明文型態，但必須要有指數、小數點或後綴型態，如：5.就是合法的浮點數，但5不是。</p>
<p>如果沒有指定型態，但從脈絡可推斷為浮點數，則編譯器會推斷為f64。</p>
<p>f32與f64型態有一些關聯常數是IEEE規定的特殊值，例如INFINITY、NEG_INFINITY、NAN、MIN、MAX等。</p>
<div class="sourceCode" id="cb31"><pre class="sourceCode rust"><code class="sourceCode rust"><span id="cb31-1"><a href="day2---%E5%9E%8B%E6%85%8B.html#cb31-1" tabindex="-1"></a><span class="pp">assert_eq!</span>(<span class="dt">f32</span><span class="pp">::</span><span class="cn">INFINITY</span><span class="op">,</span> <span class="dv">1.0</span><span class="op">/</span><span class="dv">0.0</span>)<span class="op">;</span></span>
<span id="cb31-2"><a href="day2---%E5%9E%8B%E6%85%8B.html#cb31-2" tabindex="-1"></a><span class="pp">assert!</span>((<span class="op">-</span><span class="dv">1</span><span class="op">.</span> <span class="op">/</span> <span class="dt">f32</span><span class="pp">::</span><span class="cn">INFINITY</span>)<span class="op">.</span>is_sign_negative())<span class="op">;</span></span></code></pre></div>
<p>另外，浮點數也提供一些method，例如sqrt()是開根號，exp()是指數函數</p>
<div class="sourceCode" id="cb32"><pre class="sourceCode rust"><code class="sourceCode rust"><span id="cb32-1"><a href="day2---%E5%9E%8B%E6%85%8B.html#cb32-1" tabindex="-1"></a><span class="kw">let</span> x <span class="op">=</span> <span class="dv">2.0_f64</span><span class="op">.</span>exp()<span class="op">;</span></span>
<span id="cb32-2"><a href="day2---%E5%9E%8B%E6%85%8B.html#cb32-2" tabindex="-1"></a><span class="pp">assert_eq!</span>(x<span class="op">,</span> <span class="pp">std::</span><span class="dt">f64</span><span class="pp">::consts::</span>E<span class="op">.</span>powf(<span class="dv">2.0</span>))<span class="op">;</span></span>
<span id="cb32-3"><a href="day2---%E5%9E%8B%E6%85%8B.html#cb32-3" tabindex="-1"></a><span class="pp">assert_eq!</span>((<span class="op">-</span><span class="dv">1.22f64</span>)<span class="op">.</span>sqrt()<span class="op">,</span> <span class="pp">std::</span><span class="dt">f64</span><span class="pp">::</span><span class="cn">NAN</span>)<span class="op">;</span></span></code></pre></div>
<p>請注意，方法呼叫的順位比運算子高，因此在對帶負號的浮點數值做運算時，務必加括號。</p>
<p>Rust不會做隱性轉換，如果你丟給預期做浮點數運算的函式一個整數，Rust會大聲地抱怨給你聽，因此，請善用as關鍵字。雖然不做隱性運算會讓程式碼更加攏長，但這也減少許多bug的發生。</p>
<p>最後，std::f32::consts和std::f64::consts提供了一些常數，例如：PI、E、LOG2_E、LOG10_E、LN_2、LN_10等。</p>
</div>
<div id="布林型態" class="section level2" number="3.3">
<h2>
<span class="header-section-number">3.3</span> 布林型態<a class="anchor" aria-label="anchor" href="#%E5%B8%83%E6%9E%97%E5%9E%8B%E6%85%8B"><i class="fas fa-link"></i></a>
</h2>
<p>Rust的布林值，分為true和false，透過一些比較運算子產生</p>
<p>許多語言都為布林判斷偷偷開了後門，如C將字元、整數、指標等隱性轉換為布林值，讓你在if或while裡直接將他們當作條件。但Rust不准你這樣做，即使在短路邏輯用算子&amp;&amp;和||裡也不行。你必須寫出if x!=0{…}，而不是if x{…}。</p>
<p>但你可以可以用as運算子將bool轉換為整數型態，但數字不能反向轉換為布林值。</p>
<div class="sourceCode" id="cb33"><pre class="sourceCode rust"><code class="sourceCode rust"><span id="cb33-1"><a href="day2---%E5%9E%8B%E6%85%8B.html#cb33-1" tabindex="-1"></a><span class="pp">assert_eq!</span>(<span class="cn">true</span> <span class="kw">as</span> <span class="dt">i32</span><span class="op">,</span> <span class="dv">1</span>)<span class="op">;</span></span>
<span id="cb33-2"><a href="day2---%E5%9E%8B%E6%85%8B.html#cb33-2" tabindex="-1"></a><span class="pp">assert_eq!</span>(<span class="cn">false</span> <span class="kw">as</span> <span class="dt">i32</span><span class="op">,</span> <span class="dv">0</span>)<span class="op">;</span></span></code></pre></div>
</div>
<div id="tuple型態" class="section level2" number="3.4">
<h2>
<span class="header-section-number">3.4</span> tuple型態<a class="anchor" aria-label="anchor" href="#tuple%E5%9E%8B%E6%85%8B"><i class="fas fa-link"></i></a>
</h2>
<p>tuple可以是一對、三個、四個各種不同型態的值組合成的值</p>
<p>例：(“Taipei”, 25, 100.0)這個tuple的型態是(&amp;str, i32, f64)，你可以用tuple.0、tuple.1、tuple.2來取得裡面的值。</p>
<p>但可惜你只能用常數來獲取值，而非變數，如tuple.0是合法的，但tuple.i是不合法的。</p>
<div class="sourceCode" id="cb34"><pre class="sourceCode rust"><code class="sourceCode rust"><span id="cb34-1"><a href="day2---%E5%9E%8B%E6%85%8B.html#cb34-1" tabindex="-1"></a><span class="kw">let</span> tuple <span class="op">=</span> (<span class="st">"Taipei"</span><span class="op">,</span> <span class="dv">25</span><span class="op">,</span> <span class="dv">100.0</span>)<span class="op">;</span></span>
<span id="cb34-2"><a href="day2---%E5%9E%8B%E6%85%8B.html#cb34-2" tabindex="-1"></a>tuple<span class="op">.</span><span class="dv">0</span></span>
<span id="cb34-3"><a href="day2---%E5%9E%8B%E6%85%8B.html#cb34-3" tabindex="-1"></a>#<span class="op">&gt;</span> [<span class="dv">1</span>] <span class="st">"Taipei"</span></span></code></pre></div>
<p>這樣的tuple型態在rust中通常來幫函式回傳多個值，假如你有一個string slice要處理，你可以使用split_at()，這個函式會回傳一個tuple，裡面包含了兩個string slice，分別是原始string slice的前半部和後半部。</p>
<p>該宣告式應該長這樣<code>fn split_at(&amp;self, mid: usize) -&gt; (&amp;str, &amp;str)</code>，你可以用let (first, second) = s.split_at(3);來取得這兩個string slice。</p>
<div class="sourceCode" id="cb35"><pre class="sourceCode rust"><code class="sourceCode rust"><span id="cb35-1"><a href="day2---%E5%9E%8B%E6%85%8B.html#cb35-1" tabindex="-1"></a><span class="kw">let</span> s <span class="op">=</span> <span class="st">"Taipei"</span><span class="op">;</span></span>
<span id="cb35-2"><a href="day2---%E5%9E%8B%E6%85%8B.html#cb35-2" tabindex="-1"></a><span class="kw">let</span> (first<span class="op">,</span> second) <span class="op">=</span> s<span class="op">.</span>split_at(<span class="dv">3</span>)<span class="op">;</span></span>
<span id="cb35-3"><a href="day2---%E5%9E%8B%E6%85%8B.html#cb35-3" tabindex="-1"></a><span class="pp">rprintln!</span>(<span class="st">"{} {}"</span><span class="op">,</span> first<span class="op">,</span> second)<span class="op">;</span></span>
<span id="cb35-4"><a href="day2---%E5%9E%8B%E6%85%8B.html#cb35-4" tabindex="-1"></a>#<span class="op">&gt;</span> Tai pei</span></code></pre></div>
<p>我們常常不自覺的使用tuple，例如我們想要將一個file的檔名(&amp;str,pixel(u8),和長寬(usize, usize)，最正規的是寫一個struct，但若作為過渡的資料結構，tuple為你做簡單明確的橋樑。</p>
<div class="sourceCode" id="cb36"><pre class="sourceCode rust"><code class="sourceCode rust"><span id="cb36-1"><a href="day2---%E5%9E%8B%E6%85%8B.html#cb36-1" tabindex="-1"></a><span class="kw">fn</span> write_image(filename<span class="op">:</span> <span class="op">&amp;</span><span class="dt">str</span><span class="op">,</span> pixels<span class="op">:</span> <span class="op">&amp;</span>[<span class="dt">u8</span>]<span class="op">,</span> width<span class="op">:</span> <span class="dt">usize</span><span class="op">,</span> height<span class="op">:</span> <span class="dt">usize</span>)</span></code></pre></div>
<p>另外一種是當作零tuple，也稱單元型態，只有一個值，寫成()。他出現在Rust需要某種型態，但又缺乏有意義的值可以使用。</p>
<p>例如，不回傳值的函式回傳型態有些回傳這個型態，在std::men::swap函式中，沒有「有意義」的回傳值，而是單純的交換兩個變數的值，他的宣告式如下：</p>
<div class="sourceCode" id="cb37"><pre class="sourceCode rust"><code class="sourceCode rust"><span id="cb37-1"><a href="day2---%E5%9E%8B%E6%85%8B.html#cb37-1" tabindex="-1"></a><span class="co">//&lt;T&gt;代表swap的「泛型」，可以處理任何型態的T參考值。</span></span>
<span id="cb37-2"><a href="day2---%E5%9E%8B%E6%85%8B.html#cb37-2" tabindex="-1"></a><span class="kw">fn</span> swap<span class="op">&lt;</span>T<span class="op">&gt;</span>(x<span class="op">:</span> <span class="op">&amp;</span><span class="kw">mut</span> T<span class="op">,</span> y<span class="op">:</span> <span class="op">&amp;</span><span class="kw">mut</span> T)</span>
<span id="cb37-3"><a href="day2---%E5%9E%8B%E6%85%8B.html#cb37-3" tabindex="-1"></a><span class="co">//其實有回傳()，但寫的時候省略</span></span></code></pre></div>
<p>另外我們常寫的<code>Result&lt;(), std::io::Error&gt;</code>，出錯時回傳std::io::Error的值，而成功則不回傳有意義的值。</p>
</div>
<div id="指標型態" class="section level2" number="3.5">
<h2>
<span class="header-section-number">3.5</span> 指標型態<a class="anchor" aria-label="anchor" href="#%E6%8C%87%E6%A8%99%E5%9E%8B%E6%85%8B"><i class="fas fa-link"></i></a>
</h2>
<p>Rust有幾種代表記憶體地址的型態，這是Rust和具備垃圾桶(garbage collection:記憶體回收)機制的語言之巨大差異，也是Rust看似繁瑣的型態系統的一部分。</p>
<p>在Java中，如果class Rectangle中Vector2D upperleft; upperleft是分別建立的另一個Vector2D物件的參考，Java物件內部絕對不會有實際的其他物件。</p>
<p>而Rust為管理並減少記憶體配置，在預設情況，值是崁套的，假設一個((0,0), (144, 122))值存成4個相鄰的整數。如果你將它存入一個區域變數，你會得到一個寬為四個整數的「區域變數」。Rust不會在heap上配置記憶體，除非你明確要求。</p>
<p>這樣的做法是記憶體友好的，但如果要讓一個值指向另一個值，你必須明確的使用指標。強大的是，在safe Rust裡的標型態都受到約束，以消除為定義行為。</p>
<div id="reference" class="section level3" number="3.5.1">
<h3>
<span class="header-section-number">3.5.1</span> Reference<a class="anchor" aria-label="anchor" href="#reference"><i class="fas fa-link"></i></a>
</h3>
<p>在入門段，我們常常使用簡單的ref來做參考，在執行期，一個指向i32的參考是一個機器word，保存的是i32的「地址」，該位子可能在stack也可能在heap。</p>
<p>運算式&amp;x產生一個指向x的參考，而*ptr則是取得ptr指向的值。多提一嘴，Rust參考絕對不會是null，並會記錄所有權與生命期，諸如懸空指標、重複釋出與無效指標的會在編譯期被排除。</p>
<p>兩種參考型態：</p>
<ol style="list-style-type: decimal">
<li><p>&amp;T：不可變參考，你不能透過它來修改值。一個值可以有多個共享參考</p></li>
<li><p>&amp;mut T：可變參考，你可以透過它來修改值。一個值只能有一個可變參考，且在該參考存在期間，不可有其他參考存在。</p></li>
</ol>
<p>這兩種區別在編譯器檢查與執行時，可以確保程式的安全。</p>
</div>
<div id="box" class="section level3" number="3.5.2">
<h3>
<span class="header-section-number">3.5.2</span> Box<a class="anchor" aria-label="anchor" href="#box"><i class="fas fa-link"></i></a>
</h3>
<p>若你想在heap上配置值，最簡單的就是呼叫Box::new()</p>
<div class="sourceCode" id="cb38"><pre class="sourceCode rust"><code class="sourceCode rust"><span id="cb38-1"><a href="day2---%E5%9E%8B%E6%85%8B.html#cb38-1" tabindex="-1"></a><span class="kw">let</span> x <span class="op">=</span> <span class="dv">10</span><span class="op">;</span></span>
<span id="cb38-2"><a href="day2---%E5%9E%8B%E6%85%8B.html#cb38-2" tabindex="-1"></a><span class="kw">let</span> b <span class="op">=</span> <span class="dt">Box</span><span class="pp">::</span>new(x)<span class="op">;</span><span class="co">// 在heap上配置一個i32</span></span>
<span id="cb38-3"><a href="day2---%E5%9E%8B%E6%85%8B.html#cb38-3" tabindex="-1"></a></span>
<span id="cb38-4"><a href="day2---%E5%9E%8B%E6%85%8B.html#cb38-4" tabindex="-1"></a><span class="kw">let</span> c <span class="op">=</span> <span class="op">*</span>b<span class="op">;</span><span class="co">// 取得b指向的值</span></span>
<span id="cb38-5"><a href="day2---%E5%9E%8B%E6%85%8B.html#cb38-5" tabindex="-1"></a><span class="kw">let</span> z <span class="op">=</span> <span class="op">&amp;</span>b<span class="op">;</span><span class="co">// 取得b的參考</span></span>
<span id="cb38-6"><a href="day2---%E5%9E%8B%E6%85%8B.html#cb38-6" tabindex="-1"></a></span>
<span id="cb38-7"><a href="day2---%E5%9E%8B%E6%85%8B.html#cb38-7" tabindex="-1"></a><span class="pp">rprintln!</span>(<span class="st">"{} {} {}"</span><span class="op">,</span> c<span class="op">,</span> b<span class="op">,</span> z)<span class="op">;</span></span>
<span id="cb38-8"><a href="day2---%E5%9E%8B%E6%85%8B.html#cb38-8" tabindex="-1"></a></span>
<span id="cb38-9"><a href="day2---%E5%9E%8B%E6%85%8B.html#cb38-9" tabindex="-1"></a>#<span class="op">&gt;</span> <span class="dv">10</span> <span class="dv">10</span> <span class="dv">10</span></span></code></pre></div>
<p>b的型態是Box<i32>，當b離開作用域時，記憶體會被立刻釋出，除非<strong>移動</strong>，例如被回傳。移動是Rust非常重要的概念會提到，我們會在後面章節詳細介紹。</i32></p>
</div>
<div id="原始指標" class="section level3" number="3.5.3">
<h3>
<span class="header-section-number">3.5.3</span> 原始指標<a class="anchor" aria-label="anchor" href="#%E5%8E%9F%E5%A7%8B%E6%8C%87%E6%A8%99"><i class="fas fa-link"></i></a>
</h3>
<p>原始指標像C++同款，這在Rust是unsafe的，因爲程式不會追蹤它，因此他容易出錯，例如指向null或未初始化的記憶體。</p>
</div>
<div id="陣列" class="section level3" number="3.5.4">
<h3>
<span class="header-section-number">3.5.4</span> 陣列<a class="anchor" aria-label="anchor" href="#%E9%99%A3%E5%88%97"><i class="fas fa-link"></i></a>
</h3>
<p>陣列的型態是[T; N]，T就像前面所述代表<strong>型態</strong>，N是<strong>長度</strong>，大小是執行期決定的常數，不能擴增或縮減。</p>
<p>陣列有多種寫法，最簡單也常見的就是放在中括號裡</p>
<div class="sourceCode" id="cb39"><pre class="sourceCode rust"><code class="sourceCode rust"><span id="cb39-1"><a href="day2---%E5%9E%8B%E6%85%8B.html#cb39-1" tabindex="-1"></a><span class="kw">let</span> a [<span class="dt">u8</span><span class="op">;</span> <span class="dv">3</span>] <span class="op">=</span> [<span class="dv">1</span><span class="op">,</span> <span class="dv">2</span><span class="op">,</span> <span class="dv">3</span>]<span class="op">;</span></span></code></pre></div>
<p>如果要寫一個長陣列，裏面放差不多的值，可以寫成[V; N]，V是值，N是長度，例如：</p>
<div class="sourceCode" id="cb40"><pre class="sourceCode rust"><code class="sourceCode rust"><span id="cb40-1"><a href="day2---%E5%9E%8B%E6%85%8B.html#cb40-1" tabindex="-1"></a>[<span class="dv">0_u8</span><span class="op">;</span> <span class="dv">1024</span>]</span></code></pre></div>
<p>有些時候會用這種方法代表緩衝區，如上例就是1KB的緩衝區。</p>
<p>如上述，因爲判斷長度在編譯期就是固定的，所以你不能用變數n來產生有n個值的陣列。</p>
<p>陣列的方法其實都是Rust偷偷將陣列的參考轉換成silce，因此你才能在陣列上使用slice的方法。</p>
<div class="sourceCode" id="cb41"><pre class="sourceCode rust"><code class="sourceCode rust"><span id="cb41-1"><a href="day2---%E5%9E%8B%E6%85%8B.html#cb41-1" tabindex="-1"></a><span class="kw">let</span> <span class="kw">mut</span> a <span class="op">=</span> [<span class="dv">5</span><span class="op">,</span> <span class="dv">4</span><span class="op">,</span> <span class="dv">3</span><span class="op">,</span> <span class="dv">2</span><span class="op">,</span> <span class="dv">1</span>]<span class="op">;</span></span>
<span id="cb41-2"><a href="day2---%E5%9E%8B%E6%85%8B.html#cb41-2" tabindex="-1"></a></span>
<span id="cb41-3"><a href="day2---%E5%9E%8B%E6%85%8B.html#cb41-3" tabindex="-1"></a>a<span class="op">.</span>sort()<span class="op">;</span></span>
<span id="cb41-4"><a href="day2---%E5%9E%8B%E6%85%8B.html#cb41-4" tabindex="-1"></a></span>
<span id="cb41-5"><a href="day2---%E5%9E%8B%E6%85%8B.html#cb41-5" tabindex="-1"></a><span class="cf">for</span> x <span class="kw">in</span> a <span class="op">{</span></span>
<span id="cb41-6"><a href="day2---%E5%9E%8B%E6%85%8B.html#cb41-6" tabindex="-1"></a>  <span class="pp">rprintln!</span>(<span class="st">"{}"</span><span class="op">,</span> x)<span class="op">;</span></span>
<span id="cb41-7"><a href="day2---%E5%9E%8B%E6%85%8B.html#cb41-7" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb41-8"><a href="day2---%E5%9E%8B%E6%85%8B.html#cb41-8" tabindex="-1"></a>#<span class="op">&gt;</span> <span class="dv">1</span></span>
<span id="cb41-9"><a href="day2---%E5%9E%8B%E6%85%8B.html#cb41-9" tabindex="-1"></a>#<span class="op">&gt;</span> <span class="dv">2</span></span>
<span id="cb41-10"><a href="day2---%E5%9E%8B%E6%85%8B.html#cb41-10" tabindex="-1"></a>#<span class="op">&gt;</span> <span class="dv">3</span></span>
<span id="cb41-11"><a href="day2---%E5%9E%8B%E6%85%8B.html#cb41-11" tabindex="-1"></a>#<span class="op">&gt;</span> <span class="dv">4</span></span>
<span id="cb41-12"><a href="day2---%E5%9E%8B%E6%85%8B.html#cb41-12" tabindex="-1"></a>#<span class="op">&gt;</span> <span class="dv">5</span></span>
<span id="cb41-13"><a href="day2---%E5%9E%8B%E6%85%8B.html#cb41-13" tabindex="-1"></a>#<span class="op">&gt;</span> NULL</span></code></pre></div>
</div>
<div id="向量" class="section level3" number="3.5.5">
<h3>
<span class="header-section-number">3.5.5</span> 向量<a class="anchor" aria-label="anchor" href="#%E5%90%91%E9%87%8F"><i class="fas fa-link"></i></a>
</h3>
<p>最原始的向量是長這樣ＬVec<t>，看到了嗎，只有型態沒長度，這代表你可以隨著時變去改變大小，他會在heap上配置記憶體，並且會在不需要時自動釋放。</t></p>
<p>如果你知道向量的長度，你可以用vec!宏來建立，例如：</p>
<div class="sourceCode" id="cb42"><pre class="sourceCode rust"><code class="sourceCode rust"><span id="cb42-1"><a href="day2---%E5%9E%8B%E6%85%8B.html#cb42-1" tabindex="-1"></a><span class="kw">let</span> vec <span class="op">=</span> <span class="pp">vec!</span>[<span class="dv">1</span><span class="op">,</span> <span class="dv">2</span><span class="op">,</span> <span class="dv">3</span><span class="op">,</span> <span class="dv">4</span><span class="op">,</span> <span class="dv">5</span>]<span class="op">;</span></span></code></pre></div>
<p>因為他是向量，你可以繼續加入值：</p>
<div class="sourceCode" id="cb43"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu">vec.push</span><span class="op">(</span><span class="fl">6</span><span class="op">)</span>;</span></code></pre></div>
<p>另外一種方式是呼叫Vec::new()來產生新的向量，然後用push()來加入值。</p>
<div class="sourceCode" id="cb44"><pre class="sourceCode rust"><code class="sourceCode rust"><span id="cb44-1"><a href="day2---%E5%9E%8B%E6%85%8B.html#cb44-1" tabindex="-1"></a><span class="kw">let</span> <span class="kw">mut</span> vec <span class="op">=</span> <span class="dt">Vec</span><span class="pp">::</span>new()<span class="op">;</span></span>
<span id="cb44-2"><a href="day2---%E5%9E%8B%E6%85%8B.html#cb44-2" tabindex="-1"></a>vec<span class="op">.</span>push(<span class="dv">1</span>)<span class="op">;</span></span>
<span id="cb44-3"><a href="day2---%E5%9E%8B%E6%85%8B.html#cb44-3" tabindex="-1"></a>vec<span class="op">.</span>push(<span class="dv">2</span>)<span class="op">;</span></span></code></pre></div>
<p>也可以用iterator產的生的值來建立向量，例如：</p>
<div class="sourceCode" id="cb45"><pre class="sourceCode rust"><code class="sourceCode rust"><span id="cb45-1"><a href="day2---%E5%9E%8B%E6%85%8B.html#cb45-1" tabindex="-1"></a><span class="kw">let</span> a <span class="op">=</span> [<span class="dv">5</span><span class="op">,</span> <span class="dv">4</span><span class="op">,</span> <span class="dv">3</span><span class="op">,</span> <span class="dv">2</span><span class="op">,</span> <span class="dv">1</span>]<span class="op">;</span></span>
<span id="cb45-2"><a href="day2---%E5%9E%8B%E6%85%8B.html#cb45-2" tabindex="-1"></a><span class="kw">let</span> <span class="kw">mut</span> vec <span class="op">=</span> <span class="dt">Vec</span><span class="pp">::</span>new()<span class="op">;</span></span>
<span id="cb45-3"><a href="day2---%E5%9E%8B%E6%85%8B.html#cb45-3" tabindex="-1"></a></span>
<span id="cb45-4"><a href="day2---%E5%9E%8B%E6%85%8B.html#cb45-4" tabindex="-1"></a><span class="cf">for</span> x <span class="kw">in</span> a <span class="op">{</span></span>
<span id="cb45-5"><a href="day2---%E5%9E%8B%E6%85%8B.html#cb45-5" tabindex="-1"></a>  vec<span class="op">.</span>push(x)<span class="op">;</span></span>
<span id="cb45-6"><a href="day2---%E5%9E%8B%E6%85%8B.html#cb45-6" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb45-7"><a href="day2---%E5%9E%8B%E6%85%8B.html#cb45-7" tabindex="-1"></a></span>
<span id="cb45-8"><a href="day2---%E5%9E%8B%E6%85%8B.html#cb45-8" tabindex="-1"></a><span class="cf">for</span> x <span class="kw">in</span> vec <span class="op">{</span></span>
<span id="cb45-9"><a href="day2---%E5%9E%8B%E6%85%8B.html#cb45-9" tabindex="-1"></a>  <span class="pp">rprintln!</span>(<span class="st">"{}"</span><span class="op">,</span> x)<span class="op">;</span></span>
<span id="cb45-10"><a href="day2---%E5%9E%8B%E6%85%8B.html#cb45-10" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb45-11"><a href="day2---%E5%9E%8B%E6%85%8B.html#cb45-11" tabindex="-1"></a>#<span class="op">&gt;</span> <span class="dv">5</span></span>
<span id="cb45-12"><a href="day2---%E5%9E%8B%E6%85%8B.html#cb45-12" tabindex="-1"></a>#<span class="op">&gt;</span> <span class="dv">4</span></span>
<span id="cb45-13"><a href="day2---%E5%9E%8B%E6%85%8B.html#cb45-13" tabindex="-1"></a>#<span class="op">&gt;</span> <span class="dv">3</span></span>
<span id="cb45-14"><a href="day2---%E5%9E%8B%E6%85%8B.html#cb45-14" tabindex="-1"></a>#<span class="op">&gt;</span> <span class="dv">2</span></span>
<span id="cb45-15"><a href="day2---%E5%9E%8B%E6%85%8B.html#cb45-15" tabindex="-1"></a>#<span class="op">&gt;</span> <span class="dv">1</span></span>
<span id="cb45-16"><a href="day2---%E5%9E%8B%E6%85%8B.html#cb45-16" tabindex="-1"></a>#<span class="op">&gt;</span> NULL</span></code></pre></div>
<p>向陣列一樣，向量也會找到slice的方法。</p>
<p>如果你事先知道向量的長度，你可以使用Vec::with_capacity()來代替Vec::new()，這樣預先留下夠大的緩衝區，可以減少向量擴增時的記憶體配置次數。</p>
<p>在設計函式時常常用到這樣的優勢，如colloect()，iterator會事先知道向量有幾個值，以正確的預先配置回傳向量。</p>
<p>向量的<strong>len()</strong>會告訴你向量的長度，<strong>capacity()</strong>會告訴你在不重新配置的情況下可以容納的元素。</p>
<div class="sourceCode" id="cb46"><pre class="sourceCode rust"><code class="sourceCode rust"><span id="cb46-1"><a href="day2---%E5%9E%8B%E6%85%8B.html#cb46-1" tabindex="-1"></a><span class="kw">let</span> <span class="kw">mut</span> vec <span class="op">=</span> <span class="dt">Vec</span><span class="pp">::</span>with_capacity(<span class="dv">2</span>)<span class="op">;</span></span>
<span id="cb46-2"><a href="day2---%E5%9E%8B%E6%85%8B.html#cb46-2" tabindex="-1"></a><span class="pp">rprintln!</span>(<span class="st">"len:{}, capacity:{}"</span><span class="op">,</span> vec<span class="op">.</span>len()<span class="op">,</span> vec<span class="op">.</span>capacity())<span class="op">;</span></span>
<span id="cb46-3"><a href="day2---%E5%9E%8B%E6%85%8B.html#cb46-3" tabindex="-1"></a></span>
<span id="cb46-4"><a href="day2---%E5%9E%8B%E6%85%8B.html#cb46-4" tabindex="-1"></a>vec<span class="op">.</span>push(<span class="dv">1</span>)<span class="op">;</span></span>
<span id="cb46-5"><a href="day2---%E5%9E%8B%E6%85%8B.html#cb46-5" tabindex="-1"></a>vec<span class="op">.</span>push(<span class="dv">2</span>)<span class="op">;</span></span>
<span id="cb46-6"><a href="day2---%E5%9E%8B%E6%85%8B.html#cb46-6" tabindex="-1"></a><span class="pp">rprintln!</span>(<span class="st">"len:{}, capacity:{}"</span><span class="op">,</span> vec<span class="op">.</span>len()<span class="op">,</span> vec<span class="op">.</span>capacity())<span class="op">;</span></span>
<span id="cb46-7"><a href="day2---%E5%9E%8B%E6%85%8B.html#cb46-7" tabindex="-1"></a></span>
<span id="cb46-8"><a href="day2---%E5%9E%8B%E6%85%8B.html#cb46-8" tabindex="-1"></a>vec<span class="op">.</span>push(<span class="dv">3</span>)<span class="op">;</span></span>
<span id="cb46-9"><a href="day2---%E5%9E%8B%E6%85%8B.html#cb46-9" tabindex="-1"></a><span class="pp">rprintln!</span>(<span class="st">"len:{}, capacity:{}"</span><span class="op">,</span> vec<span class="op">.</span>len()<span class="op">,</span> vec<span class="op">.</span>capacity())<span class="op">;</span></span>
<span id="cb46-10"><a href="day2---%E5%9E%8B%E6%85%8B.html#cb46-10" tabindex="-1"></a></span>
<span id="cb46-11"><a href="day2---%E5%9E%8B%E6%85%8B.html#cb46-11" tabindex="-1"></a>#<span class="op">&gt;</span> len<span class="op">:</span><span class="dv">0</span><span class="op">,</span> capacity<span class="op">:</span><span class="dv">2</span></span>
<span id="cb46-12"><a href="day2---%E5%9E%8B%E6%85%8B.html#cb46-12" tabindex="-1"></a>#<span class="op">&gt;</span> len<span class="op">:</span><span class="dv">2</span><span class="op">,</span> capacity<span class="op">:</span><span class="dv">2</span></span>
<span id="cb46-13"><a href="day2---%E5%9E%8B%E6%85%8B.html#cb46-13" tabindex="-1"></a>#<span class="op">&gt;</span> len<span class="op">:</span><span class="dv">3</span><span class="op">,</span> capacity<span class="op">:</span><span class="dv">4</span></span></code></pre></div>
<p>你可以用<strong>insert(位置, 值)</strong>來插入元素，用<strong>remove(位置)</strong>來移除元素</p>
<div class="sourceCode" id="cb47"><pre class="sourceCode rust"><code class="sourceCode rust"><span id="cb47-1"><a href="day2---%E5%9E%8B%E6%85%8B.html#cb47-1" tabindex="-1"></a><span class="kw">let</span> <span class="kw">mut</span> vec <span class="op">=</span> <span class="pp">vec!</span>[<span class="dv">1</span><span class="op">,</span> <span class="dv">2</span><span class="op">,</span> <span class="dv">3</span><span class="op">,</span> <span class="dv">4</span><span class="op">,</span> <span class="dv">5</span>]<span class="op">;</span></span>
<span id="cb47-2"><a href="day2---%E5%9E%8B%E6%85%8B.html#cb47-2" tabindex="-1"></a></span>
<span id="cb47-3"><a href="day2---%E5%9E%8B%E6%85%8B.html#cb47-3" tabindex="-1"></a><span class="co">//在1與2之間插入0</span></span>
<span id="cb47-4"><a href="day2---%E5%9E%8B%E6%85%8B.html#cb47-4" tabindex="-1"></a>vec<span class="op">.</span>insert(<span class="dv">1</span><span class="op">,</span> <span class="dv">0</span>)<span class="op">;</span></span>
<span id="cb47-5"><a href="day2---%E5%9E%8B%E6%85%8B.html#cb47-5" tabindex="-1"></a></span>
<span id="cb47-6"><a href="day2---%E5%9E%8B%E6%85%8B.html#cb47-6" tabindex="-1"></a><span class="co">//移除3</span></span>
<span id="cb47-7"><a href="day2---%E5%9E%8B%E6%85%8B.html#cb47-7" tabindex="-1"></a>vec<span class="op">.</span>remove(<span class="dv">3</span>)<span class="op">;</span></span>
<span id="cb47-8"><a href="day2---%E5%9E%8B%E6%85%8B.html#cb47-8" tabindex="-1"></a></span>
<span id="cb47-9"><a href="day2---%E5%9E%8B%E6%85%8B.html#cb47-9" tabindex="-1"></a><span class="pp">rprintln!</span>(<span class="st">"{:?}"</span><span class="op">,</span> vec)<span class="op">;</span></span>
<span id="cb47-10"><a href="day2---%E5%9E%8B%E6%85%8B.html#cb47-10" tabindex="-1"></a>#<span class="op">&gt;</span> [<span class="dv">1</span><span class="op">,</span> <span class="dv">0</span><span class="op">,</span> <span class="dv">2</span><span class="op">,</span> <span class="dv">4</span><span class="op">,</span> <span class="dv">5</span>]</span></code></pre></div>
<p>最後介紹<strong>pop()</strong>，他會從Vec<t> pop值會得到Option<t>，如果最後一個值是v，則回傳Some(v)，否則回傳None。</t></t></p>
<div class="sourceCode" id="cb48"><pre class="sourceCode rust"><code class="sourceCode rust"><span id="cb48-1"><a href="day2---%E5%9E%8B%E6%85%8B.html#cb48-1" tabindex="-1"></a><span class="kw">let</span> <span class="kw">mut</span> vec <span class="op">=</span> <span class="pp">vec!</span>[<span class="st">"哈囉"</span><span class="op">,</span> <span class="st">"世界"</span>]<span class="op">;</span></span>
<span id="cb48-2"><a href="day2---%E5%9E%8B%E6%85%8B.html#cb48-2" tabindex="-1"></a></span>
<span id="cb48-3"><a href="day2---%E5%9E%8B%E6%85%8B.html#cb48-3" tabindex="-1"></a><span class="pp">rprintln!</span>(<span class="st">"{:?}"</span><span class="op">,</span> vec<span class="op">.</span>pop())<span class="op">;</span></span>
<span id="cb48-4"><a href="day2---%E5%9E%8B%E6%85%8B.html#cb48-4" tabindex="-1"></a><span class="pp">rprintln!</span>(<span class="st">"{:?}"</span><span class="op">,</span> vec<span class="op">.</span>pop())<span class="op">;</span></span>
<span id="cb48-5"><a href="day2---%E5%9E%8B%E6%85%8B.html#cb48-5" tabindex="-1"></a><span class="pp">rprintln!</span>(<span class="st">"{:?}"</span><span class="op">,</span> vec<span class="op">.</span>pop())<span class="op">;</span></span>
<span id="cb48-6"><a href="day2---%E5%9E%8B%E6%85%8B.html#cb48-6" tabindex="-1"></a>#<span class="op">&gt;</span> <span class="cn">Some</span>(<span class="st">"世界"</span>)</span>
<span id="cb48-7"><a href="day2---%E5%9E%8B%E6%85%8B.html#cb48-7" tabindex="-1"></a>#<span class="op">&gt;</span> <span class="cn">Some</span>(<span class="st">"哈囉"</span>)</span>
<span id="cb48-8"><a href="day2---%E5%9E%8B%E6%85%8B.html#cb48-8" tabindex="-1"></a>#<span class="op">&gt;</span> <span class="cn">None</span></span></code></pre></div>
<div class="sourceCode" id="cb49"><pre class="sourceCode rust"><code class="sourceCode rust"><span id="cb49-1"><a href="day2---%E5%9E%8B%E6%85%8B.html#cb49-1" tabindex="-1"></a><span class="kw">use</span> <span class="pp">std::process::</span>Command<span class="op">;</span></span>
<span id="cb49-2"><a href="day2---%E5%9E%8B%E6%85%8B.html#cb49-2" tabindex="-1"></a></span>
<span id="cb49-3"><a href="day2---%E5%9E%8B%E6%85%8B.html#cb49-3" tabindex="-1"></a><span class="kw">let</span> <span class="kw">mut</span> cmd <span class="op">=</span> <span class="pp">Command::</span>new(<span class="st">"ls"</span>)<span class="op">;</span></span>
<span id="cb49-4"><a href="day2---%E5%9E%8B%E6%85%8B.html#cb49-4" tabindex="-1"></a><span class="kw">let</span> res <span class="op">=</span> cmd<span class="op">.</span>output()<span class="op">;</span></span>
<span id="cb49-5"><a href="day2---%E5%9E%8B%E6%85%8B.html#cb49-5" tabindex="-1"></a><span class="pp">rprintln!</span>(<span class="st">"{:?}"</span><span class="op">,</span> res)<span class="op">;</span></span>
<span id="cb49-6"><a href="day2---%E5%9E%8B%E6%85%8B.html#cb49-6" tabindex="-1"></a>#<span class="op">&gt;</span> <span class="cn">Ok</span>(Output <span class="op">{</span> status<span class="op">:</span> ExitStatus(unix_wait_status(<span class="dv">0</span>))<span class="op">,</span> stdout<span class="op">:</span> <span class="st">"01-Day1.Rmd</span><span class="sc">\n</span><span class="st">01-Day1.md</span><span class="sc">\n</span><span class="st">02-Day2.Rmd</span><span class="sc">\n</span><span class="st">03-Day3.Rmd</span><span class="sc">\n</span><span class="st">04-Day04.Rmd</span><span class="sc">\n</span><span class="st">05-Day5.Rmd</span><span class="sc">\n</span><span class="st">06-Day06.Rmd</span><span class="sc">\n</span><span class="st">07-.Rmd</span><span class="sc">\n</span><span class="st">08-結構.Rmd</span><span class="sc">\n</span><span class="st">09.Rmd</span><span class="sc">\n</span><span class="st">10-Day10.Rmd</span><span class="sc">\n</span><span class="st">11-closure.Rmd</span><span class="sc">\n</span><span class="st">12-Iterator.Rmd</span><span class="sc">\n</span><span class="st">13-集合.Rmd</span><span class="sc">\n</span><span class="st">README.md</span><span class="sc">\n</span><span class="st">Rust書.Rproj</span><span class="sc">\n</span><span class="st">Rust書.rds</span><span class="sc">\n</span><span class="st">UntitledRMD.Rmd</span><span class="sc">\n</span><span class="st">_book</span><span class="sc">\n</span><span class="st">_bookdown.yml</span><span class="sc">\n</span><span class="st">_common.R</span><span class="sc">\n</span><span class="st">_output.yml</span><span class="sc">\n</span><span class="st">actix</span><span class="sc">\n</span><span class="st">artist</span><span class="sc">\n</span><span class="st">book.bib</span><span class="sc">\n</span><span class="st">chicago-fullnote-bibliography.csl</span><span class="sc">\n</span><span class="st">doc.png</span><span class="sc">\n</span><span class="st">dst</span><span class="sc">\n</span><span class="st">fern_sim</span><span class="sc">\n</span><span class="st">firedata</span><span class="sc">\n</span><span class="st">guess</span><span class="sc">\n</span><span class="st">health</span><span class="sc">\n</span><span class="st">index.Rmd</span><span class="sc">\n</span><span class="st">index.md</span><span class="sc">\n</span><span class="st">jason</span><span class="sc">\n</span><span class="st">mandelbort</span><span class="sc">\n</span><span class="st">packages.bib</span><span class="sc">\n</span><span class="st">preamble.tex</span><span class="sc">\n</span><span class="st">render136b12b6d2f5c.rds</span><span class="sc">\n</span><span class="st">render176a9e828c7a.rds</span><span class="sc">\n</span><span class="st">src</span><span class="sc">\n</span><span class="st">style.css</span><span class="sc">\n</span><span class="st">teer</span><span class="sc">\n</span><span class="st">www</span><span class="sc">\n</span><span class="st">"</span><span class="op">,</span> stderr<span class="op">:</span> <span class="st">""</span> <span class="op">}</span>)</span></code></pre></div>

</div>
</div>
</div>
  <div class="chapter-nav">
<div class="prev"><a href="day1---%E5%88%B0%E8%99%95%E7%9C%8B%E7%9C%8B.html"><span class="header-section-number">2</span> Day1 - 到處看看</a></div>
<div class="next"><a href="%E6%89%80%E6%9C%89%E6%AC%8A%E8%88%87%E7%A7%BB%E5%8B%95.html"><span class="header-section-number">4</span> 所有權與移動</a></div>
</div></main><div class="col-md-3 col-lg-2 d-none d-md-block sidebar sidebar-chapter">
    <nav id="toc" data-toggle="toc" aria-label="On this page"><h2>On this page</h2>
      <ul class="nav navbar-nav">
<li><a class="nav-link" href="#day2---%E5%9E%8B%E6%85%8B"><span class="header-section-number">3</span> Day2 - 型態</a></li>
<li>
<a class="nav-link" href="#%E5%AE%9A%E5%AF%AC%E6%95%B8%E5%AD%97%E5%9E%8B%E6%85%8B"><span class="header-section-number">3.1</span> 定寬數字型態</a><ul class="nav navbar-nav">
<li><a class="nav-link" href="#%E6%95%B4%E6%95%B8%E5%9E%8B%E6%85%8B"><span class="header-section-number">3.1.1</span> 整數型態</a></li>
<li><a class="nav-link" href="#checked-wrapping-saturing%E8%88%87overflowing%E7%AE%97%E8%A1%93"><span class="header-section-number">3.1.2</span> checked, wrapping, saturing與overflowing算術</a></li>
</ul>
</li>
<li><a class="nav-link" href="#%E6%B5%AE%E9%BB%9E%E6%95%B8%E5%9E%8B%E6%85%8B"><span class="header-section-number">3.2</span> 浮點數型態</a></li>
<li><a class="nav-link" href="#%E5%B8%83%E6%9E%97%E5%9E%8B%E6%85%8B"><span class="header-section-number">3.3</span> 布林型態</a></li>
<li><a class="nav-link" href="#tuple%E5%9E%8B%E6%85%8B"><span class="header-section-number">3.4</span> tuple型態</a></li>
<li>
<a class="nav-link" href="#%E6%8C%87%E6%A8%99%E5%9E%8B%E6%85%8B"><span class="header-section-number">3.5</span> 指標型態</a><ul class="nav navbar-nav">
<li><a class="nav-link" href="#reference"><span class="header-section-number">3.5.1</span> Reference</a></li>
<li><a class="nav-link" href="#box"><span class="header-section-number">3.5.2</span> Box</a></li>
<li><a class="nav-link" href="#%E5%8E%9F%E5%A7%8B%E6%8C%87%E6%A8%99"><span class="header-section-number">3.5.3</span> 原始指標</a></li>
<li><a class="nav-link" href="#%E9%99%A3%E5%88%97"><span class="header-section-number">3.5.4</span> 陣列</a></li>
<li><a class="nav-link" href="#%E5%90%91%E9%87%8F"><span class="header-section-number">3.5.5</span> 向量</a></li>
</ul>
</li>
</ul>

      <div class="book-extra">
        <ul class="list-unstyled">
<li><a id="book-source" href="https://github.com/rstudio/bookdown-demo/blob/master/02-Day2.Rmd">View source <i class="fab fa-github"></i></a></li>
          <li><a id="book-edit" href="https://github.com/rstudio/bookdown-demo/edit/master/02-Day2.Rmd">Edit this page <i class="fab fa-github"></i></a></li>
        </ul>
</div>
    </nav>
</div>

</div>
</div> <!-- .container -->

<footer class="bg-primary text-light mt-5"><div class="container"><div class="row">

  <div class="col-12 col-md-6 mt-3">
    <p>"<strong>Rust之書</strong>" was written by 董宸賓. It was last built on 2024-08-14.</p>
  </div>

  <div class="col-12 col-md-6 mt-3">
    <p>This book was built by the <a class="text-light" href="https://bookdown.org">bookdown</a> R package.</p>
  </div>

</div></div>
</footer><!-- dynamically load mathjax for compatibility with self-contained --><script>
  (function () {
    var script = document.createElement("script");
    script.type = "text/javascript";
    var src = "true";
    if (src === "" || src === "true") src = "https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.9/latest.js?config=TeX-MML-AM_CHTML";
    if (location.protocol !== "file:")
      if (/^https?:/.test(src))
        src = src.replace(/^https?:/, '');
    script.src = src;
    document.getElementsByTagName("head")[0].appendChild(script);
  })();
</script><script type="text/x-mathjax-config">const popovers = document.querySelectorAll('a.footnote-ref[data-toggle="popover"]');
for (let popover of popovers) {
  const div = document.createElement('div');
  div.setAttribute('style', 'position: absolute; top: 0, left:0; width:0, height:0, overflow: hidden; visibility: hidden;');
  div.innerHTML = popover.getAttribute('data-content');

  var has_math = div.querySelector("span.math");
  if (has_math) {
    document.body.appendChild(div);
    MathJax.Hub.Queue(["Typeset", MathJax.Hub, div]);
    MathJax.Hub.Queue(function() {
      popover.setAttribute('data-content', div.innerHTML);
      document.body.removeChild(div);
    })
  }
}
</script>
</body>
</html>
