# Day2 - 型態

本章介紹rust基本型態，他們的型態都有具體的機器等級對映物，因此他們的成本皆是可預測的。種類相當繁多，沒必要都「**背**」下來，隨著寫多了就記得下來了！

<link href="https://fonts.googleapis.com/icon?family=Material+Icons" rel="stylesheet">


```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
library(distill)
library(rmarkdown)
library(rextendr)
```

Rust語言某種程度上是圍繞型態打造的，在簡單性和成本之間取得平衡，能保持記憶體與執行緒安全，同時透過泛型型態和trait保持彈性。

本章介紹Rust基本型態，他們的型態都有**具體的機器等級對映物**，因此他們的成本皆是可預測的。

目前，你大概知道Rust是一種靜態語言，且對型態有強烈的意識。你必須在編譯前就對型態有所規劃，這與動態語言例如R或JavaScript有很大的不同。

不過與另外一門以安全興著稱的Java相比，rust的型態系統更為靈活，且更為強大。

Rust內建有**型態推斷機制**，在實務上，有許多變數或運算實際上只適合一種型態，於此，Rust允許你省略型態宣告，而由編譯器推斷型態。

你當然可以把每個型態都寫下來，但這樣做會讓程式碼變得冗長，且不易閱讀。

```{Rust}
fn build_vector() -> Vec<i16>{
  let mut v: Vec<i16> = Vec::<i16>::new();
  v.push(10i16);
  v.push(20i16);
}
```

從函式的回傳型態看來，v必定是Vec<i16>，也就是16-bit帶正負號整數向量，而推入之元素也必定是i16

因此，Rust允許你省略型態宣告，而由編譯器推斷型態。

```{Rust}
fn build_vector() -> Vec<i16>{
  let mut v = Vec::new();
  v.push(10);
  v.push(20);
}
```


## 定寬數字型態

字寬數字型態是Rust的基礎，是配合絕大多數的**現代處理器**的硬體所實作的型態。雖然定寬的數字型態有可能溢出或失去準度，但在多數情況下已經夠用，但這比任意精度準數和精確的有理數型態款幾千倍。如果你還是想這樣表示，你可以試試num crate。


<table>
  <tr>
    <th>大小</th>
    <th>無正負好整數</th>
    <th>帶正負號整數</th>
    <th>浮點數</th>
  </tr>
  <tr>
    <td>8-bit</td>
    <td>u8</td>
    <td>i8</td>
    <td>x</td>
  </tr>
  <tr>
    <td>16-bit</td>
    <td>u16</td>
    <td>i16</td>
    <td>x</td>
  </tr>
  <tr>
    <td>32-bit</td>
    <td>u32</td>
    <td>i32</td>
    <td>f32</td>
  </tr>
  <tr>
    <td>64-bit</td>
    <td>u64</td>
    <td>i64</td>
    <td>f64</td>
  </tr>
  <tr>
    <td>128</td>
    <td>u128</td>
    <td>i128</td>
    <td>x</td>
  </tr>
  <tr>
    <td>arch</td>
    <td>usize</td>
    <td>isize</td>
    <td>x</td>
  </tr>
</table>

arch型態是指機器字寬，通常是**32**或**64**位元，usize和isize是指機器字寬的無正負號整數型態，通常用來表示記憶體位置。


### 整數型態

Rust的整數型態分為**有無帶正負號**的整數，而他們都是使用2的補數表示法。<br>
例如：i8的範圍是$-2^7$到$2^7-1$，u8的範圍是$0$到$2^8-1$

Rust的整數常數可以加上**後綴詞**來表示型態，例如：`10u8`表示8-bit無正負號整數10，`10i16`表示16-bit帶正負號整數10。

如果沒有後綴詞明確指出該型態，Rust會嘗試推斷型態，但如果無法推斷，則會報錯。

另外，前綴0x表示16進位，0o表示8進位，0b表示2進位。

有一個提升閱讀性的小技巧，你可以使用下**底線來分隔數字或型態後綴詞**，例如：`1_000_000_u32`表示32-bit無正負號整數1000000。

如果你想要轉換整數型態，你可以使用**as**關鍵詞，之後會詳細介紹。

```{Rust}
assert_eq!(  10_i8 as u16, 10_u16);

assert_eq!(  -1_i16 as i32, -1_i32);//符號擴展
assert_eq!(65535_u16 as i32, 65535_i32);//零擴展
```

標準程式庫提供了一些整數運算的method

例如：abs()返回絕對值，wrapping_add()返回溢出時的結果，saturating_add()返回飽和時的結果，checked_add()返回溢出時的None，否則返回Some。


### checked, wrapping, saturing與overflowing算術

**當整數運算溢出時，在debug buid裡，Rust會panic**，而在release build裡，Rust會進行溢出檢查，並返回一個**未定義的結果**，我們將這種模式稱作**wrap around**，該結果相當於「在數學上正確的結果」modulo「值得範圍」。

例如，以下程式在debug build裡會panic，而在release build裡會環繞為負數，而且迴圈會無期限地執行下去。

```{Rust}
let mut i = 1;
loop{
  i *= 10;//panic：試著執行溢位乘法
          //(但只有在debug build裡)
}
```


如果你不想要這種預設行為，整數型態提供你一些方法，這些方法共分4類

1. **checked_XXX()**：返回Option<T>，若數學上正確的結果無法用該型態到值來表示，則返回None，否則返回Some(值)。

```{Rust}
// 10+20=30，結果在u8的範圍內
assert_eq!(10_u8.checked_add(20), Some(30));


// 255+1=256，結果超出u8的範圍
assert_eq!(255_u8.checked_add(1), None);

// 進行加法，當它溢位時panic

let sum = x.checked_add(y).unwrap();

```

2. **wrapping_XXX()**：返回值，當溢位時，返回「在數學上正確的結果」modulo「值得範圍」。

```{Rust}
//第一個在範圍值內沒有問題
// 第二個超出範圍，因此我們獲得250000 modulo$2^16$。
assert_eq!(10000_u16.wrapping_mul(200), 250000);
assert_eq!(10000_u16.wrapping_mul(500), 250000);

// 針對正負運算有可能wrap成負數
assert_eq!(500_i16.wrapping_sub(1000), -500);
```

這個法的優勢在於：他們在所有的buid裡面都會是相同的

3. **saturating_XXX()**：返回值，當溢位時，返回最大或最小值，也就是計算結果被限制在該型態可以表示的最大與最小值範圍內


```{Rust}
assert_eq!(100_u8.saturating_add(200), 255);
assert_eq!(100_u8.saturating_sub(200), 0);
```

除法、餘數逐位元移位沒有saturating版本

4. **overflowing_XXX()**：返回一個tuple，第一個元素是計算結果，第二個元素是一個bool，當溢位時，bool為true，否則為false。

```{Rust}
assert_eq!(100_u8.overflowing_add(200), (44, true));
assert_eq!(100_u8.overflowing_sub(200), (156, true));
```

overflowing在處理位元移動時稍有不同，他們的overflowed只會在移動距離與型態本身的位元寬或更大時才會回傳true，而實際的移動距離是你請求移動距離mod型態的位元寬度。

```{Rust}
// 移動17 bit對u16而言太大，而17 mod 16 = 1
assert_eq!(100_u16.overflowing_shl(17), (200, true));
```

<table>
  <tr>
    <th>運算</th>
    <th>method前綴</th>
    <th>範例</th>
    <th>結果</th>
  </tr>
  <tr>
    <td>加法</td>
    <td>add</td>
    <td>10_u8.checked_add(20)</td>
    <td>Some(30)</td>
  </tr>
  <tr>
    <td>減法</td>
    <td>sub</td>
    <td>10_u8.checked_sub(20)</td>
    <td>None</td>
  </tr>
  <tr>
    <td>乘法</td>
    <td>mul</td>
    <td>128_u8.wrapping_mul(3)</td>
    <td>255</td>
  </tr>
  <tr>
    <td>除法</td>
    <td>div</td>
    <td>64_u16.saturating_div(8)</td>
    <td>8</td>
  </tr>
  <tr>
    <td>餘數</td>
    <td>rem</td>
    <td>64_u16.overflowing_rem(8)</td>
    <td>(0, false)</td>
  </tr>
  <tr>
    <td>負數</td>
    <td>neg</td>
    <td>10_i8.neg()</td>
    <td>-10</td>
  </tr>
  <tr>
    <td>絕對值</td>
    <td>abs</td>
    <td>-10_i8.abs()</td>
    <td>10</td>
  </tr>
  <tr>
    <td>取冪</td>
    <td>pow</td>
    <td>2_u8.checked.pow(8)</td>
    <td>Some(256)</td>
  </tr>
  <tr>
    <td>位元右移</td>
    <td>shr</td>
    <td>40_u32.wrapping_shr(34)</td>
    <td>10</td>
  </tr>
  <tr>
    <td>位元左移</td>
    <td>shl</td>
    <td>10_u32.overflowing_shl(34)</td>
    <td>(0, true)</td>
  </tr>
</table>

## 浮點數型態

一個非常標準的Rust浮點數長這樣：314.926e-4f64

整數：314<br>
小數：926<br>
指數：e-4<br>
後綴：f64

Rust的浮點數分為f32和f64，相當於Java的float和double，他們分別是32-bit和64-bit的IEEE754浮點數。

要讓編譯器知道值為浮點數，你不一定明文型態，但必須要有指數、小數點或後綴型態，如：5.就是合法的浮點數，但5不是。

如果沒有指定型態，但從脈絡可推斷為浮點數，則編譯器會推斷為f64。

f32與f64型態有一些關聯常數是IEEE規定的特殊值，例如INFINITY、NEG_INFINITY、NAN、MIN、MAX等。

```{Rust}
assert_eq!(f32::INFINITY, 1.0/0.0);
assert!((-1. / f32::INFINITY).is_sign_negative());
```


另外，浮點數也提供一些method，例如sqrt()是開根號，exp()是指數函數

```{Rust}
let x = 2.0_f64.exp();
assert_eq!(x, std::f64::consts::E.powf(2.0));
assert_eq!((-1.22f64).sqrt(), std::f64::NAN);
```

請注意，方法呼叫的順位比運算子高，因此在對帶負號的浮點數值做運算時，務必加括號。

Rust不會做隱性轉換，如果你丟給預期做浮點數運算的函式一個整數，Rust會大聲地抱怨給你聽，因此，請善用as關鍵字。雖然不做隱性運算會讓程式碼更加攏長，但這也減少許多bug的發生。

最後，std::f32::consts和std::f64::consts提供了一些常數，例如：PI、E、LOG2_E、LOG10_E、LN_2、LN_10等。

## 布林型態

Rust的布林值，分為true和false，透過一些比較運算子產生

許多語言都為布林判斷偷偷開了後門，如C將字元、整數、指標等隱性轉換為布林值，讓你在if或while裡直接將他們當作條件。但Rust不准你這樣做，即使在短路邏輯用算子&&和||裡也不行。你必須寫出if x!=0{...}，而不是if x{...}。

但你可以可以用as運算子將bool轉換為整數型態，但數字不能反向轉換為布林值。

```{Rust}
assert_eq!(true as i32, 1);
assert_eq!(false as i32, 0);
```


## tuple型態

tuple可以是一對、三個、四個各種不同型態的值組合成的值

例：("Taipei", 25, 100.0)這個tuple的型態是(&str, i32, f64)，你可以用tuple.0、tuple.1、tuple.2來取得裡面的值。

但可惜你只能用常數來獲取值，而非變數，如tuple.0是合法的，但tuple.i是不合法的。

```{extendr}
let tuple = ("Taipei", 25, 100.0);
tuple.0
```


這樣的tuple型態在rust中通常來幫函式回傳多個值，假如你有一個string slice要處理，你可以使用split_at()，這個函式會回傳一個tuple，裡面包含了兩個string slice，分別是原始string slice的前半部和後半部。

該宣告式應該長這樣`fn split_at(&self, mid: usize) -> (&str, &str)`，你可以用let (first, second) = s.split_at(3);來取得這兩個string slice。

```{extendr}
let s = "Taipei";
let (first, second) = s.split_at(3);
rprintln!("{} {}", first, second);
```


我們常常不自覺的使用tuple，例如我們想要將一個file的檔名(&str,pixel(u8),和長寬(usize, usize)，最正規的是寫一個struct，但若作為過渡的資料結構，tuple為你做簡單明確的橋樑。

```{Rust}
fn write_image(filename: &str, pixels: &[u8], width: usize, height: usize)
```

另外一種是當作零tuple，也稱單元型態，只有一個值，寫成()。他出現在Rust需要某種型態，但又缺乏有意義的值可以使用。

例如，不回傳值的函式回傳型態有些回傳這個型態，在std::men::swap函式中，沒有「有意義」的回傳值，而是單純的交換兩個變數的值，他的宣告式如下：

```{Rust}
//<T>代表swap的「泛型」，可以處理任何型態的T參考值。
fn swap<T>(x: &mut T, y: &mut T)
//其實有回傳()，但寫的時候省略
```

另外我們常寫的`Result<(), std::io::Error>`，出錯時回傳std::io::Error的值，而成功則不回傳有意義的值。


## 指標型態

Rust有幾種代表記憶體地址的型態，這是Rust和具備垃圾桶(garbage collection:記憶體回收)機制的語言之巨大差異，也是Rust看似繁瑣的型態系統的一部分。

在Java中，如果class Rectangle中Vector2D upperleft; upperleft是分別建立的另一個Vector2D物件的參考，Java物件內部絕對不會有實際的其他物件。

而Rust為管理並減少記憶體配置，在預設情況，值是崁套的，假設一個((0,0), (144, 122))值存成4個相鄰的整數。如果你將它存入一個區域變數，你會得到一個寬為四個整數的「區域變數」。Rust不會在heap上配置記憶體，除非你明確要求。


這樣的做法是記憶體友好的，但如果要讓一個值指向另一個值，你必須明確的使用指標。強大的是，在safe Rust裡的標型態都受到約束，以消除為定義行為。


### Reference

在入門段，我們常常使用簡單的ref來做參考，在執行期，一個指向i32的參考是一個機器word，保存的是i32的「地址」，該位子可能在stack也可能在heap。

運算式&x產生一個指向x的參考，而*ptr則是取得ptr指向的值。多提一嘴，Rust參考絕對不會是null，並會記錄所有權與生命期，諸如懸空指標、重複釋出與無效指標的會在編譯期被排除。

兩種參考型態：

  1. &T：不可變參考，你不能透過它來修改值。一個值可以有多個共享參考
  
  2. &mut T：可變參考，你可以透過它來修改值。一個值只能有一個可變參考，且在該參考存在期間，不可有其他參考存在。
  
這兩種區別在編譯器檢查與執行時，可以確保程式的安全。

### Box

若你想在heap上配置值，最簡單的就是呼叫Box::new()

```{extendr}
let x = 10;
let b = Box::new(x);// 在heap上配置一個i32

let c = *b;// 取得b指向的值
let z = &b;// 取得b的參考

rprintln!("{} {} {}", c, b, z);

```

b的型態是Box<i32>，當b離開作用域時，記憶體會被立刻釋出，除非**移動**，例如被回傳。移動是Rust非常重要的概念會提到，我們會在後面章節詳細介紹。

### 原始指標

原始指標像C++同款，這在Rust是unsafe的，因爲程式不會追蹤它，因此他容易出錯，例如指向null或未初始化的記憶體。



### 陣列

陣列的型態是[T; N]，T就像前面所述代表**型態**，N是**長度**，大小是執行期決定的常數，不能擴增或縮減。

陣列有多種寫法，最簡單也常見的就是放在中括號裡

```{Rust}
let a [u8; 3] = [1, 2, 3];
```

如果要寫一個長陣列，裏面放差不多的值，可以寫成[V; N]，V是值，N是長度，例如：

```{Rust}
[0_u8; 1024]
```

有些時候會用這種方法代表緩衝區，如上例就是1KB的緩衝區。

如上述，因爲判斷長度在編譯期就是固定的，所以你不能用變數n來產生有n個值的陣列。

陣列的方法其實都是Rust偷偷將陣列的參考轉換成silce，因此你才能在陣列上使用slice的方法。

```{extendr }
let mut a = [5, 4, 3, 2, 1];

a.sort();

for x in a {
  rprintln!("{}", x);
}
```

### 向量

最原始的向量是長這樣ＬVec<T>，看到了嗎，只有型態沒長度，這代表你可以隨著時變去改變大小，他會在heap上配置記憶體，並且會在不需要時自動釋放。

如果你知道向量的長度，你可以用vec!宏來建立，例如：

```{Rust}
let vec = vec![1, 2, 3, 4, 5];
```

因為他是向量，你可以繼續加入值：

```{Rust}
vec.push(6);
```

另外一種方式是呼叫Vec::new()來產生新的向量，然後用push()來加入值。

```{Rust}
let mut vec = Vec::new();
vec.push(1);
vec.push(2);
```

也可以用iterator產的生的值來建立向量，例如：

```{extendr}
let a = [5, 4, 3, 2, 1];
let mut vec = Vec::new();

for x in a {
  vec.push(x);
}

for x in vec {
  rprintln!("{}", x);
}
```

向陣列一樣，向量也會找到slice的方法。

如果你事先知道向量的長度，你可以使用Vec::with_capacity()來代替Vec::new()，這樣預先留下夠大的緩衝區，可以減少向量擴增時的記憶體配置次數。

在設計函式時常常用到這樣的優勢，如colloect()，iterator會事先知道向量有幾個值，以正確的預先配置回傳向量。

向量的**len()**會告訴你向量的長度，**capacity()**會告訴你在不重新配置的情況下可以容納的元素。


```{extendr}
let mut vec = Vec::with_capacity(2);
rprintln!("len:{}, capacity:{}", vec.len(), vec.capacity());

vec.push(1);
vec.push(2);
rprintln!("len:{}, capacity:{}", vec.len(), vec.capacity());

vec.push(3);
rprintln!("len:{}, capacity:{}", vec.len(), vec.capacity());

```


你可以用**insert(位置, 值)**來插入元素，用**remove(位置)**來移除元素

```{extendr}
let mut vec = vec![1, 2, 3, 4, 5];

//在1與2之間插入0
vec.insert(1, 0);

//移除3
vec.remove(3);

rprintln!("{:?}", vec);
```

最後介紹**pop()**，他會從Vec<T> pop值會得到Option<T>，如果最後一個值是v，則回傳Some(v)，否則回傳None。

```{extendr}
let mut vec = vec!["哈囉", "世界"];

rprintln!("{:?}", vec.pop());
rprintln!("{:?}", vec.pop());
rprintln!("{:?}", vec.pop());
```

```{extendr}
use std::process::Command;

let mut cmd = Command::new("ls");
let res = cmd.output();
rprintln!("{:?}", res);
```