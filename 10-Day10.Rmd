# Day10-tarit與泛型

## 使用trait

Ruat是ㄧ種型態語言，你使用程式庫的標準型態或自訂型態，再為他們寫種方法。

而trait代表一種功能，是型態可做的事，如：

- 實作`std::iter::Iterator`的值能產生一系列值

- 實作`std::clone::Clone`的值可以在記體裡面製作副本

- 實作`std::fmt::Debug`可以用println!()與{:?}印出


以上三種都是trait都是Rust標準庫的一部分，許多標準型態都實作了他們

- Range<i32>(0..10的型態)實作了Iterator trait，還有slice、Hashmap等

- 大多數的標準程式庫型態都實作了Clone，沒有實作的可能代表與記憶體資料無關

- 同樣的、大多數的標準程式庫型態都支援Debug

trait方法必須在作用域內，否則你無法使用它的方法：

```{Rust}
let mut buf: Vec<u8> = vec![];
buf.write_all(b"hello")?; //找不到write_aLL方法
```

編譯器會請你加入`use std::io::Write;。加入後可以修復這個問題。

```{Rust}
use std::io::Write;

let mut buf: Vec<u8> = vec![];
buf.write_all(b"hello")?;
```









